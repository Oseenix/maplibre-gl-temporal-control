{"version":3,"file":"index.umd.cjs","sources":["../src/icons.ts","../src/temparal.ts","../node_modules/.pnpm/@maplibre+maplibre-gl-style-spec@22.0.1/node_modules/@maplibre/maplibre-gl-style-spec/dist/index.mjs","../src/colorbar.ts"],"sourcesContent":["// https://materialdesignicons.com/\nexport const pauseSvg =\n\t'<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\"><title>pause</title><path d=\"M14,19H18V5H14M6,19H10V5H6V19Z\" /></svg>';\nexport const playSvg =\n\t'<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\"><title>play</title><path d=\"M8,5.14V19.14L19,12.14L8,5.14Z\" /></svg>';\nexport const reloadSvg =\n\t'<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\"><title>reload</title><path d=\"M2 12C2 16.97 6.03 21 11 21C13.39 21 15.68 20.06 17.4 18.4L15.9 16.9C14.63 18.25 12.86 19 11 19C4.76 19 1.64 11.46 6.05 7.05C10.46 2.64 18 5.77 18 12H15L19 16H19.1L23 12H20C20 7.03 15.97 3 11 3C6.03 3 2 7.03 2 12Z\" /></svg>';\nexport const skipBackwardSvg =\n\t'<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\"><title>skip-backward</title><path d=\"M20,5V19L13,12M6,5V19H4V5M13,5V19L6,12\" /></svg>';\nexport const skipForwardSvg =\n\t'<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\"><title>skip-forward</title><path d=\"M4,5V19L11,12M18,5V19H20V5M11,5V19L18,12\" /></svg>';\n","import type {\n\tIControl,\n\tMap,\n\tLayerSpecification,\n\tControlPosition,\n} from 'maplibre-gl';\n\nimport {\n\tplaySvg,\n\tpauseSvg,\n\treloadSvg,\n\tskipBackwardSvg,\n\tskipForwardSvg,\n} from './icons';\n\nconst ACTIVE_BUTTON_COLOR = 'rgb(204, 204, 204)';\n\ntype ContainerOptions = {\n\tlength: number;\n\tinterval: number;\n\tonSliderValueChange: () => void;\n};\n\nconst makeImg = (svg: string): HTMLImageElement => {\n\tconst img = document.createElement('img');\n\timg.src = `data:image/svg+xml,${encodeURIComponent(svg)}`;\n\timg.style.width = '24px';\n\timg.style.height = '24px';\n\treturn img;\n};\n\nlet timerId: number | undefined;\n\nconst makeContainer = ({\n\tlength,\n\tinterval,\n\tonSliderValueChange,\n}: ContainerOptions) => {\n\t// outest div\n\tconst container = document.createElement('div');\n\tcontainer.classList.add('maplibregl-ctrl');\n\tcontainer.classList.add('maplibregl-ctrl-group');\n\tcontainer.style.width = 'calc(min((500% - 29px), 260px))';\n\tcontainer.style.height = '84px';\n\tcontainer.style.backgroundColor = 'rgba(0, 36, 71, 0.8)';\n\tcontainer.style.textAlign = 'center';\n\n\tconst titleDiv = document.createElement('div');\n\ttitleDiv.innerHTML = '<br />';\n\ttitleDiv.style.marginTop = '4px';\n\tcontainer.appendChild(titleDiv);\n\n\t// temporal slider\n\tconst slider = document.createElement('input');\n\tslider.type = 'range';\n\tslider.value = '0';\n\tslider.min = '0';\n\tslider.max = String(length - 1);\n\tslider.addEventListener('input', () => {\n\t\tonSliderValueChange();\n\t});\n\tslider.style.width = '80%';\n\tslider.style.margin = '4px 0';\n\tcontainer.appendChild(slider);\n\n\t// buttons div\n\t// loop, prev, pause, play, next\n\tconst buttonsDiv = document.createElement('div');\n\tbuttonsDiv.style.display = 'flex';\n\tbuttonsDiv.style.justifyContent = 'center';\n\tbuttonsDiv.style.margin = '4px 0 0 0';\n\n\t// loop button\n\tconst setLoopEnabled = (enabled: boolean) => {\n\t\tloopButton.style.backgroundColor = enabled ? ACTIVE_BUTTON_COLOR : '';\n\t};\n\tconst isLoopEnabled = () =>\n\t\tloopButton.style.backgroundColor === ACTIVE_BUTTON_COLOR;\n\tconst loopButton = document.createElement('button');\n\tloopButton.appendChild(makeImg(reloadSvg));\n\tloopButton.style.border = '0';\n\tloopButton.style.borderRadius = '0';\n\tloopButton.style.marginRight = '16px';\n\tloopButton.style.height = '24px';\n\tloopButton.style.borderRadius = '4px';\n\tloopButton.onclick = () => setLoopEnabled(!isLoopEnabled());\n\tbuttonsDiv.appendChild(loopButton);\n\n\tconst decrement = () => {\n\t\tslider.value = String(Math.max(0, Number(slider.value) - 1));\n\t\tonSliderValueChange();\n\t\treturn Number(slider.min) < Number(slider.value);\n\t};\n\tconst increment = () => {\n\t\tif (\n\t\t\tloopButton.style.backgroundColor !== '' &&\n\t\t\tNumber(slider.value) == Number(slider.max)\n\t\t) {\n\t\t\twhile (decrement()) {}\n\t\t} else {\n\t\t\tslider.value = String(\n\t\t\t\tMath.min(Number(slider.max), Number(slider.value) + 1),\n\t\t\t);\n\t\t}\n\t\tonSliderValueChange();\n\t\treturn Number(slider.value) < Number(slider.max);\n\t};\n\n\t// prev button\n\tconst prevButton = document.createElement('button');\n\tprevButton.appendChild(makeImg(skipBackwardSvg));\n\tprevButton.onclick = decrement;\n\tprevButton.style.border = '0';\n\tprevButton.style.height = '24px';\n\tprevButton.style.borderRadius = '4px';\n\n\t// pause button\n\tconst pause = () => {\n\t\tif (timerId === undefined) return;\n\t\tclearInterval(timerId);\n\t\ttimerId = undefined;\n\t\tpauseButton.onclick = null;\n\t\tplayButton.style.backgroundColor = '';\n\t};\n\tconst pauseButton = document.createElement('button');\n\tpauseButton.appendChild(makeImg(pauseSvg));\n\tpauseButton.style.border = '0';\n\tpauseButton.style.height = '24px';\n\tpauseButton.style.borderRadius = '4px';\n\tpauseButton.onclick = pause;\n\n\t// play button\n\tconst isPlaying = () =>\n\t\tplayButton.style.backgroundColor === ACTIVE_BUTTON_COLOR;\n\tconst play = () => {\n\t\tif (isPlaying()) return;\n\t\tplayButton.style.backgroundColor = ACTIVE_BUTTON_COLOR;\n\t\ttimerId = setInterval(() => {\n\t\t\tincrement();\n\t\t}, interval);\n\t};\n\n\tconst playButton = document.createElement('button');\n\tplayButton.appendChild(makeImg(playSvg));\n\tplayButton.style.border = '0';\n\tplayButton.style.height = '24px';\n\tplayButton.style.borderRadius = '4px';\n\tplayButton.onclick = play;\n\n\t// next button\n\tconst nextButton = document.createElement('button');\n\tnextButton.appendChild(makeImg(skipForwardSvg));\n\tnextButton.style.border = '0';\n\tnextButton.style.height = '24px';\n\tnextButton.style.borderRadius = '4px';\n\tnextButton.onclick = increment;\n\n\tbuttonsDiv.appendChild(prevButton);\n\tbuttonsDiv.appendChild(pauseButton);\n\tbuttonsDiv.appendChild(playButton);\n\tbuttonsDiv.appendChild(nextButton);\n\n\tcontainer.appendChild(buttonsDiv);\n\n\treturn {\n\t\tcontainer,\n\t\ttitleDiv,\n\t\tslider,\n\t\tincrement,\n\t\tdecrement,\n\t\tisPlaying,\n\t\tplay,\n\t\tpause,\n\t\tisLoopEnabled,\n\t\tsetLoopEnabled,\n\t};\n};\n\ntype TemporalFrame = {\n\ttitle: string;\n\tlayers: LayerSpecification[];\n};\n\ntype Options = {\n\tposition?: ControlPosition;\n\tinterval?: number;\n\tperformance?: boolean;\n};\n\nexport default class TemporalControl implements IControl {\n\tprivate map: Map | undefined;\n\tprivate options: Options;\n\n\tprivate container: HTMLDivElement;\n\tprivate containerTitle!: HTMLDivElement;\n\tprivate temporalSlider!: HTMLInputElement;\n\tprivate temporalFrames: TemporalFrame[];\n\n\tnext: () => boolean;\n\tprev: () => boolean;\n\tplay: () => void;\n\tpause: () => void;\n\tisPlaying: () => boolean;\n\tisLoopEnabled: () => boolean;\n\tsetLoopEnabled: (enabled: boolean) => void;\n\tgoto: (index: number) => void;\n\n\tconstructor(temporalFrames: TemporalFrame[], options: Options = {}) {\n\t\tthis.temporalFrames = temporalFrames;\n\t\tthis.options = options;\n\n\t\tconst containerOptions: ContainerOptions = {\n\t\t\tlength: this.temporalFrames.length,\n\t\t\tinterval: this.options.interval || 500,\n\t\t\tonSliderValueChange: () => this.refresh(),\n\t\t};\n\n\t\tconst {\n\t\t\tcontainer,\n\t\t\ttitleDiv,\n\t\t\tslider,\n\t\t\tincrement,\n\t\t\tdecrement,\n\t\t\tplay,\n\t\t\tpause,\n\t\t\tisPlaying,\n\t\t\tisLoopEnabled,\n\t\t\tsetLoopEnabled,\n\t\t} = makeContainer(containerOptions);\n\n\t\tthis.container = container;\n\t\tthis.containerTitle = titleDiv;\n\t\tthis.temporalSlider = slider;\n\t\tthis.next = increment;\n\t\tthis.prev = decrement;\n\t\tthis.play = play;\n\t\tthis.pause = pause;\n\t\tthis.isPlaying = isPlaying;\n\t\tthis.isLoopEnabled = isLoopEnabled;\n\t\tthis.setLoopEnabled = setLoopEnabled;\n\t\tthis.goto = (idx: number) => {\n\t\t\tslider.value = String(\n\t\t\t\tMath.min(this.temporalFrames.length - 1, Math.max(0, idx)),\n\t\t\t);\n\t\t\tthis.refresh();\n\t\t};\n\t}\n\n\tonAdd(map: Map) {\n\t\tthis.map = map;\n\t\tmap.getContainer().appendChild(this.container);\n\n\t\tthis.map.once('styledata', () => {\n\t\t\tthis.refresh();\n\t\t});\n\n\t\treturn this.container;\n\t}\n\n\tonRemove() {\n\t\tthis.container.parentNode?.removeChild(this.container);\n\t\tthis.map = undefined;\n\t}\n\n\tgetDefaultPosition(): ControlPosition {\n\t\treturn 'bottom-left';\n\t}\n\n\trefresh() {\n\t\tconst sliderValue = Number(this.temporalSlider.value);\n\t\tthis.containerTitle.innerHTML = this.temporalFrames[sliderValue].title;\n\t\tconst visibleLayerIds = this.temporalFrames[sliderValue].layers.map(\n\t\t\t(layer) => layer.id,\n\t\t);\n\t\tthis.temporalFrames.forEach((temporalFrame) => {\n\t\t\ttemporalFrame.layers.forEach((layer) =>\n\t\t\t\tthis.setVisible(layer, visibleLayerIds.includes(layer.id)),\n\t\t\t);\n\t\t});\n\t}\n\n\tprivate setVisible(layer: LayerSpecification, isVisible = true) {\n\t\tif (\n\t\t\tlayer.type === 'raster' ||\n\t\t\tlayer.type === 'fill' ||\n\t\t\tlayer.type === 'circle' ||\n\t\t\tlayer.type === 'line'\n\t\t) {\n\t\t\tif (layer.type === 'raster') {\n\t\t\t\t// when raster, set opacity as visibility for background loading\n\t\t\t\tthis.map?.setPaintProperty(\n\t\t\t\t\tlayer.id,\n\t\t\t\t\t`${layer.type}-opacity-transition`,\n\t\t\t\t\t{\n\t\t\t\t\t\t// set disable fade-in transition\n\t\t\t\t\t\tduration: 0,\n\t\t\t\t\t},\n\t\t\t\t);\n\t\t\t}\n\t\t\tlet opacity;\n\t\t\tif (isVisible) {\n\t\t\t\t// @ts-ignore\n\t\t\t\topacity = layer.paint?.[`${layer.type}-opacity`] || 1;\n\t\t\t} else {\n\t\t\t\topacity = this.options.performance ? 0.000000000000000000001 : 0;\n\t\t\t}\n\n\t\t\tthis.map?.setPaintProperty(layer.id, `${layer.type}-opacity`, opacity);\n\t\t} else {\n\t\t\tthis.map?.setLayoutProperty(\n\t\t\t\tlayer.id,\n\t\t\t\t'visibility',\n\t\t\t\tisVisible ? 'visible' : 'none',\n\t\t\t);\n\t\t}\n\t}\n}\n\n","var $version = 8;\nvar $root = {\n\tversion: {\n\t\trequired: true,\n\t\ttype: \"enum\",\n\t\tvalues: [\n\t\t\t8\n\t\t]\n\t},\n\tname: {\n\t\ttype: \"string\"\n\t},\n\tmetadata: {\n\t\ttype: \"*\"\n\t},\n\tcenter: {\n\t\ttype: \"array\",\n\t\tvalue: \"number\"\n\t},\n\tcenterAltitude: {\n\t\ttype: \"number\"\n\t},\n\tzoom: {\n\t\ttype: \"number\"\n\t},\n\tbearing: {\n\t\ttype: \"number\",\n\t\t\"default\": 0,\n\t\tperiod: 360,\n\t\tunits: \"degrees\"\n\t},\n\tpitch: {\n\t\ttype: \"number\",\n\t\t\"default\": 0,\n\t\tunits: \"degrees\"\n\t},\n\troll: {\n\t\ttype: \"number\",\n\t\t\"default\": 0,\n\t\tunits: \"degrees\"\n\t},\n\tlight: {\n\t\ttype: \"light\"\n\t},\n\tsky: {\n\t\ttype: \"sky\"\n\t},\n\tprojection: {\n\t\ttype: \"projection\"\n\t},\n\tterrain: {\n\t\ttype: \"terrain\"\n\t},\n\tsources: {\n\t\trequired: true,\n\t\ttype: \"sources\"\n\t},\n\tsprite: {\n\t\ttype: \"sprite\"\n\t},\n\tglyphs: {\n\t\ttype: \"string\"\n\t},\n\ttransition: {\n\t\ttype: \"transition\"\n\t},\n\tlayers: {\n\t\trequired: true,\n\t\ttype: \"array\",\n\t\tvalue: \"layer\"\n\t}\n};\nvar sources = {\n\t\"*\": {\n\t\ttype: \"source\"\n\t}\n};\nvar source = [\n\t\"source_vector\",\n\t\"source_raster\",\n\t\"source_raster_dem\",\n\t\"source_geojson\",\n\t\"source_video\",\n\t\"source_image\"\n];\nvar source_vector = {\n\ttype: {\n\t\trequired: true,\n\t\ttype: \"enum\",\n\t\tvalues: {\n\t\t\tvector: {\n\t\t\t}\n\t\t}\n\t},\n\turl: {\n\t\ttype: \"string\"\n\t},\n\ttiles: {\n\t\ttype: \"array\",\n\t\tvalue: \"string\"\n\t},\n\tbounds: {\n\t\ttype: \"array\",\n\t\tvalue: \"number\",\n\t\tlength: 4,\n\t\t\"default\": [\n\t\t\t-180,\n\t\t\t-85.051129,\n\t\t\t180,\n\t\t\t85.051129\n\t\t]\n\t},\n\tscheme: {\n\t\ttype: \"enum\",\n\t\tvalues: {\n\t\t\txyz: {\n\t\t\t},\n\t\t\ttms: {\n\t\t\t}\n\t\t},\n\t\t\"default\": \"xyz\"\n\t},\n\tminzoom: {\n\t\ttype: \"number\",\n\t\t\"default\": 0\n\t},\n\tmaxzoom: {\n\t\ttype: \"number\",\n\t\t\"default\": 22\n\t},\n\tattribution: {\n\t\ttype: \"string\"\n\t},\n\tpromoteId: {\n\t\ttype: \"promoteId\"\n\t},\n\tvolatile: {\n\t\ttype: \"boolean\",\n\t\t\"default\": false\n\t},\n\t\"*\": {\n\t\ttype: \"*\"\n\t}\n};\nvar source_raster = {\n\ttype: {\n\t\trequired: true,\n\t\ttype: \"enum\",\n\t\tvalues: {\n\t\t\traster: {\n\t\t\t}\n\t\t}\n\t},\n\turl: {\n\t\ttype: \"string\"\n\t},\n\ttiles: {\n\t\ttype: \"array\",\n\t\tvalue: \"string\"\n\t},\n\tbounds: {\n\t\ttype: \"array\",\n\t\tvalue: \"number\",\n\t\tlength: 4,\n\t\t\"default\": [\n\t\t\t-180,\n\t\t\t-85.051129,\n\t\t\t180,\n\t\t\t85.051129\n\t\t]\n\t},\n\tminzoom: {\n\t\ttype: \"number\",\n\t\t\"default\": 0\n\t},\n\tmaxzoom: {\n\t\ttype: \"number\",\n\t\t\"default\": 22\n\t},\n\ttileSize: {\n\t\ttype: \"number\",\n\t\t\"default\": 512,\n\t\tunits: \"pixels\"\n\t},\n\tscheme: {\n\t\ttype: \"enum\",\n\t\tvalues: {\n\t\t\txyz: {\n\t\t\t},\n\t\t\ttms: {\n\t\t\t}\n\t\t},\n\t\t\"default\": \"xyz\"\n\t},\n\tattribution: {\n\t\ttype: \"string\"\n\t},\n\tvolatile: {\n\t\ttype: \"boolean\",\n\t\t\"default\": false\n\t},\n\t\"*\": {\n\t\ttype: \"*\"\n\t}\n};\nvar source_raster_dem = {\n\ttype: {\n\t\trequired: true,\n\t\ttype: \"enum\",\n\t\tvalues: {\n\t\t\t\"raster-dem\": {\n\t\t\t}\n\t\t}\n\t},\n\turl: {\n\t\ttype: \"string\"\n\t},\n\ttiles: {\n\t\ttype: \"array\",\n\t\tvalue: \"string\"\n\t},\n\tbounds: {\n\t\ttype: \"array\",\n\t\tvalue: \"number\",\n\t\tlength: 4,\n\t\t\"default\": [\n\t\t\t-180,\n\t\t\t-85.051129,\n\t\t\t180,\n\t\t\t85.051129\n\t\t]\n\t},\n\tminzoom: {\n\t\ttype: \"number\",\n\t\t\"default\": 0\n\t},\n\tmaxzoom: {\n\t\ttype: \"number\",\n\t\t\"default\": 22\n\t},\n\ttileSize: {\n\t\ttype: \"number\",\n\t\t\"default\": 512,\n\t\tunits: \"pixels\"\n\t},\n\tattribution: {\n\t\ttype: \"string\"\n\t},\n\tencoding: {\n\t\ttype: \"enum\",\n\t\tvalues: {\n\t\t\tterrarium: {\n\t\t\t},\n\t\t\tmapbox: {\n\t\t\t},\n\t\t\tcustom: {\n\t\t\t}\n\t\t},\n\t\t\"default\": \"mapbox\"\n\t},\n\tredFactor: {\n\t\ttype: \"number\",\n\t\t\"default\": 1\n\t},\n\tblueFactor: {\n\t\ttype: \"number\",\n\t\t\"default\": 1\n\t},\n\tgreenFactor: {\n\t\ttype: \"number\",\n\t\t\"default\": 1\n\t},\n\tbaseShift: {\n\t\ttype: \"number\",\n\t\t\"default\": 0\n\t},\n\tvolatile: {\n\t\ttype: \"boolean\",\n\t\t\"default\": false\n\t},\n\t\"*\": {\n\t\ttype: \"*\"\n\t}\n};\nvar source_geojson = {\n\ttype: {\n\t\trequired: true,\n\t\ttype: \"enum\",\n\t\tvalues: {\n\t\t\tgeojson: {\n\t\t\t}\n\t\t}\n\t},\n\tdata: {\n\t\trequired: true,\n\t\ttype: \"*\"\n\t},\n\tmaxzoom: {\n\t\ttype: \"number\",\n\t\t\"default\": 18\n\t},\n\tattribution: {\n\t\ttype: \"string\"\n\t},\n\tbuffer: {\n\t\ttype: \"number\",\n\t\t\"default\": 128,\n\t\tmaximum: 512,\n\t\tminimum: 0\n\t},\n\tfilter: {\n\t\ttype: \"*\"\n\t},\n\ttolerance: {\n\t\ttype: \"number\",\n\t\t\"default\": 0.375\n\t},\n\tcluster: {\n\t\ttype: \"boolean\",\n\t\t\"default\": false\n\t},\n\tclusterRadius: {\n\t\ttype: \"number\",\n\t\t\"default\": 50,\n\t\tminimum: 0\n\t},\n\tclusterMaxZoom: {\n\t\ttype: \"number\"\n\t},\n\tclusterMinPoints: {\n\t\ttype: \"number\"\n\t},\n\tclusterProperties: {\n\t\ttype: \"*\"\n\t},\n\tlineMetrics: {\n\t\ttype: \"boolean\",\n\t\t\"default\": false\n\t},\n\tgenerateId: {\n\t\ttype: \"boolean\",\n\t\t\"default\": false\n\t},\n\tpromoteId: {\n\t\ttype: \"promoteId\"\n\t}\n};\nvar source_video = {\n\ttype: {\n\t\trequired: true,\n\t\ttype: \"enum\",\n\t\tvalues: {\n\t\t\tvideo: {\n\t\t\t}\n\t\t}\n\t},\n\turls: {\n\t\trequired: true,\n\t\ttype: \"array\",\n\t\tvalue: \"string\"\n\t},\n\tcoordinates: {\n\t\trequired: true,\n\t\ttype: \"array\",\n\t\tlength: 4,\n\t\tvalue: {\n\t\t\ttype: \"array\",\n\t\t\tlength: 2,\n\t\t\tvalue: \"number\"\n\t\t}\n\t}\n};\nvar source_image = {\n\ttype: {\n\t\trequired: true,\n\t\ttype: \"enum\",\n\t\tvalues: {\n\t\t\timage: {\n\t\t\t}\n\t\t}\n\t},\n\turl: {\n\t\trequired: true,\n\t\ttype: \"string\"\n\t},\n\tcoordinates: {\n\t\trequired: true,\n\t\ttype: \"array\",\n\t\tlength: 4,\n\t\tvalue: {\n\t\t\ttype: \"array\",\n\t\t\tlength: 2,\n\t\t\tvalue: \"number\"\n\t\t}\n\t}\n};\nvar layer = {\n\tid: {\n\t\ttype: \"string\",\n\t\trequired: true\n\t},\n\ttype: {\n\t\ttype: \"enum\",\n\t\tvalues: {\n\t\t\tfill: {\n\t\t\t},\n\t\t\tline: {\n\t\t\t},\n\t\t\tsymbol: {\n\t\t\t},\n\t\t\tcircle: {\n\t\t\t},\n\t\t\theatmap: {\n\t\t\t},\n\t\t\t\"fill-extrusion\": {\n\t\t\t},\n\t\t\traster: {\n\t\t\t},\n\t\t\thillshade: {\n\t\t\t},\n\t\t\tbackground: {\n\t\t\t}\n\t\t},\n\t\trequired: true\n\t},\n\tmetadata: {\n\t\ttype: \"*\"\n\t},\n\tsource: {\n\t\ttype: \"string\"\n\t},\n\t\"source-layer\": {\n\t\ttype: \"string\"\n\t},\n\tminzoom: {\n\t\ttype: \"number\",\n\t\tminimum: 0,\n\t\tmaximum: 24\n\t},\n\tmaxzoom: {\n\t\ttype: \"number\",\n\t\tminimum: 0,\n\t\tmaximum: 24\n\t},\n\tfilter: {\n\t\ttype: \"filter\"\n\t},\n\tlayout: {\n\t\ttype: \"layout\"\n\t},\n\tpaint: {\n\t\ttype: \"paint\"\n\t}\n};\nvar layout = [\n\t\"layout_fill\",\n\t\"layout_line\",\n\t\"layout_circle\",\n\t\"layout_heatmap\",\n\t\"layout_fill-extrusion\",\n\t\"layout_symbol\",\n\t\"layout_raster\",\n\t\"layout_hillshade\",\n\t\"layout_background\"\n];\nvar layout_background = {\n\tvisibility: {\n\t\ttype: \"enum\",\n\t\tvalues: {\n\t\t\tvisible: {\n\t\t\t},\n\t\t\tnone: {\n\t\t\t}\n\t\t},\n\t\t\"default\": \"visible\",\n\t\t\"property-type\": \"constant\"\n\t}\n};\nvar layout_fill = {\n\t\"fill-sort-key\": {\n\t\ttype: \"number\",\n\t\texpression: {\n\t\t\tinterpolated: false,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\",\n\t\t\t\t\"feature\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-driven\"\n\t},\n\tvisibility: {\n\t\ttype: \"enum\",\n\t\tvalues: {\n\t\t\tvisible: {\n\t\t\t},\n\t\t\tnone: {\n\t\t\t}\n\t\t},\n\t\t\"default\": \"visible\",\n\t\t\"property-type\": \"constant\"\n\t}\n};\nvar layout_circle = {\n\t\"circle-sort-key\": {\n\t\ttype: \"number\",\n\t\texpression: {\n\t\t\tinterpolated: false,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\",\n\t\t\t\t\"feature\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-driven\"\n\t},\n\tvisibility: {\n\t\ttype: \"enum\",\n\t\tvalues: {\n\t\t\tvisible: {\n\t\t\t},\n\t\t\tnone: {\n\t\t\t}\n\t\t},\n\t\t\"default\": \"visible\",\n\t\t\"property-type\": \"constant\"\n\t}\n};\nvar layout_heatmap = {\n\tvisibility: {\n\t\ttype: \"enum\",\n\t\tvalues: {\n\t\t\tvisible: {\n\t\t\t},\n\t\t\tnone: {\n\t\t\t}\n\t\t},\n\t\t\"default\": \"visible\",\n\t\t\"property-type\": \"constant\"\n\t}\n};\nvar layout_line = {\n\t\"line-cap\": {\n\t\ttype: \"enum\",\n\t\tvalues: {\n\t\t\tbutt: {\n\t\t\t},\n\t\t\tround: {\n\t\t\t},\n\t\t\tsquare: {\n\t\t\t}\n\t\t},\n\t\t\"default\": \"butt\",\n\t\texpression: {\n\t\t\tinterpolated: false,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-constant\"\n\t},\n\t\"line-join\": {\n\t\ttype: \"enum\",\n\t\tvalues: {\n\t\t\tbevel: {\n\t\t\t},\n\t\t\tround: {\n\t\t\t},\n\t\t\tmiter: {\n\t\t\t}\n\t\t},\n\t\t\"default\": \"miter\",\n\t\texpression: {\n\t\t\tinterpolated: false,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\",\n\t\t\t\t\"feature\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-driven\"\n\t},\n\t\"line-miter-limit\": {\n\t\ttype: \"number\",\n\t\t\"default\": 2,\n\t\trequires: [\n\t\t\t{\n\t\t\t\t\"line-join\": \"miter\"\n\t\t\t}\n\t\t],\n\t\texpression: {\n\t\t\tinterpolated: true,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-constant\"\n\t},\n\t\"line-round-limit\": {\n\t\ttype: \"number\",\n\t\t\"default\": 1.05,\n\t\trequires: [\n\t\t\t{\n\t\t\t\t\"line-join\": \"round\"\n\t\t\t}\n\t\t],\n\t\texpression: {\n\t\t\tinterpolated: true,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-constant\"\n\t},\n\t\"line-sort-key\": {\n\t\ttype: \"number\",\n\t\texpression: {\n\t\t\tinterpolated: false,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\",\n\t\t\t\t\"feature\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-driven\"\n\t},\n\tvisibility: {\n\t\ttype: \"enum\",\n\t\tvalues: {\n\t\t\tvisible: {\n\t\t\t},\n\t\t\tnone: {\n\t\t\t}\n\t\t},\n\t\t\"default\": \"visible\",\n\t\t\"property-type\": \"constant\"\n\t}\n};\nvar layout_symbol = {\n\t\"symbol-placement\": {\n\t\ttype: \"enum\",\n\t\tvalues: {\n\t\t\tpoint: {\n\t\t\t},\n\t\t\tline: {\n\t\t\t},\n\t\t\t\"line-center\": {\n\t\t\t}\n\t\t},\n\t\t\"default\": \"point\",\n\t\texpression: {\n\t\t\tinterpolated: false,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-constant\"\n\t},\n\t\"symbol-spacing\": {\n\t\ttype: \"number\",\n\t\t\"default\": 250,\n\t\tminimum: 1,\n\t\tunits: \"pixels\",\n\t\trequires: [\n\t\t\t{\n\t\t\t\t\"symbol-placement\": \"line\"\n\t\t\t}\n\t\t],\n\t\texpression: {\n\t\t\tinterpolated: true,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-constant\"\n\t},\n\t\"symbol-avoid-edges\": {\n\t\ttype: \"boolean\",\n\t\t\"default\": false,\n\t\texpression: {\n\t\t\tinterpolated: false,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-constant\"\n\t},\n\t\"symbol-sort-key\": {\n\t\ttype: \"number\",\n\t\texpression: {\n\t\t\tinterpolated: false,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\",\n\t\t\t\t\"feature\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-driven\"\n\t},\n\t\"symbol-z-order\": {\n\t\ttype: \"enum\",\n\t\tvalues: {\n\t\t\tauto: {\n\t\t\t},\n\t\t\t\"viewport-y\": {\n\t\t\t},\n\t\t\tsource: {\n\t\t\t}\n\t\t},\n\t\t\"default\": \"auto\",\n\t\texpression: {\n\t\t\tinterpolated: false,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-constant\"\n\t},\n\t\"icon-allow-overlap\": {\n\t\ttype: \"boolean\",\n\t\t\"default\": false,\n\t\trequires: [\n\t\t\t\"icon-image\",\n\t\t\t{\n\t\t\t\t\"!\": \"icon-overlap\"\n\t\t\t}\n\t\t],\n\t\texpression: {\n\t\t\tinterpolated: false,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-constant\"\n\t},\n\t\"icon-overlap\": {\n\t\ttype: \"enum\",\n\t\tvalues: {\n\t\t\tnever: {\n\t\t\t},\n\t\t\talways: {\n\t\t\t},\n\t\t\tcooperative: {\n\t\t\t}\n\t\t},\n\t\trequires: [\n\t\t\t\"icon-image\"\n\t\t],\n\t\texpression: {\n\t\t\tinterpolated: false,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-constant\"\n\t},\n\t\"icon-ignore-placement\": {\n\t\ttype: \"boolean\",\n\t\t\"default\": false,\n\t\trequires: [\n\t\t\t\"icon-image\"\n\t\t],\n\t\texpression: {\n\t\t\tinterpolated: false,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-constant\"\n\t},\n\t\"icon-optional\": {\n\t\ttype: \"boolean\",\n\t\t\"default\": false,\n\t\trequires: [\n\t\t\t\"icon-image\",\n\t\t\t\"text-field\"\n\t\t],\n\t\texpression: {\n\t\t\tinterpolated: false,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-constant\"\n\t},\n\t\"icon-rotation-alignment\": {\n\t\ttype: \"enum\",\n\t\tvalues: {\n\t\t\tmap: {\n\t\t\t},\n\t\t\tviewport: {\n\t\t\t},\n\t\t\tauto: {\n\t\t\t}\n\t\t},\n\t\t\"default\": \"auto\",\n\t\trequires: [\n\t\t\t\"icon-image\"\n\t\t],\n\t\texpression: {\n\t\t\tinterpolated: false,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-constant\"\n\t},\n\t\"icon-size\": {\n\t\ttype: \"number\",\n\t\t\"default\": 1,\n\t\tminimum: 0,\n\t\tunits: \"factor of the original icon size\",\n\t\trequires: [\n\t\t\t\"icon-image\"\n\t\t],\n\t\texpression: {\n\t\t\tinterpolated: true,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\",\n\t\t\t\t\"feature\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-driven\"\n\t},\n\t\"icon-text-fit\": {\n\t\ttype: \"enum\",\n\t\tvalues: {\n\t\t\tnone: {\n\t\t\t},\n\t\t\twidth: {\n\t\t\t},\n\t\t\theight: {\n\t\t\t},\n\t\t\tboth: {\n\t\t\t}\n\t\t},\n\t\t\"default\": \"none\",\n\t\trequires: [\n\t\t\t\"icon-image\",\n\t\t\t\"text-field\"\n\t\t],\n\t\texpression: {\n\t\t\tinterpolated: false,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-constant\"\n\t},\n\t\"icon-text-fit-padding\": {\n\t\ttype: \"array\",\n\t\tvalue: \"number\",\n\t\tlength: 4,\n\t\t\"default\": [\n\t\t\t0,\n\t\t\t0,\n\t\t\t0,\n\t\t\t0\n\t\t],\n\t\tunits: \"pixels\",\n\t\trequires: [\n\t\t\t\"icon-image\",\n\t\t\t\"text-field\",\n\t\t\t{\n\t\t\t\t\"icon-text-fit\": [\n\t\t\t\t\t\"both\",\n\t\t\t\t\t\"width\",\n\t\t\t\t\t\"height\"\n\t\t\t\t]\n\t\t\t}\n\t\t],\n\t\texpression: {\n\t\t\tinterpolated: true,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-constant\"\n\t},\n\t\"icon-image\": {\n\t\ttype: \"resolvedImage\",\n\t\ttokens: true,\n\t\texpression: {\n\t\t\tinterpolated: false,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\",\n\t\t\t\t\"feature\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-driven\"\n\t},\n\t\"icon-rotate\": {\n\t\ttype: \"number\",\n\t\t\"default\": 0,\n\t\tperiod: 360,\n\t\tunits: \"degrees\",\n\t\trequires: [\n\t\t\t\"icon-image\"\n\t\t],\n\t\texpression: {\n\t\t\tinterpolated: true,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\",\n\t\t\t\t\"feature\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-driven\"\n\t},\n\t\"icon-padding\": {\n\t\ttype: \"padding\",\n\t\t\"default\": [\n\t\t\t2\n\t\t],\n\t\tunits: \"pixels\",\n\t\trequires: [\n\t\t\t\"icon-image\"\n\t\t],\n\t\texpression: {\n\t\t\tinterpolated: true,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\",\n\t\t\t\t\"feature\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-driven\"\n\t},\n\t\"icon-keep-upright\": {\n\t\ttype: \"boolean\",\n\t\t\"default\": false,\n\t\trequires: [\n\t\t\t\"icon-image\",\n\t\t\t{\n\t\t\t\t\"icon-rotation-alignment\": \"map\"\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"symbol-placement\": [\n\t\t\t\t\t\"line\",\n\t\t\t\t\t\"line-center\"\n\t\t\t\t]\n\t\t\t}\n\t\t],\n\t\texpression: {\n\t\t\tinterpolated: false,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-constant\"\n\t},\n\t\"icon-offset\": {\n\t\ttype: \"array\",\n\t\tvalue: \"number\",\n\t\tlength: 2,\n\t\t\"default\": [\n\t\t\t0,\n\t\t\t0\n\t\t],\n\t\trequires: [\n\t\t\t\"icon-image\"\n\t\t],\n\t\texpression: {\n\t\t\tinterpolated: true,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\",\n\t\t\t\t\"feature\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-driven\"\n\t},\n\t\"icon-anchor\": {\n\t\ttype: \"enum\",\n\t\tvalues: {\n\t\t\tcenter: {\n\t\t\t},\n\t\t\tleft: {\n\t\t\t},\n\t\t\tright: {\n\t\t\t},\n\t\t\ttop: {\n\t\t\t},\n\t\t\tbottom: {\n\t\t\t},\n\t\t\t\"top-left\": {\n\t\t\t},\n\t\t\t\"top-right\": {\n\t\t\t},\n\t\t\t\"bottom-left\": {\n\t\t\t},\n\t\t\t\"bottom-right\": {\n\t\t\t}\n\t\t},\n\t\t\"default\": \"center\",\n\t\trequires: [\n\t\t\t\"icon-image\"\n\t\t],\n\t\texpression: {\n\t\t\tinterpolated: false,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\",\n\t\t\t\t\"feature\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-driven\"\n\t},\n\t\"icon-pitch-alignment\": {\n\t\ttype: \"enum\",\n\t\tvalues: {\n\t\t\tmap: {\n\t\t\t},\n\t\t\tviewport: {\n\t\t\t},\n\t\t\tauto: {\n\t\t\t}\n\t\t},\n\t\t\"default\": \"auto\",\n\t\trequires: [\n\t\t\t\"icon-image\"\n\t\t],\n\t\texpression: {\n\t\t\tinterpolated: false,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-constant\"\n\t},\n\t\"text-pitch-alignment\": {\n\t\ttype: \"enum\",\n\t\tvalues: {\n\t\t\tmap: {\n\t\t\t},\n\t\t\tviewport: {\n\t\t\t},\n\t\t\tauto: {\n\t\t\t}\n\t\t},\n\t\t\"default\": \"auto\",\n\t\trequires: [\n\t\t\t\"text-field\"\n\t\t],\n\t\texpression: {\n\t\t\tinterpolated: false,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-constant\"\n\t},\n\t\"text-rotation-alignment\": {\n\t\ttype: \"enum\",\n\t\tvalues: {\n\t\t\tmap: {\n\t\t\t},\n\t\t\tviewport: {\n\t\t\t},\n\t\t\t\"viewport-glyph\": {\n\t\t\t},\n\t\t\tauto: {\n\t\t\t}\n\t\t},\n\t\t\"default\": \"auto\",\n\t\trequires: [\n\t\t\t\"text-field\"\n\t\t],\n\t\texpression: {\n\t\t\tinterpolated: false,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-constant\"\n\t},\n\t\"text-field\": {\n\t\ttype: \"formatted\",\n\t\t\"default\": \"\",\n\t\ttokens: true,\n\t\texpression: {\n\t\t\tinterpolated: false,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\",\n\t\t\t\t\"feature\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-driven\"\n\t},\n\t\"text-font\": {\n\t\ttype: \"array\",\n\t\tvalue: \"string\",\n\t\t\"default\": [\n\t\t\t\"Open Sans Regular\",\n\t\t\t\"Arial Unicode MS Regular\"\n\t\t],\n\t\trequires: [\n\t\t\t\"text-field\"\n\t\t],\n\t\texpression: {\n\t\t\tinterpolated: false,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\",\n\t\t\t\t\"feature\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-driven\"\n\t},\n\t\"text-size\": {\n\t\ttype: \"number\",\n\t\t\"default\": 16,\n\t\tminimum: 0,\n\t\tunits: \"pixels\",\n\t\trequires: [\n\t\t\t\"text-field\"\n\t\t],\n\t\texpression: {\n\t\t\tinterpolated: true,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\",\n\t\t\t\t\"feature\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-driven\"\n\t},\n\t\"text-max-width\": {\n\t\ttype: \"number\",\n\t\t\"default\": 10,\n\t\tminimum: 0,\n\t\tunits: \"ems\",\n\t\trequires: [\n\t\t\t\"text-field\"\n\t\t],\n\t\texpression: {\n\t\t\tinterpolated: true,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\",\n\t\t\t\t\"feature\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-driven\"\n\t},\n\t\"text-line-height\": {\n\t\ttype: \"number\",\n\t\t\"default\": 1.2,\n\t\tunits: \"ems\",\n\t\trequires: [\n\t\t\t\"text-field\"\n\t\t],\n\t\texpression: {\n\t\t\tinterpolated: true,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-constant\"\n\t},\n\t\"text-letter-spacing\": {\n\t\ttype: \"number\",\n\t\t\"default\": 0,\n\t\tunits: \"ems\",\n\t\trequires: [\n\t\t\t\"text-field\"\n\t\t],\n\t\texpression: {\n\t\t\tinterpolated: true,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\",\n\t\t\t\t\"feature\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-driven\"\n\t},\n\t\"text-justify\": {\n\t\ttype: \"enum\",\n\t\tvalues: {\n\t\t\tauto: {\n\t\t\t},\n\t\t\tleft: {\n\t\t\t},\n\t\t\tcenter: {\n\t\t\t},\n\t\t\tright: {\n\t\t\t}\n\t\t},\n\t\t\"default\": \"center\",\n\t\trequires: [\n\t\t\t\"text-field\"\n\t\t],\n\t\texpression: {\n\t\t\tinterpolated: false,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\",\n\t\t\t\t\"feature\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-driven\"\n\t},\n\t\"text-radial-offset\": {\n\t\ttype: \"number\",\n\t\tunits: \"ems\",\n\t\t\"default\": 0,\n\t\trequires: [\n\t\t\t\"text-field\"\n\t\t],\n\t\t\"property-type\": \"data-driven\",\n\t\texpression: {\n\t\t\tinterpolated: true,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\",\n\t\t\t\t\"feature\"\n\t\t\t]\n\t\t}\n\t},\n\t\"text-variable-anchor\": {\n\t\ttype: \"array\",\n\t\tvalue: \"enum\",\n\t\tvalues: {\n\t\t\tcenter: {\n\t\t\t},\n\t\t\tleft: {\n\t\t\t},\n\t\t\tright: {\n\t\t\t},\n\t\t\ttop: {\n\t\t\t},\n\t\t\tbottom: {\n\t\t\t},\n\t\t\t\"top-left\": {\n\t\t\t},\n\t\t\t\"top-right\": {\n\t\t\t},\n\t\t\t\"bottom-left\": {\n\t\t\t},\n\t\t\t\"bottom-right\": {\n\t\t\t}\n\t\t},\n\t\trequires: [\n\t\t\t\"text-field\",\n\t\t\t{\n\t\t\t\t\"symbol-placement\": [\n\t\t\t\t\t\"point\"\n\t\t\t\t]\n\t\t\t}\n\t\t],\n\t\texpression: {\n\t\t\tinterpolated: false,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-constant\"\n\t},\n\t\"text-variable-anchor-offset\": {\n\t\ttype: \"variableAnchorOffsetCollection\",\n\t\trequires: [\n\t\t\t\"text-field\",\n\t\t\t{\n\t\t\t\t\"symbol-placement\": [\n\t\t\t\t\t\"point\"\n\t\t\t\t]\n\t\t\t}\n\t\t],\n\t\texpression: {\n\t\t\tinterpolated: true,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\",\n\t\t\t\t\"feature\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-driven\"\n\t},\n\t\"text-anchor\": {\n\t\ttype: \"enum\",\n\t\tvalues: {\n\t\t\tcenter: {\n\t\t\t},\n\t\t\tleft: {\n\t\t\t},\n\t\t\tright: {\n\t\t\t},\n\t\t\ttop: {\n\t\t\t},\n\t\t\tbottom: {\n\t\t\t},\n\t\t\t\"top-left\": {\n\t\t\t},\n\t\t\t\"top-right\": {\n\t\t\t},\n\t\t\t\"bottom-left\": {\n\t\t\t},\n\t\t\t\"bottom-right\": {\n\t\t\t}\n\t\t},\n\t\t\"default\": \"center\",\n\t\trequires: [\n\t\t\t\"text-field\",\n\t\t\t{\n\t\t\t\t\"!\": \"text-variable-anchor\"\n\t\t\t}\n\t\t],\n\t\texpression: {\n\t\t\tinterpolated: false,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\",\n\t\t\t\t\"feature\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-driven\"\n\t},\n\t\"text-max-angle\": {\n\t\ttype: \"number\",\n\t\t\"default\": 45,\n\t\tunits: \"degrees\",\n\t\trequires: [\n\t\t\t\"text-field\",\n\t\t\t{\n\t\t\t\t\"symbol-placement\": [\n\t\t\t\t\t\"line\",\n\t\t\t\t\t\"line-center\"\n\t\t\t\t]\n\t\t\t}\n\t\t],\n\t\texpression: {\n\t\t\tinterpolated: true,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-constant\"\n\t},\n\t\"text-writing-mode\": {\n\t\ttype: \"array\",\n\t\tvalue: \"enum\",\n\t\tvalues: {\n\t\t\thorizontal: {\n\t\t\t},\n\t\t\tvertical: {\n\t\t\t}\n\t\t},\n\t\trequires: [\n\t\t\t\"text-field\",\n\t\t\t{\n\t\t\t\t\"symbol-placement\": [\n\t\t\t\t\t\"point\"\n\t\t\t\t]\n\t\t\t}\n\t\t],\n\t\texpression: {\n\t\t\tinterpolated: false,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-constant\"\n\t},\n\t\"text-rotate\": {\n\t\ttype: \"number\",\n\t\t\"default\": 0,\n\t\tperiod: 360,\n\t\tunits: \"degrees\",\n\t\trequires: [\n\t\t\t\"text-field\"\n\t\t],\n\t\texpression: {\n\t\t\tinterpolated: true,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\",\n\t\t\t\t\"feature\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-driven\"\n\t},\n\t\"text-padding\": {\n\t\ttype: \"number\",\n\t\t\"default\": 2,\n\t\tminimum: 0,\n\t\tunits: \"pixels\",\n\t\trequires: [\n\t\t\t\"text-field\"\n\t\t],\n\t\texpression: {\n\t\t\tinterpolated: true,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-constant\"\n\t},\n\t\"text-keep-upright\": {\n\t\ttype: \"boolean\",\n\t\t\"default\": true,\n\t\trequires: [\n\t\t\t\"text-field\",\n\t\t\t{\n\t\t\t\t\"text-rotation-alignment\": \"map\"\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"symbol-placement\": [\n\t\t\t\t\t\"line\",\n\t\t\t\t\t\"line-center\"\n\t\t\t\t]\n\t\t\t}\n\t\t],\n\t\texpression: {\n\t\t\tinterpolated: false,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-constant\"\n\t},\n\t\"text-transform\": {\n\t\ttype: \"enum\",\n\t\tvalues: {\n\t\t\tnone: {\n\t\t\t},\n\t\t\tuppercase: {\n\t\t\t},\n\t\t\tlowercase: {\n\t\t\t}\n\t\t},\n\t\t\"default\": \"none\",\n\t\trequires: [\n\t\t\t\"text-field\"\n\t\t],\n\t\texpression: {\n\t\t\tinterpolated: false,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\",\n\t\t\t\t\"feature\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-driven\"\n\t},\n\t\"text-offset\": {\n\t\ttype: \"array\",\n\t\tvalue: \"number\",\n\t\tunits: \"ems\",\n\t\tlength: 2,\n\t\t\"default\": [\n\t\t\t0,\n\t\t\t0\n\t\t],\n\t\trequires: [\n\t\t\t\"text-field\",\n\t\t\t{\n\t\t\t\t\"!\": \"text-radial-offset\"\n\t\t\t}\n\t\t],\n\t\texpression: {\n\t\t\tinterpolated: true,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\",\n\t\t\t\t\"feature\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-driven\"\n\t},\n\t\"text-allow-overlap\": {\n\t\ttype: \"boolean\",\n\t\t\"default\": false,\n\t\trequires: [\n\t\t\t\"text-field\",\n\t\t\t{\n\t\t\t\t\"!\": \"text-overlap\"\n\t\t\t}\n\t\t],\n\t\texpression: {\n\t\t\tinterpolated: false,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-constant\"\n\t},\n\t\"text-overlap\": {\n\t\ttype: \"enum\",\n\t\tvalues: {\n\t\t\tnever: {\n\t\t\t},\n\t\t\talways: {\n\t\t\t},\n\t\t\tcooperative: {\n\t\t\t}\n\t\t},\n\t\trequires: [\n\t\t\t\"text-field\"\n\t\t],\n\t\texpression: {\n\t\t\tinterpolated: false,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-constant\"\n\t},\n\t\"text-ignore-placement\": {\n\t\ttype: \"boolean\",\n\t\t\"default\": false,\n\t\trequires: [\n\t\t\t\"text-field\"\n\t\t],\n\t\texpression: {\n\t\t\tinterpolated: false,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-constant\"\n\t},\n\t\"text-optional\": {\n\t\ttype: \"boolean\",\n\t\t\"default\": false,\n\t\trequires: [\n\t\t\t\"text-field\",\n\t\t\t\"icon-image\"\n\t\t],\n\t\texpression: {\n\t\t\tinterpolated: false,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-constant\"\n\t},\n\tvisibility: {\n\t\ttype: \"enum\",\n\t\tvalues: {\n\t\t\tvisible: {\n\t\t\t},\n\t\t\tnone: {\n\t\t\t}\n\t\t},\n\t\t\"default\": \"visible\",\n\t\t\"property-type\": \"constant\"\n\t}\n};\nvar layout_raster = {\n\tvisibility: {\n\t\ttype: \"enum\",\n\t\tvalues: {\n\t\t\tvisible: {\n\t\t\t},\n\t\t\tnone: {\n\t\t\t}\n\t\t},\n\t\t\"default\": \"visible\",\n\t\t\"property-type\": \"constant\"\n\t}\n};\nvar layout_hillshade = {\n\tvisibility: {\n\t\ttype: \"enum\",\n\t\tvalues: {\n\t\t\tvisible: {\n\t\t\t},\n\t\t\tnone: {\n\t\t\t}\n\t\t},\n\t\t\"default\": \"visible\",\n\t\t\"property-type\": \"constant\"\n\t}\n};\nvar filter = {\n\ttype: \"array\",\n\tvalue: \"*\"\n};\nvar filter_operator = {\n\ttype: \"enum\",\n\tvalues: {\n\t\t\"==\": {\n\t\t},\n\t\t\"!=\": {\n\t\t},\n\t\t\">\": {\n\t\t},\n\t\t\">=\": {\n\t\t},\n\t\t\"<\": {\n\t\t},\n\t\t\"<=\": {\n\t\t},\n\t\t\"in\": {\n\t\t},\n\t\t\"!in\": {\n\t\t},\n\t\tall: {\n\t\t},\n\t\tany: {\n\t\t},\n\t\tnone: {\n\t\t},\n\t\thas: {\n\t\t},\n\t\t\"!has\": {\n\t\t}\n\t}\n};\nvar geometry_type = {\n\ttype: \"enum\",\n\tvalues: {\n\t\tPoint: {\n\t\t},\n\t\tLineString: {\n\t\t},\n\t\tPolygon: {\n\t\t}\n\t}\n};\nvar function_stop = {\n\ttype: \"array\",\n\tminimum: 0,\n\tmaximum: 24,\n\tvalue: [\n\t\t\"number\",\n\t\t\"color\"\n\t],\n\tlength: 2\n};\nvar expression$1 = {\n\ttype: \"array\",\n\tvalue: \"*\",\n\tminimum: 1\n};\nvar light = {\n\tanchor: {\n\t\ttype: \"enum\",\n\t\t\"default\": \"viewport\",\n\t\tvalues: {\n\t\t\tmap: {\n\t\t\t},\n\t\t\tviewport: {\n\t\t\t}\n\t\t},\n\t\t\"property-type\": \"data-constant\",\n\t\ttransition: false,\n\t\texpression: {\n\t\t\tinterpolated: false,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\"\n\t\t\t]\n\t\t}\n\t},\n\tposition: {\n\t\ttype: \"array\",\n\t\t\"default\": [\n\t\t\t1.15,\n\t\t\t210,\n\t\t\t30\n\t\t],\n\t\tlength: 3,\n\t\tvalue: \"number\",\n\t\t\"property-type\": \"data-constant\",\n\t\ttransition: true,\n\t\texpression: {\n\t\t\tinterpolated: true,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\"\n\t\t\t]\n\t\t}\n\t},\n\tcolor: {\n\t\ttype: \"color\",\n\t\t\"property-type\": \"data-constant\",\n\t\t\"default\": \"#ffffff\",\n\t\texpression: {\n\t\t\tinterpolated: true,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\"\n\t\t\t]\n\t\t},\n\t\ttransition: true\n\t},\n\tintensity: {\n\t\ttype: \"number\",\n\t\t\"property-type\": \"data-constant\",\n\t\t\"default\": 0.5,\n\t\tminimum: 0,\n\t\tmaximum: 1,\n\t\texpression: {\n\t\t\tinterpolated: true,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\"\n\t\t\t]\n\t\t},\n\t\ttransition: true\n\t}\n};\nvar sky = {\n\t\"sky-color\": {\n\t\ttype: \"color\",\n\t\t\"property-type\": \"data-constant\",\n\t\t\"default\": \"#88C6FC\",\n\t\texpression: {\n\t\t\tinterpolated: true,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\"\n\t\t\t]\n\t\t},\n\t\ttransition: true\n\t},\n\t\"horizon-color\": {\n\t\ttype: \"color\",\n\t\t\"property-type\": \"data-constant\",\n\t\t\"default\": \"#ffffff\",\n\t\texpression: {\n\t\t\tinterpolated: true,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\"\n\t\t\t]\n\t\t},\n\t\ttransition: true\n\t},\n\t\"fog-color\": {\n\t\ttype: \"color\",\n\t\t\"property-type\": \"data-constant\",\n\t\t\"default\": \"#ffffff\",\n\t\texpression: {\n\t\t\tinterpolated: true,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\"\n\t\t\t]\n\t\t},\n\t\ttransition: true\n\t},\n\t\"fog-ground-blend\": {\n\t\ttype: \"number\",\n\t\t\"property-type\": \"data-constant\",\n\t\t\"default\": 0.5,\n\t\tminimum: 0,\n\t\tmaximum: 1,\n\t\texpression: {\n\t\t\tinterpolated: true,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\"\n\t\t\t]\n\t\t},\n\t\ttransition: true\n\t},\n\t\"horizon-fog-blend\": {\n\t\ttype: \"number\",\n\t\t\"property-type\": \"data-constant\",\n\t\t\"default\": 0.8,\n\t\tminimum: 0,\n\t\tmaximum: 1,\n\t\texpression: {\n\t\t\tinterpolated: true,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\"\n\t\t\t]\n\t\t},\n\t\ttransition: true\n\t},\n\t\"sky-horizon-blend\": {\n\t\ttype: \"number\",\n\t\t\"property-type\": \"data-constant\",\n\t\t\"default\": 0.8,\n\t\tminimum: 0,\n\t\tmaximum: 1,\n\t\texpression: {\n\t\t\tinterpolated: true,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\"\n\t\t\t]\n\t\t},\n\t\ttransition: true\n\t},\n\t\"atmosphere-blend\": {\n\t\ttype: \"number\",\n\t\t\"property-type\": \"data-constant\",\n\t\t\"default\": 0.8,\n\t\tminimum: 0,\n\t\tmaximum: 1,\n\t\texpression: {\n\t\t\tinterpolated: true,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\"\n\t\t\t]\n\t\t},\n\t\ttransition: true\n\t}\n};\nvar terrain = {\n\tsource: {\n\t\ttype: \"string\",\n\t\trequired: true\n\t},\n\texaggeration: {\n\t\ttype: \"number\",\n\t\tminimum: 0,\n\t\t\"default\": 1\n\t}\n};\nvar projection = {\n\ttype: {\n\t\ttype: \"projectionDefinition\",\n\t\t\"default\": \"mercator\",\n\t\t\"property-type\": \"data-constant\",\n\t\ttransition: false,\n\t\texpression: {\n\t\t\tinterpolated: true,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\"\n\t\t\t]\n\t\t}\n\t}\n};\nvar paint = [\n\t\"paint_fill\",\n\t\"paint_line\",\n\t\"paint_circle\",\n\t\"paint_heatmap\",\n\t\"paint_fill-extrusion\",\n\t\"paint_symbol\",\n\t\"paint_raster\",\n\t\"paint_hillshade\",\n\t\"paint_background\"\n];\nvar paint_fill = {\n\t\"fill-antialias\": {\n\t\ttype: \"boolean\",\n\t\t\"default\": true,\n\t\texpression: {\n\t\t\tinterpolated: false,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-constant\"\n\t},\n\t\"fill-opacity\": {\n\t\ttype: \"number\",\n\t\t\"default\": 1,\n\t\tminimum: 0,\n\t\tmaximum: 1,\n\t\ttransition: true,\n\t\texpression: {\n\t\t\tinterpolated: true,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\",\n\t\t\t\t\"feature\",\n\t\t\t\t\"feature-state\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-driven\"\n\t},\n\t\"fill-color\": {\n\t\ttype: \"color\",\n\t\t\"default\": \"#000000\",\n\t\ttransition: true,\n\t\trequires: [\n\t\t\t{\n\t\t\t\t\"!\": \"fill-pattern\"\n\t\t\t}\n\t\t],\n\t\texpression: {\n\t\t\tinterpolated: true,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\",\n\t\t\t\t\"feature\",\n\t\t\t\t\"feature-state\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-driven\"\n\t},\n\t\"fill-outline-color\": {\n\t\ttype: \"color\",\n\t\ttransition: true,\n\t\trequires: [\n\t\t\t{\n\t\t\t\t\"!\": \"fill-pattern\"\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"fill-antialias\": true\n\t\t\t}\n\t\t],\n\t\texpression: {\n\t\t\tinterpolated: true,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\",\n\t\t\t\t\"feature\",\n\t\t\t\t\"feature-state\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-driven\"\n\t},\n\t\"fill-translate\": {\n\t\ttype: \"array\",\n\t\tvalue: \"number\",\n\t\tlength: 2,\n\t\t\"default\": [\n\t\t\t0,\n\t\t\t0\n\t\t],\n\t\ttransition: true,\n\t\tunits: \"pixels\",\n\t\texpression: {\n\t\t\tinterpolated: true,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-constant\"\n\t},\n\t\"fill-translate-anchor\": {\n\t\ttype: \"enum\",\n\t\tvalues: {\n\t\t\tmap: {\n\t\t\t},\n\t\t\tviewport: {\n\t\t\t}\n\t\t},\n\t\t\"default\": \"map\",\n\t\trequires: [\n\t\t\t\"fill-translate\"\n\t\t],\n\t\texpression: {\n\t\t\tinterpolated: false,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-constant\"\n\t},\n\t\"fill-pattern\": {\n\t\ttype: \"resolvedImage\",\n\t\ttransition: true,\n\t\texpression: {\n\t\t\tinterpolated: false,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\",\n\t\t\t\t\"feature\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"cross-faded-data-driven\"\n\t}\n};\nvar paint_line = {\n\t\"line-opacity\": {\n\t\ttype: \"number\",\n\t\t\"default\": 1,\n\t\tminimum: 0,\n\t\tmaximum: 1,\n\t\ttransition: true,\n\t\texpression: {\n\t\t\tinterpolated: true,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\",\n\t\t\t\t\"feature\",\n\t\t\t\t\"feature-state\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-driven\"\n\t},\n\t\"line-color\": {\n\t\ttype: \"color\",\n\t\t\"default\": \"#000000\",\n\t\ttransition: true,\n\t\trequires: [\n\t\t\t{\n\t\t\t\t\"!\": \"line-pattern\"\n\t\t\t}\n\t\t],\n\t\texpression: {\n\t\t\tinterpolated: true,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\",\n\t\t\t\t\"feature\",\n\t\t\t\t\"feature-state\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-driven\"\n\t},\n\t\"line-translate\": {\n\t\ttype: \"array\",\n\t\tvalue: \"number\",\n\t\tlength: 2,\n\t\t\"default\": [\n\t\t\t0,\n\t\t\t0\n\t\t],\n\t\ttransition: true,\n\t\tunits: \"pixels\",\n\t\texpression: {\n\t\t\tinterpolated: true,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-constant\"\n\t},\n\t\"line-translate-anchor\": {\n\t\ttype: \"enum\",\n\t\tvalues: {\n\t\t\tmap: {\n\t\t\t},\n\t\t\tviewport: {\n\t\t\t}\n\t\t},\n\t\t\"default\": \"map\",\n\t\trequires: [\n\t\t\t\"line-translate\"\n\t\t],\n\t\texpression: {\n\t\t\tinterpolated: false,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-constant\"\n\t},\n\t\"line-width\": {\n\t\ttype: \"number\",\n\t\t\"default\": 1,\n\t\tminimum: 0,\n\t\ttransition: true,\n\t\tunits: \"pixels\",\n\t\texpression: {\n\t\t\tinterpolated: true,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\",\n\t\t\t\t\"feature\",\n\t\t\t\t\"feature-state\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-driven\"\n\t},\n\t\"line-gap-width\": {\n\t\ttype: \"number\",\n\t\t\"default\": 0,\n\t\tminimum: 0,\n\t\ttransition: true,\n\t\tunits: \"pixels\",\n\t\texpression: {\n\t\t\tinterpolated: true,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\",\n\t\t\t\t\"feature\",\n\t\t\t\t\"feature-state\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-driven\"\n\t},\n\t\"line-offset\": {\n\t\ttype: \"number\",\n\t\t\"default\": 0,\n\t\ttransition: true,\n\t\tunits: \"pixels\",\n\t\texpression: {\n\t\t\tinterpolated: true,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\",\n\t\t\t\t\"feature\",\n\t\t\t\t\"feature-state\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-driven\"\n\t},\n\t\"line-blur\": {\n\t\ttype: \"number\",\n\t\t\"default\": 0,\n\t\tminimum: 0,\n\t\ttransition: true,\n\t\tunits: \"pixels\",\n\t\texpression: {\n\t\t\tinterpolated: true,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\",\n\t\t\t\t\"feature\",\n\t\t\t\t\"feature-state\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-driven\"\n\t},\n\t\"line-dasharray\": {\n\t\ttype: \"array\",\n\t\tvalue: \"number\",\n\t\tminimum: 0,\n\t\ttransition: true,\n\t\tunits: \"line widths\",\n\t\trequires: [\n\t\t\t{\n\t\t\t\t\"!\": \"line-pattern\"\n\t\t\t}\n\t\t],\n\t\texpression: {\n\t\t\tinterpolated: false,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"cross-faded\"\n\t},\n\t\"line-pattern\": {\n\t\ttype: \"resolvedImage\",\n\t\ttransition: true,\n\t\texpression: {\n\t\t\tinterpolated: false,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\",\n\t\t\t\t\"feature\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"cross-faded-data-driven\"\n\t},\n\t\"line-gradient\": {\n\t\ttype: \"color\",\n\t\ttransition: false,\n\t\trequires: [\n\t\t\t{\n\t\t\t\t\"!\": \"line-dasharray\"\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"!\": \"line-pattern\"\n\t\t\t},\n\t\t\t{\n\t\t\t\tsource: \"geojson\",\n\t\t\t\thas: {\n\t\t\t\t\tlineMetrics: true\n\t\t\t\t}\n\t\t\t}\n\t\t],\n\t\texpression: {\n\t\t\tinterpolated: true,\n\t\t\tparameters: [\n\t\t\t\t\"line-progress\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"color-ramp\"\n\t}\n};\nvar paint_circle = {\n\t\"circle-radius\": {\n\t\ttype: \"number\",\n\t\t\"default\": 5,\n\t\tminimum: 0,\n\t\ttransition: true,\n\t\tunits: \"pixels\",\n\t\texpression: {\n\t\t\tinterpolated: true,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\",\n\t\t\t\t\"feature\",\n\t\t\t\t\"feature-state\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-driven\"\n\t},\n\t\"circle-color\": {\n\t\ttype: \"color\",\n\t\t\"default\": \"#000000\",\n\t\ttransition: true,\n\t\texpression: {\n\t\t\tinterpolated: true,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\",\n\t\t\t\t\"feature\",\n\t\t\t\t\"feature-state\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-driven\"\n\t},\n\t\"circle-blur\": {\n\t\ttype: \"number\",\n\t\t\"default\": 0,\n\t\ttransition: true,\n\t\texpression: {\n\t\t\tinterpolated: true,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\",\n\t\t\t\t\"feature\",\n\t\t\t\t\"feature-state\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-driven\"\n\t},\n\t\"circle-opacity\": {\n\t\ttype: \"number\",\n\t\t\"default\": 1,\n\t\tminimum: 0,\n\t\tmaximum: 1,\n\t\ttransition: true,\n\t\texpression: {\n\t\t\tinterpolated: true,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\",\n\t\t\t\t\"feature\",\n\t\t\t\t\"feature-state\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-driven\"\n\t},\n\t\"circle-translate\": {\n\t\ttype: \"array\",\n\t\tvalue: \"number\",\n\t\tlength: 2,\n\t\t\"default\": [\n\t\t\t0,\n\t\t\t0\n\t\t],\n\t\ttransition: true,\n\t\tunits: \"pixels\",\n\t\texpression: {\n\t\t\tinterpolated: true,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-constant\"\n\t},\n\t\"circle-translate-anchor\": {\n\t\ttype: \"enum\",\n\t\tvalues: {\n\t\t\tmap: {\n\t\t\t},\n\t\t\tviewport: {\n\t\t\t}\n\t\t},\n\t\t\"default\": \"map\",\n\t\trequires: [\n\t\t\t\"circle-translate\"\n\t\t],\n\t\texpression: {\n\t\t\tinterpolated: false,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-constant\"\n\t},\n\t\"circle-pitch-scale\": {\n\t\ttype: \"enum\",\n\t\tvalues: {\n\t\t\tmap: {\n\t\t\t},\n\t\t\tviewport: {\n\t\t\t}\n\t\t},\n\t\t\"default\": \"map\",\n\t\texpression: {\n\t\t\tinterpolated: false,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-constant\"\n\t},\n\t\"circle-pitch-alignment\": {\n\t\ttype: \"enum\",\n\t\tvalues: {\n\t\t\tmap: {\n\t\t\t},\n\t\t\tviewport: {\n\t\t\t}\n\t\t},\n\t\t\"default\": \"viewport\",\n\t\texpression: {\n\t\t\tinterpolated: false,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-constant\"\n\t},\n\t\"circle-stroke-width\": {\n\t\ttype: \"number\",\n\t\t\"default\": 0,\n\t\tminimum: 0,\n\t\ttransition: true,\n\t\tunits: \"pixels\",\n\t\texpression: {\n\t\t\tinterpolated: true,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\",\n\t\t\t\t\"feature\",\n\t\t\t\t\"feature-state\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-driven\"\n\t},\n\t\"circle-stroke-color\": {\n\t\ttype: \"color\",\n\t\t\"default\": \"#000000\",\n\t\ttransition: true,\n\t\texpression: {\n\t\t\tinterpolated: true,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\",\n\t\t\t\t\"feature\",\n\t\t\t\t\"feature-state\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-driven\"\n\t},\n\t\"circle-stroke-opacity\": {\n\t\ttype: \"number\",\n\t\t\"default\": 1,\n\t\tminimum: 0,\n\t\tmaximum: 1,\n\t\ttransition: true,\n\t\texpression: {\n\t\t\tinterpolated: true,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\",\n\t\t\t\t\"feature\",\n\t\t\t\t\"feature-state\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-driven\"\n\t}\n};\nvar paint_heatmap = {\n\t\"heatmap-radius\": {\n\t\ttype: \"number\",\n\t\t\"default\": 30,\n\t\tminimum: 1,\n\t\ttransition: true,\n\t\tunits: \"pixels\",\n\t\texpression: {\n\t\t\tinterpolated: true,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\",\n\t\t\t\t\"feature\",\n\t\t\t\t\"feature-state\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-driven\"\n\t},\n\t\"heatmap-weight\": {\n\t\ttype: \"number\",\n\t\t\"default\": 1,\n\t\tminimum: 0,\n\t\ttransition: false,\n\t\texpression: {\n\t\t\tinterpolated: true,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\",\n\t\t\t\t\"feature\",\n\t\t\t\t\"feature-state\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-driven\"\n\t},\n\t\"heatmap-intensity\": {\n\t\ttype: \"number\",\n\t\t\"default\": 1,\n\t\tminimum: 0,\n\t\ttransition: true,\n\t\texpression: {\n\t\t\tinterpolated: true,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-constant\"\n\t},\n\t\"heatmap-color\": {\n\t\ttype: \"color\",\n\t\t\"default\": [\n\t\t\t\"interpolate\",\n\t\t\t[\n\t\t\t\t\"linear\"\n\t\t\t],\n\t\t\t[\n\t\t\t\t\"heatmap-density\"\n\t\t\t],\n\t\t\t0,\n\t\t\t\"rgba(0, 0, 255, 0)\",\n\t\t\t0.1,\n\t\t\t\"royalblue\",\n\t\t\t0.3,\n\t\t\t\"cyan\",\n\t\t\t0.5,\n\t\t\t\"lime\",\n\t\t\t0.7,\n\t\t\t\"yellow\",\n\t\t\t1,\n\t\t\t\"red\"\n\t\t],\n\t\ttransition: false,\n\t\texpression: {\n\t\t\tinterpolated: true,\n\t\t\tparameters: [\n\t\t\t\t\"heatmap-density\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"color-ramp\"\n\t},\n\t\"heatmap-opacity\": {\n\t\ttype: \"number\",\n\t\t\"default\": 1,\n\t\tminimum: 0,\n\t\tmaximum: 1,\n\t\ttransition: true,\n\t\texpression: {\n\t\t\tinterpolated: true,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-constant\"\n\t}\n};\nvar paint_symbol = {\n\t\"icon-opacity\": {\n\t\ttype: \"number\",\n\t\t\"default\": 1,\n\t\tminimum: 0,\n\t\tmaximum: 1,\n\t\ttransition: true,\n\t\trequires: [\n\t\t\t\"icon-image\"\n\t\t],\n\t\texpression: {\n\t\t\tinterpolated: true,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\",\n\t\t\t\t\"feature\",\n\t\t\t\t\"feature-state\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-driven\"\n\t},\n\t\"icon-color\": {\n\t\ttype: \"color\",\n\t\t\"default\": \"#000000\",\n\t\ttransition: true,\n\t\trequires: [\n\t\t\t\"icon-image\"\n\t\t],\n\t\texpression: {\n\t\t\tinterpolated: true,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\",\n\t\t\t\t\"feature\",\n\t\t\t\t\"feature-state\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-driven\"\n\t},\n\t\"icon-halo-color\": {\n\t\ttype: \"color\",\n\t\t\"default\": \"rgba(0, 0, 0, 0)\",\n\t\ttransition: true,\n\t\trequires: [\n\t\t\t\"icon-image\"\n\t\t],\n\t\texpression: {\n\t\t\tinterpolated: true,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\",\n\t\t\t\t\"feature\",\n\t\t\t\t\"feature-state\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-driven\"\n\t},\n\t\"icon-halo-width\": {\n\t\ttype: \"number\",\n\t\t\"default\": 0,\n\t\tminimum: 0,\n\t\ttransition: true,\n\t\tunits: \"pixels\",\n\t\trequires: [\n\t\t\t\"icon-image\"\n\t\t],\n\t\texpression: {\n\t\t\tinterpolated: true,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\",\n\t\t\t\t\"feature\",\n\t\t\t\t\"feature-state\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-driven\"\n\t},\n\t\"icon-halo-blur\": {\n\t\ttype: \"number\",\n\t\t\"default\": 0,\n\t\tminimum: 0,\n\t\ttransition: true,\n\t\tunits: \"pixels\",\n\t\trequires: [\n\t\t\t\"icon-image\"\n\t\t],\n\t\texpression: {\n\t\t\tinterpolated: true,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\",\n\t\t\t\t\"feature\",\n\t\t\t\t\"feature-state\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-driven\"\n\t},\n\t\"icon-translate\": {\n\t\ttype: \"array\",\n\t\tvalue: \"number\",\n\t\tlength: 2,\n\t\t\"default\": [\n\t\t\t0,\n\t\t\t0\n\t\t],\n\t\ttransition: true,\n\t\tunits: \"pixels\",\n\t\trequires: [\n\t\t\t\"icon-image\"\n\t\t],\n\t\texpression: {\n\t\t\tinterpolated: true,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-constant\"\n\t},\n\t\"icon-translate-anchor\": {\n\t\ttype: \"enum\",\n\t\tvalues: {\n\t\t\tmap: {\n\t\t\t},\n\t\t\tviewport: {\n\t\t\t}\n\t\t},\n\t\t\"default\": \"map\",\n\t\trequires: [\n\t\t\t\"icon-image\",\n\t\t\t\"icon-translate\"\n\t\t],\n\t\texpression: {\n\t\t\tinterpolated: false,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-constant\"\n\t},\n\t\"text-opacity\": {\n\t\ttype: \"number\",\n\t\t\"default\": 1,\n\t\tminimum: 0,\n\t\tmaximum: 1,\n\t\ttransition: true,\n\t\trequires: [\n\t\t\t\"text-field\"\n\t\t],\n\t\texpression: {\n\t\t\tinterpolated: true,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\",\n\t\t\t\t\"feature\",\n\t\t\t\t\"feature-state\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-driven\"\n\t},\n\t\"text-color\": {\n\t\ttype: \"color\",\n\t\t\"default\": \"#000000\",\n\t\ttransition: true,\n\t\toverridable: true,\n\t\trequires: [\n\t\t\t\"text-field\"\n\t\t],\n\t\texpression: {\n\t\t\tinterpolated: true,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\",\n\t\t\t\t\"feature\",\n\t\t\t\t\"feature-state\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-driven\"\n\t},\n\t\"text-halo-color\": {\n\t\ttype: \"color\",\n\t\t\"default\": \"rgba(0, 0, 0, 0)\",\n\t\ttransition: true,\n\t\trequires: [\n\t\t\t\"text-field\"\n\t\t],\n\t\texpression: {\n\t\t\tinterpolated: true,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\",\n\t\t\t\t\"feature\",\n\t\t\t\t\"feature-state\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-driven\"\n\t},\n\t\"text-halo-width\": {\n\t\ttype: \"number\",\n\t\t\"default\": 0,\n\t\tminimum: 0,\n\t\ttransition: true,\n\t\tunits: \"pixels\",\n\t\trequires: [\n\t\t\t\"text-field\"\n\t\t],\n\t\texpression: {\n\t\t\tinterpolated: true,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\",\n\t\t\t\t\"feature\",\n\t\t\t\t\"feature-state\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-driven\"\n\t},\n\t\"text-halo-blur\": {\n\t\ttype: \"number\",\n\t\t\"default\": 0,\n\t\tminimum: 0,\n\t\ttransition: true,\n\t\tunits: \"pixels\",\n\t\trequires: [\n\t\t\t\"text-field\"\n\t\t],\n\t\texpression: {\n\t\t\tinterpolated: true,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\",\n\t\t\t\t\"feature\",\n\t\t\t\t\"feature-state\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-driven\"\n\t},\n\t\"text-translate\": {\n\t\ttype: \"array\",\n\t\tvalue: \"number\",\n\t\tlength: 2,\n\t\t\"default\": [\n\t\t\t0,\n\t\t\t0\n\t\t],\n\t\ttransition: true,\n\t\tunits: \"pixels\",\n\t\trequires: [\n\t\t\t\"text-field\"\n\t\t],\n\t\texpression: {\n\t\t\tinterpolated: true,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-constant\"\n\t},\n\t\"text-translate-anchor\": {\n\t\ttype: \"enum\",\n\t\tvalues: {\n\t\t\tmap: {\n\t\t\t},\n\t\t\tviewport: {\n\t\t\t}\n\t\t},\n\t\t\"default\": \"map\",\n\t\trequires: [\n\t\t\t\"text-field\",\n\t\t\t\"text-translate\"\n\t\t],\n\t\texpression: {\n\t\t\tinterpolated: false,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-constant\"\n\t}\n};\nvar paint_raster = {\n\t\"raster-opacity\": {\n\t\ttype: \"number\",\n\t\t\"default\": 1,\n\t\tminimum: 0,\n\t\tmaximum: 1,\n\t\ttransition: true,\n\t\texpression: {\n\t\t\tinterpolated: true,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-constant\"\n\t},\n\t\"raster-hue-rotate\": {\n\t\ttype: \"number\",\n\t\t\"default\": 0,\n\t\tperiod: 360,\n\t\ttransition: true,\n\t\tunits: \"degrees\",\n\t\texpression: {\n\t\t\tinterpolated: true,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-constant\"\n\t},\n\t\"raster-brightness-min\": {\n\t\ttype: \"number\",\n\t\t\"default\": 0,\n\t\tminimum: 0,\n\t\tmaximum: 1,\n\t\ttransition: true,\n\t\texpression: {\n\t\t\tinterpolated: true,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-constant\"\n\t},\n\t\"raster-brightness-max\": {\n\t\ttype: \"number\",\n\t\t\"default\": 1,\n\t\tminimum: 0,\n\t\tmaximum: 1,\n\t\ttransition: true,\n\t\texpression: {\n\t\t\tinterpolated: true,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-constant\"\n\t},\n\t\"raster-saturation\": {\n\t\ttype: \"number\",\n\t\t\"default\": 0,\n\t\tminimum: -1,\n\t\tmaximum: 1,\n\t\ttransition: true,\n\t\texpression: {\n\t\t\tinterpolated: true,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-constant\"\n\t},\n\t\"raster-contrast\": {\n\t\ttype: \"number\",\n\t\t\"default\": 0,\n\t\tminimum: -1,\n\t\tmaximum: 1,\n\t\ttransition: true,\n\t\texpression: {\n\t\t\tinterpolated: true,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-constant\"\n\t},\n\t\"raster-resampling\": {\n\t\ttype: \"enum\",\n\t\tvalues: {\n\t\t\tlinear: {\n\t\t\t},\n\t\t\tnearest: {\n\t\t\t}\n\t\t},\n\t\t\"default\": \"linear\",\n\t\texpression: {\n\t\t\tinterpolated: false,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-constant\"\n\t},\n\t\"raster-fade-duration\": {\n\t\ttype: \"number\",\n\t\t\"default\": 300,\n\t\tminimum: 0,\n\t\ttransition: false,\n\t\tunits: \"milliseconds\",\n\t\texpression: {\n\t\t\tinterpolated: true,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-constant\"\n\t}\n};\nvar paint_hillshade = {\n\t\"hillshade-illumination-direction\": {\n\t\ttype: \"number\",\n\t\t\"default\": 335,\n\t\tminimum: 0,\n\t\tmaximum: 359,\n\t\ttransition: false,\n\t\texpression: {\n\t\t\tinterpolated: true,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-constant\"\n\t},\n\t\"hillshade-illumination-anchor\": {\n\t\ttype: \"enum\",\n\t\tvalues: {\n\t\t\tmap: {\n\t\t\t},\n\t\t\tviewport: {\n\t\t\t}\n\t\t},\n\t\t\"default\": \"viewport\",\n\t\texpression: {\n\t\t\tinterpolated: false,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-constant\"\n\t},\n\t\"hillshade-exaggeration\": {\n\t\ttype: \"number\",\n\t\t\"default\": 0.5,\n\t\tminimum: 0,\n\t\tmaximum: 1,\n\t\ttransition: true,\n\t\texpression: {\n\t\t\tinterpolated: true,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-constant\"\n\t},\n\t\"hillshade-shadow-color\": {\n\t\ttype: \"color\",\n\t\t\"default\": \"#000000\",\n\t\ttransition: true,\n\t\texpression: {\n\t\t\tinterpolated: true,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-constant\"\n\t},\n\t\"hillshade-highlight-color\": {\n\t\ttype: \"color\",\n\t\t\"default\": \"#FFFFFF\",\n\t\ttransition: true,\n\t\texpression: {\n\t\t\tinterpolated: true,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-constant\"\n\t},\n\t\"hillshade-accent-color\": {\n\t\ttype: \"color\",\n\t\t\"default\": \"#000000\",\n\t\ttransition: true,\n\t\texpression: {\n\t\t\tinterpolated: true,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-constant\"\n\t}\n};\nvar paint_background = {\n\t\"background-color\": {\n\t\ttype: \"color\",\n\t\t\"default\": \"#000000\",\n\t\ttransition: true,\n\t\trequires: [\n\t\t\t{\n\t\t\t\t\"!\": \"background-pattern\"\n\t\t\t}\n\t\t],\n\t\texpression: {\n\t\t\tinterpolated: true,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-constant\"\n\t},\n\t\"background-pattern\": {\n\t\ttype: \"resolvedImage\",\n\t\ttransition: true,\n\t\texpression: {\n\t\t\tinterpolated: false,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"cross-faded\"\n\t},\n\t\"background-opacity\": {\n\t\ttype: \"number\",\n\t\t\"default\": 1,\n\t\tminimum: 0,\n\t\tmaximum: 1,\n\t\ttransition: true,\n\t\texpression: {\n\t\t\tinterpolated: true,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-constant\"\n\t}\n};\nvar transition = {\n\tduration: {\n\t\ttype: \"number\",\n\t\t\"default\": 300,\n\t\tminimum: 0,\n\t\tunits: \"milliseconds\"\n\t},\n\tdelay: {\n\t\ttype: \"number\",\n\t\t\"default\": 0,\n\t\tminimum: 0,\n\t\tunits: \"milliseconds\"\n\t}\n};\nvar promoteId = {\n\t\"*\": {\n\t\ttype: \"string\"\n\t}\n};\nvar v8Spec = {\n\t$version: $version,\n\t$root: $root,\n\tsources: sources,\n\tsource: source,\n\tsource_vector: source_vector,\n\tsource_raster: source_raster,\n\tsource_raster_dem: source_raster_dem,\n\tsource_geojson: source_geojson,\n\tsource_video: source_video,\n\tsource_image: source_image,\n\tlayer: layer,\n\tlayout: layout,\n\tlayout_background: layout_background,\n\tlayout_fill: layout_fill,\n\tlayout_circle: layout_circle,\n\tlayout_heatmap: layout_heatmap,\n\t\"layout_fill-extrusion\": {\n\tvisibility: {\n\t\ttype: \"enum\",\n\t\tvalues: {\n\t\t\tvisible: {\n\t\t\t},\n\t\t\tnone: {\n\t\t\t}\n\t\t},\n\t\t\"default\": \"visible\",\n\t\t\"property-type\": \"constant\"\n\t}\n},\n\tlayout_line: layout_line,\n\tlayout_symbol: layout_symbol,\n\tlayout_raster: layout_raster,\n\tlayout_hillshade: layout_hillshade,\n\tfilter: filter,\n\tfilter_operator: filter_operator,\n\tgeometry_type: geometry_type,\n\t\"function\": {\n\texpression: {\n\t\ttype: \"expression\"\n\t},\n\tstops: {\n\t\ttype: \"array\",\n\t\tvalue: \"function_stop\"\n\t},\n\tbase: {\n\t\ttype: \"number\",\n\t\t\"default\": 1,\n\t\tminimum: 0\n\t},\n\tproperty: {\n\t\ttype: \"string\",\n\t\t\"default\": \"$zoom\"\n\t},\n\ttype: {\n\t\ttype: \"enum\",\n\t\tvalues: {\n\t\t\tidentity: {\n\t\t\t},\n\t\t\texponential: {\n\t\t\t},\n\t\t\tinterval: {\n\t\t\t},\n\t\t\tcategorical: {\n\t\t\t}\n\t\t},\n\t\t\"default\": \"exponential\"\n\t},\n\tcolorSpace: {\n\t\ttype: \"enum\",\n\t\tvalues: {\n\t\t\trgb: {\n\t\t\t},\n\t\t\tlab: {\n\t\t\t},\n\t\t\thcl: {\n\t\t\t}\n\t\t},\n\t\t\"default\": \"rgb\"\n\t},\n\t\"default\": {\n\t\ttype: \"*\",\n\t\trequired: false\n\t}\n},\n\tfunction_stop: function_stop,\n\texpression: expression$1,\n\tlight: light,\n\tsky: sky,\n\tterrain: terrain,\n\tprojection: projection,\n\tpaint: paint,\n\tpaint_fill: paint_fill,\n\t\"paint_fill-extrusion\": {\n\t\"fill-extrusion-opacity\": {\n\t\ttype: \"number\",\n\t\t\"default\": 1,\n\t\tminimum: 0,\n\t\tmaximum: 1,\n\t\ttransition: true,\n\t\texpression: {\n\t\t\tinterpolated: true,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-constant\"\n\t},\n\t\"fill-extrusion-color\": {\n\t\ttype: \"color\",\n\t\t\"default\": \"#000000\",\n\t\ttransition: true,\n\t\trequires: [\n\t\t\t{\n\t\t\t\t\"!\": \"fill-extrusion-pattern\"\n\t\t\t}\n\t\t],\n\t\texpression: {\n\t\t\tinterpolated: true,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\",\n\t\t\t\t\"feature\",\n\t\t\t\t\"feature-state\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-driven\"\n\t},\n\t\"fill-extrusion-translate\": {\n\t\ttype: \"array\",\n\t\tvalue: \"number\",\n\t\tlength: 2,\n\t\t\"default\": [\n\t\t\t0,\n\t\t\t0\n\t\t],\n\t\ttransition: true,\n\t\tunits: \"pixels\",\n\t\texpression: {\n\t\t\tinterpolated: true,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-constant\"\n\t},\n\t\"fill-extrusion-translate-anchor\": {\n\t\ttype: \"enum\",\n\t\tvalues: {\n\t\t\tmap: {\n\t\t\t},\n\t\t\tviewport: {\n\t\t\t}\n\t\t},\n\t\t\"default\": \"map\",\n\t\trequires: [\n\t\t\t\"fill-extrusion-translate\"\n\t\t],\n\t\texpression: {\n\t\t\tinterpolated: false,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-constant\"\n\t},\n\t\"fill-extrusion-pattern\": {\n\t\ttype: \"resolvedImage\",\n\t\ttransition: true,\n\t\texpression: {\n\t\t\tinterpolated: false,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\",\n\t\t\t\t\"feature\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"cross-faded-data-driven\"\n\t},\n\t\"fill-extrusion-height\": {\n\t\ttype: \"number\",\n\t\t\"default\": 0,\n\t\tminimum: 0,\n\t\tunits: \"meters\",\n\t\ttransition: true,\n\t\texpression: {\n\t\t\tinterpolated: true,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\",\n\t\t\t\t\"feature\",\n\t\t\t\t\"feature-state\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-driven\"\n\t},\n\t\"fill-extrusion-base\": {\n\t\ttype: \"number\",\n\t\t\"default\": 0,\n\t\tminimum: 0,\n\t\tunits: \"meters\",\n\t\ttransition: true,\n\t\trequires: [\n\t\t\t\"fill-extrusion-height\"\n\t\t],\n\t\texpression: {\n\t\t\tinterpolated: true,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\",\n\t\t\t\t\"feature\",\n\t\t\t\t\"feature-state\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-driven\"\n\t},\n\t\"fill-extrusion-vertical-gradient\": {\n\t\ttype: \"boolean\",\n\t\t\"default\": true,\n\t\ttransition: false,\n\t\texpression: {\n\t\t\tinterpolated: false,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-constant\"\n\t}\n},\n\tpaint_line: paint_line,\n\tpaint_circle: paint_circle,\n\tpaint_heatmap: paint_heatmap,\n\tpaint_symbol: paint_symbol,\n\tpaint_raster: paint_raster,\n\tpaint_hillshade: paint_hillshade,\n\tpaint_background: paint_background,\n\ttransition: transition,\n\t\"property-type\": {\n\t\"data-driven\": {\n\t\ttype: \"property-type\"\n\t},\n\t\"cross-faded\": {\n\t\ttype: \"property-type\"\n\t},\n\t\"cross-faded-data-driven\": {\n\t\ttype: \"property-type\"\n\t},\n\t\"color-ramp\": {\n\t\ttype: \"property-type\"\n\t},\n\t\"data-constant\": {\n\t\ttype: \"property-type\"\n\t},\n\tconstant: {\n\t\ttype: \"property-type\"\n\t}\n},\n\tpromoteId: promoteId\n};\n\nconst refProperties = ['type', 'source', 'source-layer', 'minzoom', 'maxzoom', 'filter', 'layout'];\n\nfunction deref(layer, parent) {\n    const result = {};\n    for (const k in layer) {\n        if (k !== 'ref') {\n            result[k] = layer[k];\n        }\n    }\n    refProperties.forEach((k) => {\n        if (k in parent) {\n            result[k] = parent[k];\n        }\n    });\n    return result;\n}\n/**\n * Given an array of layers, some of which may contain `ref` properties\n * whose value is the `id` of another property, return a new array where\n * such layers have been augmented with the 'type', 'source', etc. properties\n * from the parent layer, and the `ref` property has been removed.\n *\n * The input is not modified. The output may contain references to portions\n * of the input.\n *\n * @private\n * @param {Array<Layer>} layers\n * @returns {Array<Layer>}\n */\nfunction derefLayers(layers) {\n    layers = layers.slice();\n    const map = Object.create(null);\n    for (let i = 0; i < layers.length; i++) {\n        map[layers[i].id] = layers[i];\n    }\n    for (let i = 0; i < layers.length; i++) {\n        if ('ref' in layers[i]) {\n            layers[i] = deref(layers[i], map[layers[i].ref]);\n        }\n    }\n    return layers;\n}\n\n/**\n * Deeply compares two object literals.\n *\n * @private\n */\nfunction deepEqual(a, b) {\n    if (Array.isArray(a)) {\n        if (!Array.isArray(b) || a.length !== b.length)\n            return false;\n        for (let i = 0; i < a.length; i++) {\n            if (!deepEqual(a[i], b[i]))\n                return false;\n        }\n        return true;\n    }\n    if (typeof a === 'object' && a !== null && b !== null) {\n        if (!(typeof b === 'object'))\n            return false;\n        const keys = Object.keys(a);\n        if (keys.length !== Object.keys(b).length)\n            return false;\n        for (const key in a) {\n            if (!deepEqual(a[key], b[key]))\n                return false;\n        }\n        return true;\n    }\n    return a === b;\n}\n\n/**\n * The main reason for this method is to allow type check when adding a command to the array.\n * @param commands - The commands array to add to\n * @param command - The command to add\n */\nfunction addCommand(commands, command) {\n    commands.push(command);\n}\nfunction addSource(sourceId, after, commands) {\n    addCommand(commands, { command: 'addSource', args: [sourceId, after[sourceId]] });\n}\nfunction removeSource(sourceId, commands, sourcesRemoved) {\n    addCommand(commands, { command: 'removeSource', args: [sourceId] });\n    sourcesRemoved[sourceId] = true;\n}\nfunction updateSource(sourceId, after, commands, sourcesRemoved) {\n    removeSource(sourceId, commands, sourcesRemoved);\n    addSource(sourceId, after, commands);\n}\nfunction canUpdateGeoJSON(before, after, sourceId) {\n    let prop;\n    for (prop in before[sourceId]) {\n        if (!Object.prototype.hasOwnProperty.call(before[sourceId], prop))\n            continue;\n        if (prop !== 'data' && !deepEqual(before[sourceId][prop], after[sourceId][prop])) {\n            return false;\n        }\n    }\n    for (prop in after[sourceId]) {\n        if (!Object.prototype.hasOwnProperty.call(after[sourceId], prop))\n            continue;\n        if (prop !== 'data' && !deepEqual(before[sourceId][prop], after[sourceId][prop])) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction diffSources(before, after, commands, sourcesRemoved) {\n    before = before || {};\n    after = after || {};\n    let sourceId;\n    // look for sources to remove\n    for (sourceId in before) {\n        if (!Object.prototype.hasOwnProperty.call(before, sourceId))\n            continue;\n        if (!Object.prototype.hasOwnProperty.call(after, sourceId)) {\n            removeSource(sourceId, commands, sourcesRemoved);\n        }\n    }\n    // look for sources to add/update\n    for (sourceId in after) {\n        if (!Object.prototype.hasOwnProperty.call(after, sourceId))\n            continue;\n        if (!Object.prototype.hasOwnProperty.call(before, sourceId)) {\n            addSource(sourceId, after, commands);\n        }\n        else if (!deepEqual(before[sourceId], after[sourceId])) {\n            if (before[sourceId].type === 'geojson' && after[sourceId].type === 'geojson' && canUpdateGeoJSON(before, after, sourceId)) {\n                addCommand(commands, { command: 'setGeoJSONSourceData', args: [sourceId, after[sourceId].data] });\n            }\n            else {\n                // no update command, must remove then add\n                updateSource(sourceId, after, commands, sourcesRemoved);\n            }\n        }\n    }\n}\nfunction diffLayerPropertyChanges(before, after, commands, layerId, klass, command) {\n    before = before || {};\n    after = after || {};\n    for (const prop in before) {\n        if (!Object.prototype.hasOwnProperty.call(before, prop))\n            continue;\n        if (!deepEqual(before[prop], after[prop])) {\n            commands.push({ command, args: [layerId, prop, after[prop], klass] });\n        }\n    }\n    for (const prop in after) {\n        if (!Object.prototype.hasOwnProperty.call(after, prop) || Object.prototype.hasOwnProperty.call(before, prop))\n            continue;\n        if (!deepEqual(before[prop], after[prop])) {\n            commands.push({ command, args: [layerId, prop, after[prop], klass] });\n        }\n    }\n}\nfunction pluckId(layer) {\n    return layer.id;\n}\nfunction indexById(group, layer) {\n    group[layer.id] = layer;\n    return group;\n}\nfunction diffLayers(before, after, commands) {\n    before = before || [];\n    after = after || [];\n    // order of layers by id\n    const beforeOrder = before.map(pluckId);\n    const afterOrder = after.map(pluckId);\n    // index of layer by id\n    const beforeIndex = before.reduce(indexById, {});\n    const afterIndex = after.reduce(indexById, {});\n    // track order of layers as if they have been mutated\n    const tracker = beforeOrder.slice();\n    // layers that have been added do not need to be diffed\n    const clean = Object.create(null);\n    let layerId;\n    let beforeLayer;\n    let afterLayer;\n    let insertBeforeLayerId;\n    let prop;\n    // remove layers\n    for (let i = 0, d = 0; i < beforeOrder.length; i++) {\n        layerId = beforeOrder[i];\n        if (!Object.prototype.hasOwnProperty.call(afterIndex, layerId)) {\n            addCommand(commands, { command: 'removeLayer', args: [layerId] });\n            tracker.splice(tracker.indexOf(layerId, d), 1);\n        }\n        else {\n            // limit where in tracker we need to look for a match\n            d++;\n        }\n    }\n    // add/reorder layers\n    for (let i = 0, d = 0; i < afterOrder.length; i++) {\n        // work backwards as insert is before an existing layer\n        layerId = afterOrder[afterOrder.length - 1 - i];\n        if (tracker[tracker.length - 1 - i] === layerId)\n            continue;\n        if (Object.prototype.hasOwnProperty.call(beforeIndex, layerId)) {\n            // remove the layer before we insert at the correct position\n            addCommand(commands, { command: 'removeLayer', args: [layerId] });\n            tracker.splice(tracker.lastIndexOf(layerId, tracker.length - d), 1);\n        }\n        else {\n            // limit where in tracker we need to look for a match\n            d++;\n        }\n        // add layer at correct position\n        insertBeforeLayerId = tracker[tracker.length - i];\n        addCommand(commands, { command: 'addLayer', args: [afterIndex[layerId], insertBeforeLayerId] });\n        tracker.splice(tracker.length - i, 0, layerId);\n        clean[layerId] = true;\n    }\n    // update layers\n    for (let i = 0; i < afterOrder.length; i++) {\n        layerId = afterOrder[i];\n        beforeLayer = beforeIndex[layerId];\n        afterLayer = afterIndex[layerId];\n        // no need to update if previously added (new or moved)\n        if (clean[layerId] || deepEqual(beforeLayer, afterLayer))\n            continue;\n        // If source, source-layer, or type have changes, then remove the layer\n        // and add it back 'from scratch'.\n        if (!deepEqual(beforeLayer.source, afterLayer.source) || !deepEqual(beforeLayer['source-layer'], afterLayer['source-layer']) || !deepEqual(beforeLayer.type, afterLayer.type)) {\n            addCommand(commands, { command: 'removeLayer', args: [layerId] });\n            // we add the layer back at the same position it was already in, so\n            // there's no need to update the `tracker`\n            insertBeforeLayerId = tracker[tracker.lastIndexOf(layerId) + 1];\n            addCommand(commands, { command: 'addLayer', args: [afterLayer, insertBeforeLayerId] });\n            continue;\n        }\n        // layout, paint, filter, minzoom, maxzoom\n        diffLayerPropertyChanges(beforeLayer.layout, afterLayer.layout, commands, layerId, null, 'setLayoutProperty');\n        diffLayerPropertyChanges(beforeLayer.paint, afterLayer.paint, commands, layerId, null, 'setPaintProperty');\n        if (!deepEqual(beforeLayer.filter, afterLayer.filter)) {\n            addCommand(commands, { command: 'setFilter', args: [layerId, afterLayer.filter] });\n        }\n        if (!deepEqual(beforeLayer.minzoom, afterLayer.minzoom) || !deepEqual(beforeLayer.maxzoom, afterLayer.maxzoom)) {\n            addCommand(commands, { command: 'setLayerZoomRange', args: [layerId, afterLayer.minzoom, afterLayer.maxzoom] });\n        }\n        // handle all other layer props, including paint.*\n        for (prop in beforeLayer) {\n            if (!Object.prototype.hasOwnProperty.call(beforeLayer, prop))\n                continue;\n            if (prop === 'layout' || prop === 'paint' || prop === 'filter' ||\n                prop === 'metadata' || prop === 'minzoom' || prop === 'maxzoom')\n                continue;\n            if (prop.indexOf('paint.') === 0) {\n                diffLayerPropertyChanges(beforeLayer[prop], afterLayer[prop], commands, layerId, prop.slice(6), 'setPaintProperty');\n            }\n            else if (!deepEqual(beforeLayer[prop], afterLayer[prop])) {\n                addCommand(commands, { command: 'setLayerProperty', args: [layerId, prop, afterLayer[prop]] });\n            }\n        }\n        for (prop in afterLayer) {\n            if (!Object.prototype.hasOwnProperty.call(afterLayer, prop) || Object.prototype.hasOwnProperty.call(beforeLayer, prop))\n                continue;\n            if (prop === 'layout' || prop === 'paint' || prop === 'filter' ||\n                prop === 'metadata' || prop === 'minzoom' || prop === 'maxzoom')\n                continue;\n            if (prop.indexOf('paint.') === 0) {\n                diffLayerPropertyChanges(beforeLayer[prop], afterLayer[prop], commands, layerId, prop.slice(6), 'setPaintProperty');\n            }\n            else if (!deepEqual(beforeLayer[prop], afterLayer[prop])) {\n                addCommand(commands, { command: 'setLayerProperty', args: [layerId, prop, afterLayer[prop]] });\n            }\n        }\n    }\n}\n/**\n * Diff two stylesheet\n *\n * Creates semanticly aware diffs that can easily be applied at runtime.\n * Operations produced by the diff closely resemble the maplibre-gl-js API. Any\n * error creating the diff will fall back to the 'setStyle' operation.\n *\n * Example diff:\n * [\n *     { command: 'setConstant', args: ['@water', '#0000FF'] },\n *     { command: 'setPaintProperty', args: ['background', 'background-color', 'black'] }\n * ]\n *\n * @private\n * @param {*} [before] stylesheet to compare from\n * @param {*} after stylesheet to compare to\n * @returns Array list of changes\n */\nfunction diff(before, after) {\n    if (!before)\n        return [{ command: 'setStyle', args: [after] }];\n    let commands = [];\n    try {\n        // Handle changes to top-level properties\n        if (!deepEqual(before.version, after.version)) {\n            return [{ command: 'setStyle', args: [after] }];\n        }\n        if (!deepEqual(before.center, after.center)) {\n            commands.push({ command: 'setCenter', args: [after.center] });\n        }\n        if (!deepEqual(before.centerAltitude, after.centerAltitude)) {\n            commands.push({ command: 'setCenterAltitude', args: [after.centerAltitude] });\n        }\n        if (!deepEqual(before.zoom, after.zoom)) {\n            commands.push({ command: 'setZoom', args: [after.zoom] });\n        }\n        if (!deepEqual(before.bearing, after.bearing)) {\n            commands.push({ command: 'setBearing', args: [after.bearing] });\n        }\n        if (!deepEqual(before.pitch, after.pitch)) {\n            commands.push({ command: 'setPitch', args: [after.pitch] });\n        }\n        if (!deepEqual(before.roll, after.roll)) {\n            commands.push({ command: 'setRoll', args: [after.roll] });\n        }\n        if (!deepEqual(before.sprite, after.sprite)) {\n            commands.push({ command: 'setSprite', args: [after.sprite] });\n        }\n        if (!deepEqual(before.glyphs, after.glyphs)) {\n            commands.push({ command: 'setGlyphs', args: [after.glyphs] });\n        }\n        if (!deepEqual(before.transition, after.transition)) {\n            commands.push({ command: 'setTransition', args: [after.transition] });\n        }\n        if (!deepEqual(before.light, after.light)) {\n            commands.push({ command: 'setLight', args: [after.light] });\n        }\n        if (!deepEqual(before.terrain, after.terrain)) {\n            commands.push({ command: 'setTerrain', args: [after.terrain] });\n        }\n        if (!deepEqual(before.sky, after.sky)) {\n            commands.push({ command: 'setSky', args: [after.sky] });\n        }\n        if (!deepEqual(before.projection, after.projection)) {\n            commands.push({ command: 'setProjection', args: [after.projection] });\n        }\n        // Handle changes to `sources`\n        // If a source is to be removed, we also--before the removeSource\n        // command--need to remove all the style layers that depend on it.\n        const sourcesRemoved = {};\n        // First collect the {add,remove}Source commands\n        const removeOrAddSourceCommands = [];\n        diffSources(before.sources, after.sources, removeOrAddSourceCommands, sourcesRemoved);\n        // Push a removeLayer command for each style layer that depends on a\n        // source that's being removed.\n        // Also, exclude any such layers them from the input to `diffLayers`\n        // below, so that diffLayers produces the appropriate `addLayers`\n        // command\n        const beforeLayers = [];\n        if (before.layers) {\n            before.layers.forEach((layer) => {\n                if ('source' in layer && sourcesRemoved[layer.source]) {\n                    commands.push({ command: 'removeLayer', args: [layer.id] });\n                }\n                else {\n                    beforeLayers.push(layer);\n                }\n            });\n        }\n        commands = commands.concat(removeOrAddSourceCommands);\n        // Handle changes to `layers`\n        diffLayers(beforeLayers, after.layers, commands);\n    }\n    catch (e) {\n        // fall back to setStyle\n        console.warn('Unable to compute style diff:', e);\n        commands = [{ command: 'setStyle', args: [after] }];\n    }\n    return commands;\n}\n\n// Note: Do not inherit from Error. It breaks when transpiling to ES5.\nclass ValidationError {\n    constructor(key, value, message, identifier) {\n        this.message = (key ? `${key}: ` : '') + message;\n        if (identifier)\n            this.identifier = identifier;\n        if (value !== null && value !== undefined && value.__line__) {\n            this.line = value.__line__;\n        }\n    }\n}\n\n// Note: Do not inherit from Error. It breaks when transpiling to ES5.\nclass ParsingError {\n    constructor(error) {\n        this.error = error;\n        this.message = error.message;\n        const match = error.message.match(/line (\\d+)/);\n        this.line = match ? parseInt(match[1], 10) : 0;\n    }\n}\n\nfunction extendBy(output, ...inputs) {\n    for (const input of inputs) {\n        for (const k in input) {\n            output[k] = input[k];\n        }\n    }\n    return output;\n}\n\nclass ExpressionParsingError extends Error {\n    constructor(key, message) {\n        super(message);\n        this.message = message;\n        this.key = key;\n    }\n}\n\n/**\n * Tracks `let` bindings during expression parsing.\n * @private\n */\nclass Scope {\n    constructor(parent, bindings = []) {\n        this.parent = parent;\n        this.bindings = {};\n        for (const [name, expression] of bindings) {\n            this.bindings[name] = expression;\n        }\n    }\n    concat(bindings) {\n        return new Scope(this, bindings);\n    }\n    get(name) {\n        if (this.bindings[name]) {\n            return this.bindings[name];\n        }\n        if (this.parent) {\n            return this.parent.get(name);\n        }\n        throw new Error(`${name} not found in scope.`);\n    }\n    has(name) {\n        if (this.bindings[name])\n            return true;\n        return this.parent ? this.parent.has(name) : false;\n    }\n}\n\nconst NullType = { kind: 'null' };\nconst NumberType = { kind: 'number' };\nconst StringType = { kind: 'string' };\nconst BooleanType = { kind: 'boolean' };\nconst ColorType = { kind: 'color' };\nconst ProjectionDefinitionType = { kind: 'projectionDefinition' };\nconst ObjectType = { kind: 'object' };\nconst ValueType = { kind: 'value' };\nconst ErrorType = { kind: 'error' };\nconst CollatorType = { kind: 'collator' };\nconst FormattedType = { kind: 'formatted' };\nconst PaddingType = { kind: 'padding' };\nconst ResolvedImageType = { kind: 'resolvedImage' };\nconst VariableAnchorOffsetCollectionType = { kind: 'variableAnchorOffsetCollection' };\nfunction array(itemType, N) {\n    return {\n        kind: 'array',\n        itemType,\n        N\n    };\n}\nfunction typeToString(type) {\n    if (type.kind === 'array') {\n        const itemType = typeToString(type.itemType);\n        return typeof type.N === 'number' ?\n            `array<${itemType}, ${type.N}>` :\n            type.itemType.kind === 'value' ? 'array' : `array<${itemType}>`;\n    }\n    else {\n        return type.kind;\n    }\n}\nconst valueMemberTypes = [\n    NullType,\n    NumberType,\n    StringType,\n    BooleanType,\n    ColorType,\n    ProjectionDefinitionType,\n    FormattedType,\n    ObjectType,\n    array(ValueType),\n    PaddingType,\n    ResolvedImageType,\n    VariableAnchorOffsetCollectionType\n];\n/**\n * Returns null if `t` is a subtype of `expected`; otherwise returns an\n * error message.\n * @private\n */\nfunction checkSubtype(expected, t) {\n    if (t.kind === 'error') {\n        // Error is a subtype of every type\n        return null;\n    }\n    else if (expected.kind === 'array') {\n        if (t.kind === 'array' &&\n            ((t.N === 0 && t.itemType.kind === 'value') || !checkSubtype(expected.itemType, t.itemType)) &&\n            (typeof expected.N !== 'number' || expected.N === t.N)) {\n            return null;\n        }\n    }\n    else if (expected.kind === t.kind) {\n        return null;\n    }\n    else if (expected.kind === 'value') {\n        for (const memberType of valueMemberTypes) {\n            if (!checkSubtype(memberType, t)) {\n                return null;\n            }\n        }\n    }\n    return `Expected ${typeToString(expected)} but found ${typeToString(t)} instead.`;\n}\nfunction isValidType(provided, allowedTypes) {\n    return allowedTypes.some(t => t.kind === provided.kind);\n}\nfunction isValidNativeType(provided, allowedTypes) {\n    return allowedTypes.some(t => {\n        if (t === 'null') {\n            return provided === null;\n        }\n        else if (t === 'array') {\n            return Array.isArray(provided);\n        }\n        else if (t === 'object') {\n            return provided && !Array.isArray(provided) && typeof provided === 'object';\n        }\n        else {\n            return t === typeof provided;\n        }\n    });\n}\n/**\n * Verify whether the specified type is of the same type as the specified sample.\n *\n * @param provided Type to verify\n * @param sample Sample type to reference\n * @returns `true` if both objects are of the same type, `false` otherwise\n * @example basic types\n * if (verifyType(outputType, ValueType)) {\n *     // type narrowed to:\n *     outputType.kind; // 'value'\n * }\n * @example array types\n * if (verifyType(outputType, array(NumberType))) {\n *     // type narrowed to:\n *     outputType.kind; // 'array'\n *     outputType.itemType; // NumberTypeT\n *     outputType.itemType.kind; // 'number'\n * }\n */\nfunction verifyType(provided, sample) {\n    if (provided.kind === 'array' && sample.kind === 'array') {\n        return provided.itemType.kind === sample.itemType.kind && typeof provided.N === 'number';\n    }\n    return provided.kind === sample.kind;\n}\n\n// See https://observablehq.com/@mbostock/lab-and-rgb\nconst Xn = 0.96422, Yn = 1, Zn = 0.82521, t0 = 4 / 29, t1 = 6 / 29, t2 = 3 * t1 * t1, t3 = t1 * t1 * t1, deg2rad = Math.PI / 180, rad2deg = 180 / Math.PI;\nfunction constrainAngle(angle) {\n    angle = angle % 360;\n    if (angle < 0) {\n        angle += 360;\n    }\n    return angle;\n}\nfunction rgbToLab([r, g, b, alpha]) {\n    r = rgb2xyz(r);\n    g = rgb2xyz(g);\n    b = rgb2xyz(b);\n    let x, z;\n    const y = xyz2lab((0.2225045 * r + 0.7168786 * g + 0.0606169 * b) / Yn);\n    if (r === g && g === b) {\n        x = z = y;\n    }\n    else {\n        x = xyz2lab((0.4360747 * r + 0.3850649 * g + 0.1430804 * b) / Xn);\n        z = xyz2lab((0.0139322 * r + 0.0971045 * g + 0.7141733 * b) / Zn);\n    }\n    const l = 116 * y - 16;\n    return [(l < 0) ? 0 : l, 500 * (x - y), 200 * (y - z), alpha];\n}\nfunction rgb2xyz(x) {\n    return (x <= 0.04045) ? x / 12.92 : Math.pow((x + 0.055) / 1.055, 2.4);\n}\nfunction xyz2lab(t) {\n    return (t > t3) ? Math.pow(t, 1 / 3) : t / t2 + t0;\n}\nfunction labToRgb([l, a, b, alpha]) {\n    let y = (l + 16) / 116, x = isNaN(a) ? y : y + a / 500, z = isNaN(b) ? y : y - b / 200;\n    y = Yn * lab2xyz(y);\n    x = Xn * lab2xyz(x);\n    z = Zn * lab2xyz(z);\n    return [\n        xyz2rgb(3.1338561 * x - 1.6168667 * y - 0.4906146 * z), // D50 -> sRGB\n        xyz2rgb(-0.9787684 * x + 1.9161415 * y + 0.0334540 * z),\n        xyz2rgb(0.0719453 * x - 0.2289914 * y + 1.4052427 * z),\n        alpha,\n    ];\n}\nfunction xyz2rgb(x) {\n    x = (x <= 0.00304) ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055;\n    return (x < 0) ? 0 : (x > 1) ? 1 : x; // clip to 0..1 range\n}\nfunction lab2xyz(t) {\n    return (t > t1) ? t * t * t : t2 * (t - t0);\n}\nfunction rgbToHcl(rgbColor) {\n    const [l, a, b, alpha] = rgbToLab(rgbColor);\n    const c = Math.sqrt(a * a + b * b);\n    const h = Math.round(c * 10000) ? constrainAngle(Math.atan2(b, a) * rad2deg) : NaN;\n    return [h, c, l, alpha];\n}\nfunction hclToRgb([h, c, l, alpha]) {\n    h = isNaN(h) ? 0 : h * deg2rad;\n    return labToRgb([l, Math.cos(h) * c, Math.sin(h) * c, alpha]);\n}\n// https://drafts.csswg.org/css-color-4/#hsl-to-rgb\nfunction hslToRgb([h, s, l, alpha]) {\n    h = constrainAngle(h);\n    s /= 100;\n    l /= 100;\n    function f(n) {\n        const k = (n + h / 30) % 12;\n        const a = s * Math.min(l, 1 - l);\n        return l - a * Math.max(-1, Math.min(k - 3, 9 - k, 1));\n    }\n    return [f(0), f(8), f(4), alpha];\n}\n\n/**\n * CSS color parser compliant with CSS Color 4 Specification.\n * Supports: named colors, `transparent` keyword, all rgb hex notations,\n * rgb(), rgba(), hsl() and hsla() functions.\n * Does not round the parsed values to integers from the range 0..255.\n *\n * Syntax:\n *\n * <alpha-value> = <number> | <percentage>\n *         <hue> = <number> | <angle>\n *\n *         rgb() = rgb( <percentage>{3} [ / <alpha-value> ]? ) | rgb( <number>{3} [ / <alpha-value> ]? )\n *         rgb() = rgb( <percentage>#{3} , <alpha-value>? )    | rgb( <number>#{3} , <alpha-value>? )\n *\n *         hsl() = hsl( <hue> <percentage> <percentage> [ / <alpha-value> ]? )\n *         hsl() = hsl( <hue>, <percentage>, <percentage>, <alpha-value>? )\n *\n * Caveats:\n *   - <angle> - <number> with optional `deg` suffix; `grad`, `rad`, `turn` are not supported\n *   - `none` keyword is not supported\n *   - comments inside rgb()/hsl() are not supported\n *   - legacy color syntax rgba() is supported with an identical grammar and behavior to rgb()\n *   - legacy color syntax hsla() is supported with an identical grammar and behavior to hsl()\n *\n * @param input CSS color string to parse.\n * @returns Color in sRGB color space, with `red`, `green`, `blue`\n * and `alpha` channels normalized to the range 0..1,\n * or `undefined` if the input is not a valid color string.\n */\nfunction parseCssColor(input) {\n    input = input.toLowerCase().trim();\n    if (input === 'transparent') {\n        return [0, 0, 0, 0];\n    }\n    // 'white', 'black', 'blue'\n    const namedColorsMatch = namedColors[input];\n    if (namedColorsMatch) {\n        const [r, g, b] = namedColorsMatch;\n        return [r / 255, g / 255, b / 255, 1];\n    }\n    // #f0c, #f0cf, #ff00cc, #ff00ccff\n    if (input.startsWith('#')) {\n        const hexRegexp = /^#(?:[0-9a-f]{3,4}|[0-9a-f]{6}|[0-9a-f]{8})$/;\n        if (hexRegexp.test(input)) {\n            const step = input.length < 6 ? 1 : 2;\n            let i = 1;\n            return [\n                parseHex(input.slice(i, i += step)),\n                parseHex(input.slice(i, i += step)),\n                parseHex(input.slice(i, i += step)),\n                parseHex(input.slice(i, i + step) || 'ff'),\n            ];\n        }\n    }\n    // rgb(128 0 0), rgb(50% 0% 0%), rgba(255,0,255,0.6), rgb(255 0 255 / 60%), rgb(100% 0% 100% /.6)\n    if (input.startsWith('rgb')) {\n        const rgbRegExp = /^rgba?\\(\\s*([\\de.+-]+)(%)?(?:\\s+|\\s*(,)\\s*)([\\de.+-]+)(%)?(?:\\s+|\\s*(,)\\s*)([\\de.+-]+)(%)?(?:\\s*([,\\/])\\s*([\\de.+-]+)(%)?)?\\s*\\)$/;\n        const rgbMatch = input.match(rgbRegExp);\n        if (rgbMatch) {\n            const [_, // eslint-disable-line @typescript-eslint/no-unused-vars\n            r, // <numeric>\n            rp, // %         (optional)\n            f1, // ,         (optional)\n            g, // <numeric>\n            gp, // %         (optional)\n            f2, // ,         (optional)\n            b, // <numeric>\n            bp, // %         (optional)\n            f3, // ,|/       (optional)\n            a, // <numeric> (optional)\n            ap, // %         (optional)\n            ] = rgbMatch;\n            const argFormat = [f1 || ' ', f2 || ' ', f3].join('');\n            if (argFormat === '  ' ||\n                argFormat === '  /' ||\n                argFormat === ',,' ||\n                argFormat === ',,,') {\n                const valFormat = [rp, gp, bp].join('');\n                const maxValue = (valFormat === '%%%') ? 100 :\n                    (valFormat === '') ? 255 : 0;\n                if (maxValue) {\n                    const rgba = [\n                        clamp(+r / maxValue, 0, 1),\n                        clamp(+g / maxValue, 0, 1),\n                        clamp(+b / maxValue, 0, 1),\n                        a ? parseAlpha(+a, ap) : 1,\n                    ];\n                    if (validateNumbers(rgba)) {\n                        return rgba;\n                    }\n                    // invalid numbers\n                }\n                // values must be all numbers or all percentages\n            }\n            return; // comma optional syntax requires no commas at all\n        }\n    }\n    // hsl(120 50% 80%), hsla(120deg,50%,80%,.9), hsl(12e1 50% 80% / 90%)\n    const hslRegExp = /^hsla?\\(\\s*([\\de.+-]+)(?:deg)?(?:\\s+|\\s*(,)\\s*)([\\de.+-]+)%(?:\\s+|\\s*(,)\\s*)([\\de.+-]+)%(?:\\s*([,\\/])\\s*([\\de.+-]+)(%)?)?\\s*\\)$/;\n    const hslMatch = input.match(hslRegExp);\n    if (hslMatch) {\n        const [_, // eslint-disable-line @typescript-eslint/no-unused-vars\n        h, // <numeric>\n        f1, // ,         (optional)\n        s, // <numeric>\n        f2, // ,         (optional)\n        l, // <numeric>\n        f3, // ,|/       (optional)\n        a, // <numeric> (optional)\n        ap, // %         (optional)\n        ] = hslMatch;\n        const argFormat = [f1 || ' ', f2 || ' ', f3].join('');\n        if (argFormat === '  ' ||\n            argFormat === '  /' ||\n            argFormat === ',,' ||\n            argFormat === ',,,') {\n            const hsla = [\n                +h,\n                clamp(+s, 0, 100),\n                clamp(+l, 0, 100),\n                a ? parseAlpha(+a, ap) : 1,\n            ];\n            if (validateNumbers(hsla)) {\n                return hslToRgb(hsla);\n            }\n            // invalid numbers\n        }\n        // comma optional syntax requires no commas at all\n    }\n}\nfunction parseHex(hex) {\n    return parseInt(hex.padEnd(2, hex), 16) / 255;\n}\nfunction parseAlpha(a, asPercentage) {\n    return clamp(asPercentage ? (a / 100) : a, 0, 1);\n}\nfunction clamp(n, min, max) {\n    return Math.min(Math.max(min, n), max);\n}\n/**\n * The regular expression for numeric values is not super specific, and it may\n * happen that it will accept a value that is not a valid number. In order to\n * detect and eliminate such values this function exists.\n *\n * @param array Array of uncertain numbers.\n * @returns `true` if the specified array contains only valid numbers, `false` otherwise.\n */\nfunction validateNumbers(array) {\n    return !array.some(Number.isNaN);\n}\n/**\n * To generate:\n * - visit {@link https://www.w3.org/TR/css-color-4/#named-colors}\n * - run in the console:\n * @example\n * copy(`{\\n${[...document.querySelector('.named-color-table tbody').children].map((tr) => `${tr.cells[2].textContent.trim()}: [${tr.cells[4].textContent.trim().split(/\\s+/).join(', ')}],`).join('\\n')}\\n}`);\n */\nconst namedColors = {\n    aliceblue: [240, 248, 255],\n    antiquewhite: [250, 235, 215],\n    aqua: [0, 255, 255],\n    aquamarine: [127, 255, 212],\n    azure: [240, 255, 255],\n    beige: [245, 245, 220],\n    bisque: [255, 228, 196],\n    black: [0, 0, 0],\n    blanchedalmond: [255, 235, 205],\n    blue: [0, 0, 255],\n    blueviolet: [138, 43, 226],\n    brown: [165, 42, 42],\n    burlywood: [222, 184, 135],\n    cadetblue: [95, 158, 160],\n    chartreuse: [127, 255, 0],\n    chocolate: [210, 105, 30],\n    coral: [255, 127, 80],\n    cornflowerblue: [100, 149, 237],\n    cornsilk: [255, 248, 220],\n    crimson: [220, 20, 60],\n    cyan: [0, 255, 255],\n    darkblue: [0, 0, 139],\n    darkcyan: [0, 139, 139],\n    darkgoldenrod: [184, 134, 11],\n    darkgray: [169, 169, 169],\n    darkgreen: [0, 100, 0],\n    darkgrey: [169, 169, 169],\n    darkkhaki: [189, 183, 107],\n    darkmagenta: [139, 0, 139],\n    darkolivegreen: [85, 107, 47],\n    darkorange: [255, 140, 0],\n    darkorchid: [153, 50, 204],\n    darkred: [139, 0, 0],\n    darksalmon: [233, 150, 122],\n    darkseagreen: [143, 188, 143],\n    darkslateblue: [72, 61, 139],\n    darkslategray: [47, 79, 79],\n    darkslategrey: [47, 79, 79],\n    darkturquoise: [0, 206, 209],\n    darkviolet: [148, 0, 211],\n    deeppink: [255, 20, 147],\n    deepskyblue: [0, 191, 255],\n    dimgray: [105, 105, 105],\n    dimgrey: [105, 105, 105],\n    dodgerblue: [30, 144, 255],\n    firebrick: [178, 34, 34],\n    floralwhite: [255, 250, 240],\n    forestgreen: [34, 139, 34],\n    fuchsia: [255, 0, 255],\n    gainsboro: [220, 220, 220],\n    ghostwhite: [248, 248, 255],\n    gold: [255, 215, 0],\n    goldenrod: [218, 165, 32],\n    gray: [128, 128, 128],\n    green: [0, 128, 0],\n    greenyellow: [173, 255, 47],\n    grey: [128, 128, 128],\n    honeydew: [240, 255, 240],\n    hotpink: [255, 105, 180],\n    indianred: [205, 92, 92],\n    indigo: [75, 0, 130],\n    ivory: [255, 255, 240],\n    khaki: [240, 230, 140],\n    lavender: [230, 230, 250],\n    lavenderblush: [255, 240, 245],\n    lawngreen: [124, 252, 0],\n    lemonchiffon: [255, 250, 205],\n    lightblue: [173, 216, 230],\n    lightcoral: [240, 128, 128],\n    lightcyan: [224, 255, 255],\n    lightgoldenrodyellow: [250, 250, 210],\n    lightgray: [211, 211, 211],\n    lightgreen: [144, 238, 144],\n    lightgrey: [211, 211, 211],\n    lightpink: [255, 182, 193],\n    lightsalmon: [255, 160, 122],\n    lightseagreen: [32, 178, 170],\n    lightskyblue: [135, 206, 250],\n    lightslategray: [119, 136, 153],\n    lightslategrey: [119, 136, 153],\n    lightsteelblue: [176, 196, 222],\n    lightyellow: [255, 255, 224],\n    lime: [0, 255, 0],\n    limegreen: [50, 205, 50],\n    linen: [250, 240, 230],\n    magenta: [255, 0, 255],\n    maroon: [128, 0, 0],\n    mediumaquamarine: [102, 205, 170],\n    mediumblue: [0, 0, 205],\n    mediumorchid: [186, 85, 211],\n    mediumpurple: [147, 112, 219],\n    mediumseagreen: [60, 179, 113],\n    mediumslateblue: [123, 104, 238],\n    mediumspringgreen: [0, 250, 154],\n    mediumturquoise: [72, 209, 204],\n    mediumvioletred: [199, 21, 133],\n    midnightblue: [25, 25, 112],\n    mintcream: [245, 255, 250],\n    mistyrose: [255, 228, 225],\n    moccasin: [255, 228, 181],\n    navajowhite: [255, 222, 173],\n    navy: [0, 0, 128],\n    oldlace: [253, 245, 230],\n    olive: [128, 128, 0],\n    olivedrab: [107, 142, 35],\n    orange: [255, 165, 0],\n    orangered: [255, 69, 0],\n    orchid: [218, 112, 214],\n    palegoldenrod: [238, 232, 170],\n    palegreen: [152, 251, 152],\n    paleturquoise: [175, 238, 238],\n    palevioletred: [219, 112, 147],\n    papayawhip: [255, 239, 213],\n    peachpuff: [255, 218, 185],\n    peru: [205, 133, 63],\n    pink: [255, 192, 203],\n    plum: [221, 160, 221],\n    powderblue: [176, 224, 230],\n    purple: [128, 0, 128],\n    rebeccapurple: [102, 51, 153],\n    red: [255, 0, 0],\n    rosybrown: [188, 143, 143],\n    royalblue: [65, 105, 225],\n    saddlebrown: [139, 69, 19],\n    salmon: [250, 128, 114],\n    sandybrown: [244, 164, 96],\n    seagreen: [46, 139, 87],\n    seashell: [255, 245, 238],\n    sienna: [160, 82, 45],\n    silver: [192, 192, 192],\n    skyblue: [135, 206, 235],\n    slateblue: [106, 90, 205],\n    slategray: [112, 128, 144],\n    slategrey: [112, 128, 144],\n    snow: [255, 250, 250],\n    springgreen: [0, 255, 127],\n    steelblue: [70, 130, 180],\n    tan: [210, 180, 140],\n    teal: [0, 128, 128],\n    thistle: [216, 191, 216],\n    tomato: [255, 99, 71],\n    turquoise: [64, 224, 208],\n    violet: [238, 130, 238],\n    wheat: [245, 222, 179],\n    white: [255, 255, 255],\n    whitesmoke: [245, 245, 245],\n    yellow: [255, 255, 0],\n    yellowgreen: [154, 205, 50],\n};\n\nfunction interpolateNumber(from, to, t) {\n    return from + t * (to - from);\n}\nfunction interpolateArray(from, to, t) {\n    return from.map((d, i) => {\n        return interpolateNumber(d, to[i], t);\n    });\n}\n\n/**\n * Checks whether the specified color space is one of the supported interpolation color spaces.\n *\n * @param colorSpace Color space key to verify.\n * @returns `true` if the specified color space is one of the supported\n * interpolation color spaces, `false` otherwise\n */\nfunction isSupportedInterpolationColorSpace(colorSpace) {\n    return colorSpace === 'rgb' || colorSpace === 'hcl' || colorSpace === 'lab';\n}\n/**\n * Color representation used by WebGL.\n * Defined in sRGB color space and pre-blended with alpha.\n * @private\n */\nclass Color {\n    /**\n     * @param r Red component premultiplied by `alpha` 0..1\n     * @param g Green component premultiplied by `alpha` 0..1\n     * @param b Blue component premultiplied by `alpha` 0..1\n     * @param [alpha=1] Alpha component 0..1\n     * @param [premultiplied=true] Whether the `r`, `g` and `b` values have already\n     * been multiplied by alpha. If `true` nothing happens if `false` then they will\n     * be multiplied automatically.\n     */\n    constructor(r, g, b, alpha = 1, premultiplied = true) {\n        this.r = r;\n        this.g = g;\n        this.b = b;\n        this.a = alpha;\n        if (!premultiplied) {\n            this.r *= alpha;\n            this.g *= alpha;\n            this.b *= alpha;\n            if (!alpha) {\n                // alpha = 0 erases completely rgb channels. This behavior is not desirable\n                // if this particular color is later used in color interpolation.\n                // Because of that, a reference to original color is saved.\n                this.overwriteGetter('rgb', [r, g, b, alpha]);\n            }\n        }\n    }\n    /**\n     * Parses CSS color strings and converts colors to sRGB color space if needed.\n     * Officially supported color formats:\n     * - keyword, e.g. 'aquamarine' or 'steelblue'\n     * - hex (with 3, 4, 6 or 8 digits), e.g. '#f0f' or '#e9bebea9'\n     * - rgb and rgba, e.g. 'rgb(0,240,120)' or 'rgba(0%,94%,47%,0.1)' or 'rgb(0 240 120 / .3)'\n     * - hsl and hsla, e.g. 'hsl(0,0%,83%)' or 'hsla(0,0%,83%,.5)' or 'hsl(0 0% 83% / 20%)'\n     *\n     * @param input CSS color string to parse.\n     * @returns A `Color` instance, or `undefined` if the input is not a valid color string.\n     */\n    static parse(input) {\n        // in zoom-and-property function input could be an instance of Color class\n        if (input instanceof Color) {\n            return input;\n        }\n        if (typeof input !== 'string') {\n            return;\n        }\n        const rgba = parseCssColor(input);\n        if (rgba) {\n            return new Color(...rgba, false);\n        }\n    }\n    /**\n     * Used in color interpolation and by 'to-rgba' expression.\n     *\n     * @returns Gien color, with reversed alpha blending, in sRGB color space.\n     */\n    get rgb() {\n        const { r, g, b, a } = this;\n        const f = a || Infinity; // reverse alpha blending factor\n        return this.overwriteGetter('rgb', [r / f, g / f, b / f, a]);\n    }\n    /**\n     * Used in color interpolation.\n     *\n     * @returns Gien color, with reversed alpha blending, in HCL color space.\n     */\n    get hcl() {\n        return this.overwriteGetter('hcl', rgbToHcl(this.rgb));\n    }\n    /**\n     * Used in color interpolation.\n     *\n     * @returns Gien color, with reversed alpha blending, in LAB color space.\n     */\n    get lab() {\n        return this.overwriteGetter('lab', rgbToLab(this.rgb));\n    }\n    /**\n     * Lazy getter pattern. When getter is called for the first time lazy value\n     * is calculated and then overwrites getter function in given object instance.\n     *\n     * @example:\n     * const redColor = Color.parse('red');\n     * let x = redColor.hcl; // this will invoke `get hcl()`, which will calculate\n     * // the value of red in HCL space and invoke this `overwriteGetter` function\n     * // which in turn will set a field with a key 'hcl' in the `redColor` object.\n     * // In other words it will override `get hcl()` from its `Color` prototype\n     * // with its own property: hcl = [calculated red value in hcl].\n     * let y = redColor.hcl; // next call will no longer invoke getter but simply\n     * // return the previously calculated value\n     * x === y; // true - `x` is exactly the same object as `y`\n     *\n     * @param getterKey Getter key\n     * @param lazyValue Lazily calculated value to be memoized by current instance\n     * @private\n     */\n    overwriteGetter(getterKey, lazyValue) {\n        Object.defineProperty(this, getterKey, { value: lazyValue });\n        return lazyValue;\n    }\n    /**\n     * Used by 'to-string' expression.\n     *\n     * @returns Serialized color in format `rgba(r,g,b,a)`\n     * where r,g,b are numbers within 0..255 and alpha is number within 1..0\n     *\n     * @example\n     * var purple = new Color.parse('purple');\n     * purple.toString; // = \"rgba(128,0,128,1)\"\n     * var translucentGreen = new Color.parse('rgba(26, 207, 26, .73)');\n     * translucentGreen.toString(); // = \"rgba(26,207,26,0.73)\"\n     */\n    toString() {\n        const [r, g, b, a] = this.rgb;\n        return `rgba(${[r, g, b].map(n => Math.round(n * 255)).join(',')},${a})`;\n    }\n    static interpolate(from, to, t, spaceKey = 'rgb') {\n        switch (spaceKey) {\n            case 'rgb': {\n                const [r, g, b, alpha] = interpolateArray(from.rgb, to.rgb, t);\n                return new Color(r, g, b, alpha, false);\n            }\n            case 'hcl': {\n                const [hue0, chroma0, light0, alphaF] = from.hcl;\n                const [hue1, chroma1, light1, alphaT] = to.hcl;\n                // https://github.com/gka/chroma.js/blob/cd1b3c0926c7a85cbdc3b1453b3a94006de91a92/src/interpolator/_hsx.js\n                let hue, chroma;\n                if (!isNaN(hue0) && !isNaN(hue1)) {\n                    let dh = hue1 - hue0;\n                    if (hue1 > hue0 && dh > 180) {\n                        dh -= 360;\n                    }\n                    else if (hue1 < hue0 && hue0 - hue1 > 180) {\n                        dh += 360;\n                    }\n                    hue = hue0 + t * dh;\n                }\n                else if (!isNaN(hue0)) {\n                    hue = hue0;\n                    if (light1 === 1 || light1 === 0)\n                        chroma = chroma0;\n                }\n                else if (!isNaN(hue1)) {\n                    hue = hue1;\n                    if (light0 === 1 || light0 === 0)\n                        chroma = chroma1;\n                }\n                else {\n                    hue = NaN;\n                }\n                const [r, g, b, alpha] = hclToRgb([\n                    hue,\n                    chroma !== null && chroma !== void 0 ? chroma : interpolateNumber(chroma0, chroma1, t),\n                    interpolateNumber(light0, light1, t),\n                    interpolateNumber(alphaF, alphaT, t),\n                ]);\n                return new Color(r, g, b, alpha, false);\n            }\n            case 'lab': {\n                const [r, g, b, alpha] = labToRgb(interpolateArray(from.lab, to.lab, t));\n                return new Color(r, g, b, alpha, false);\n            }\n        }\n    }\n}\nColor.black = new Color(0, 0, 0, 1);\nColor.white = new Color(1, 1, 1, 1);\nColor.transparent = new Color(0, 0, 0, 0);\nColor.red = new Color(1, 0, 0, 1);\n\n// Flow type declarations for Intl cribbed from\n// https://github.com/facebook/flow/issues/1270\nclass Collator {\n    constructor(caseSensitive, diacriticSensitive, locale) {\n        if (caseSensitive)\n            this.sensitivity = diacriticSensitive ? 'variant' : 'case';\n        else\n            this.sensitivity = diacriticSensitive ? 'accent' : 'base';\n        this.locale = locale;\n        this.collator = new Intl.Collator(this.locale ? this.locale : [], { sensitivity: this.sensitivity, usage: 'search' });\n    }\n    compare(lhs, rhs) {\n        return this.collator.compare(lhs, rhs);\n    }\n    resolvedLocale() {\n        // We create a Collator without \"usage: search\" because we don't want\n        // the search options encoded in our result (e.g. \"en-u-co-search\")\n        return new Intl.Collator(this.locale ? this.locale : [])\n            .resolvedOptions().locale;\n    }\n}\n\nclass FormattedSection {\n    constructor(text, image, scale, fontStack, textColor) {\n        this.text = text;\n        this.image = image;\n        this.scale = scale;\n        this.fontStack = fontStack;\n        this.textColor = textColor;\n    }\n}\nclass Formatted {\n    constructor(sections) {\n        this.sections = sections;\n    }\n    static fromString(unformatted) {\n        return new Formatted([new FormattedSection(unformatted, null, null, null, null)]);\n    }\n    isEmpty() {\n        if (this.sections.length === 0)\n            return true;\n        return !this.sections.some(section => section.text.length !== 0 ||\n            (section.image && section.image.name.length !== 0));\n    }\n    static factory(text) {\n        if (text instanceof Formatted) {\n            return text;\n        }\n        else {\n            return Formatted.fromString(text);\n        }\n    }\n    toString() {\n        if (this.sections.length === 0)\n            return '';\n        return this.sections.map(section => section.text).join('');\n    }\n}\n\n/**\n * A set of four numbers representing padding around a box. Create instances from\n * bare arrays or numeric values using the static method `Padding.parse`.\n * @private\n */\nclass Padding {\n    constructor(values) {\n        this.values = values.slice();\n    }\n    /**\n     * Numeric padding values\n     * @param input A padding value\n     * @returns A `Padding` instance, or `undefined` if the input is not a valid padding value.\n     */\n    static parse(input) {\n        if (input instanceof Padding) {\n            return input;\n        }\n        // Backwards compatibility: bare number is treated the same as array with single value.\n        // Padding applies to all four sides.\n        if (typeof input === 'number') {\n            return new Padding([input, input, input, input]);\n        }\n        if (!Array.isArray(input)) {\n            return undefined;\n        }\n        if (input.length < 1 || input.length > 4) {\n            return undefined;\n        }\n        for (const val of input) {\n            if (typeof val !== 'number') {\n                return undefined;\n            }\n        }\n        // Expand shortcut properties into explicit 4-sided values\n        switch (input.length) {\n            case 1:\n                input = [input[0], input[0], input[0], input[0]];\n                break;\n            case 2:\n                input = [input[0], input[1], input[0], input[1]];\n                break;\n            case 3:\n                input = [input[0], input[1], input[2], input[1]];\n                break;\n        }\n        return new Padding(input);\n    }\n    toString() {\n        return JSON.stringify(this.values);\n    }\n    static interpolate(from, to, t) {\n        return new Padding(interpolateArray(from.values, to.values, t));\n    }\n}\n\nclass RuntimeError {\n    constructor(message) {\n        this.name = 'ExpressionEvaluationError';\n        this.message = message;\n    }\n    toJSON() {\n        return this.message;\n    }\n}\n\n/** Set of valid anchor positions, as a set for validation */\nconst anchors = new Set(['center', 'left', 'right', 'top', 'bottom', 'top-left', 'top-right', 'bottom-left', 'bottom-right']);\n/**\n * Utility class to assist managing values for text-variable-anchor-offset property. Create instances from\n * bare arrays using the static method `VariableAnchorOffsetCollection.parse`.\n * @private\n */\nclass VariableAnchorOffsetCollection {\n    constructor(values) {\n        this.values = values.slice();\n    }\n    static parse(input) {\n        if (input instanceof VariableAnchorOffsetCollection) {\n            return input;\n        }\n        if (!Array.isArray(input) ||\n            input.length < 1 ||\n            input.length % 2 !== 0) {\n            return undefined;\n        }\n        for (let i = 0; i < input.length; i += 2) {\n            // Elements in even positions should be anchor positions; Elements in odd positions should be offset values\n            const anchorValue = input[i];\n            const offsetValue = input[i + 1];\n            if (typeof anchorValue !== 'string' || !anchors.has(anchorValue)) {\n                return undefined;\n            }\n            if (!Array.isArray(offsetValue) || offsetValue.length !== 2 || typeof offsetValue[0] !== 'number' || typeof offsetValue[1] !== 'number') {\n                return undefined;\n            }\n        }\n        return new VariableAnchorOffsetCollection(input);\n    }\n    toString() {\n        return JSON.stringify(this.values);\n    }\n    static interpolate(from, to, t) {\n        const fromValues = from.values;\n        const toValues = to.values;\n        if (fromValues.length !== toValues.length) {\n            throw new RuntimeError(`Cannot interpolate values of different length. from: ${from.toString()}, to: ${to.toString()}`);\n        }\n        const output = [];\n        for (let i = 0; i < fromValues.length; i += 2) {\n            // Anchor entries must match\n            if (fromValues[i] !== toValues[i]) {\n                throw new RuntimeError(`Cannot interpolate values containing mismatched anchors. from[${i}]: ${fromValues[i]}, to[${i}]: ${toValues[i]}`);\n            }\n            output.push(fromValues[i]);\n            // Interpolate the offset values for each anchor\n            const [fx, fy] = fromValues[i + 1];\n            const [tx, ty] = toValues[i + 1];\n            output.push([interpolateNumber(fx, tx, t), interpolateNumber(fy, ty, t)]);\n        }\n        return new VariableAnchorOffsetCollection(output);\n    }\n}\n\nclass ResolvedImage {\n    constructor(options) {\n        this.name = options.name;\n        this.available = options.available;\n    }\n    toString() {\n        return this.name;\n    }\n    static fromString(name) {\n        if (!name)\n            return null; // treat empty values as no image\n        return new ResolvedImage({ name, available: false });\n    }\n}\n\nclass ProjectionDefinition {\n    constructor(from, to, transition) {\n        this.from = from;\n        this.to = to;\n        this.transition = transition;\n    }\n    static interpolate(from, to, t) {\n        return new ProjectionDefinition(from, to, t);\n    }\n    static parse(input) {\n        if (input instanceof ProjectionDefinition) {\n            return input;\n        }\n        if (Array.isArray(input) && input.length === 3 && typeof input[0] === 'string' && typeof input[1] === 'string' && typeof input[2] === 'number') {\n            return new ProjectionDefinition(input[0], input[1], input[2]);\n        }\n        if (typeof input === 'object' && typeof input.from === 'string' && typeof input.to === 'string' && typeof input.transition === 'number') {\n            return new ProjectionDefinition(input.from, input.to, input.transition);\n        }\n        if (typeof input === 'string') {\n            return new ProjectionDefinition(input, input, 1);\n        }\n        return undefined;\n    }\n}\n\nfunction validateRGBA(r, g, b, a) {\n    if (!(typeof r === 'number' && r >= 0 && r <= 255 &&\n        typeof g === 'number' && g >= 0 && g <= 255 &&\n        typeof b === 'number' && b >= 0 && b <= 255)) {\n        const value = typeof a === 'number' ? [r, g, b, a] : [r, g, b];\n        return `Invalid rgba value [${value.join(', ')}]: 'r', 'g', and 'b' must be between 0 and 255.`;\n    }\n    if (!(typeof a === 'undefined' || (typeof a === 'number' && a >= 0 && a <= 1))) {\n        return `Invalid rgba value [${[r, g, b, a].join(', ')}]: 'a' must be between 0 and 1.`;\n    }\n    return null;\n}\nfunction isValue(mixed) {\n    if (mixed === null ||\n        typeof mixed === 'string' ||\n        typeof mixed === 'boolean' ||\n        typeof mixed === 'number' ||\n        mixed instanceof ProjectionDefinition ||\n        mixed instanceof Color ||\n        mixed instanceof Collator ||\n        mixed instanceof Formatted ||\n        mixed instanceof Padding ||\n        mixed instanceof VariableAnchorOffsetCollection ||\n        mixed instanceof ResolvedImage) {\n        return true;\n    }\n    else if (Array.isArray(mixed)) {\n        for (const item of mixed) {\n            if (!isValue(item)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    else if (typeof mixed === 'object') {\n        for (const key in mixed) {\n            if (!isValue(mixed[key])) {\n                return false;\n            }\n        }\n        return true;\n    }\n    else {\n        return false;\n    }\n}\nfunction typeOf(value) {\n    if (value === null) {\n        return NullType;\n    }\n    else if (typeof value === 'string') {\n        return StringType;\n    }\n    else if (typeof value === 'boolean') {\n        return BooleanType;\n    }\n    else if (typeof value === 'number') {\n        return NumberType;\n    }\n    else if (value instanceof Color) {\n        return ColorType;\n    }\n    else if (value instanceof ProjectionDefinition) {\n        return ProjectionDefinitionType;\n    }\n    else if (value instanceof Collator) {\n        return CollatorType;\n    }\n    else if (value instanceof Formatted) {\n        return FormattedType;\n    }\n    else if (value instanceof Padding) {\n        return PaddingType;\n    }\n    else if (value instanceof VariableAnchorOffsetCollection) {\n        return VariableAnchorOffsetCollectionType;\n    }\n    else if (value instanceof ResolvedImage) {\n        return ResolvedImageType;\n    }\n    else if (Array.isArray(value)) {\n        const length = value.length;\n        let itemType;\n        for (const item of value) {\n            const t = typeOf(item);\n            if (!itemType) {\n                itemType = t;\n            }\n            else if (itemType === t) {\n                continue;\n            }\n            else {\n                itemType = ValueType;\n                break;\n            }\n        }\n        return array(itemType || ValueType, length);\n    }\n    else {\n        return ObjectType;\n    }\n}\nfunction valueToString(value) {\n    const type = typeof value;\n    if (value === null) {\n        return '';\n    }\n    else if (type === 'string' || type === 'number' || type === 'boolean') {\n        return String(value);\n    }\n    else if (value instanceof Color || value instanceof ProjectionDefinition || value instanceof Formatted || value instanceof Padding || value instanceof VariableAnchorOffsetCollection || value instanceof ResolvedImage) {\n        return value.toString();\n    }\n    else {\n        return JSON.stringify(value);\n    }\n}\n\nclass Literal {\n    constructor(type, value) {\n        this.type = type;\n        this.value = value;\n    }\n    static parse(args, context) {\n        if (args.length !== 2)\n            return context.error(`'literal' expression requires exactly one argument, but found ${args.length - 1} instead.`);\n        if (!isValue(args[1]))\n            return context.error('invalid value');\n        const value = args[1];\n        let type = typeOf(value);\n        // special case: infer the item type if possible for zero-length arrays\n        const expected = context.expectedType;\n        if (type.kind === 'array' &&\n            type.N === 0 &&\n            expected &&\n            expected.kind === 'array' &&\n            (typeof expected.N !== 'number' || expected.N === 0)) {\n            type = expected;\n        }\n        return new Literal(type, value);\n    }\n    evaluate() {\n        return this.value;\n    }\n    eachChild() { }\n    outputDefined() {\n        return true;\n    }\n}\n\nconst types$1 = {\n    string: StringType,\n    number: NumberType,\n    boolean: BooleanType,\n    object: ObjectType\n};\nclass Assertion {\n    constructor(type, args) {\n        this.type = type;\n        this.args = args;\n    }\n    static parse(args, context) {\n        if (args.length < 2)\n            return context.error('Expected at least one argument.');\n        let i = 1;\n        let type;\n        const name = args[0];\n        if (name === 'array') {\n            let itemType;\n            if (args.length > 2) {\n                const type = args[1];\n                if (typeof type !== 'string' || !(type in types$1) || type === 'object')\n                    return context.error('The item type argument of \"array\" must be one of string, number, boolean', 1);\n                itemType = types$1[type];\n                i++;\n            }\n            else {\n                itemType = ValueType;\n            }\n            let N;\n            if (args.length > 3) {\n                if (args[2] !== null &&\n                    (typeof args[2] !== 'number' ||\n                        args[2] < 0 ||\n                        args[2] !== Math.floor(args[2]))) {\n                    return context.error('The length argument to \"array\" must be a positive integer literal', 2);\n                }\n                N = args[2];\n                i++;\n            }\n            type = array(itemType, N);\n        }\n        else {\n            if (!types$1[name])\n                throw new Error(`Types doesn't contain name = ${name}`);\n            type = types$1[name];\n        }\n        const parsed = [];\n        for (; i < args.length; i++) {\n            const input = context.parse(args[i], i, ValueType);\n            if (!input)\n                return null;\n            parsed.push(input);\n        }\n        return new Assertion(type, parsed);\n    }\n    evaluate(ctx) {\n        for (let i = 0; i < this.args.length; i++) {\n            const value = this.args[i].evaluate(ctx);\n            const error = checkSubtype(this.type, typeOf(value));\n            if (!error) {\n                return value;\n            }\n            else if (i === this.args.length - 1) {\n                throw new RuntimeError(`Expected value to be of type ${typeToString(this.type)}, but found ${typeToString(typeOf(value))} instead.`);\n            }\n        }\n        throw new Error();\n    }\n    eachChild(fn) {\n        this.args.forEach(fn);\n    }\n    outputDefined() {\n        return this.args.every(arg => arg.outputDefined());\n    }\n}\n\nconst types = {\n    'to-boolean': BooleanType,\n    'to-color': ColorType,\n    'to-number': NumberType,\n    'to-string': StringType\n};\n/**\n * Special form for error-coalescing coercion expressions \"to-number\",\n * \"to-color\".  Since these coercions can fail at runtime, they accept multiple\n * arguments, only evaluating one at a time until one succeeds.\n *\n * @private\n */\nclass Coercion {\n    constructor(type, args) {\n        this.type = type;\n        this.args = args;\n    }\n    static parse(args, context) {\n        if (args.length < 2)\n            return context.error('Expected at least one argument.');\n        const name = args[0];\n        if (!types[name])\n            throw new Error(`Can't parse ${name} as it is not part of the known types`);\n        if ((name === 'to-boolean' || name === 'to-string') && args.length !== 2)\n            return context.error('Expected one argument.');\n        const type = types[name];\n        const parsed = [];\n        for (let i = 1; i < args.length; i++) {\n            const input = context.parse(args[i], i, ValueType);\n            if (!input)\n                return null;\n            parsed.push(input);\n        }\n        return new Coercion(type, parsed);\n    }\n    evaluate(ctx) {\n        switch (this.type.kind) {\n            case 'boolean':\n                return Boolean(this.args[0].evaluate(ctx));\n            case 'color': {\n                let input;\n                let error;\n                for (const arg of this.args) {\n                    input = arg.evaluate(ctx);\n                    error = null;\n                    if (input instanceof Color) {\n                        return input;\n                    }\n                    else if (typeof input === 'string') {\n                        const c = ctx.parseColor(input);\n                        if (c)\n                            return c;\n                    }\n                    else if (Array.isArray(input)) {\n                        if (input.length < 3 || input.length > 4) {\n                            error = `Invalid rgba value ${JSON.stringify(input)}: expected an array containing either three or four numeric values.`;\n                        }\n                        else {\n                            error = validateRGBA(input[0], input[1], input[2], input[3]);\n                        }\n                        if (!error) {\n                            return new Color(input[0] / 255, input[1] / 255, input[2] / 255, input[3]);\n                        }\n                    }\n                }\n                throw new RuntimeError(error || `Could not parse color from value '${typeof input === 'string' ? input : JSON.stringify(input)}'`);\n            }\n            case 'padding': {\n                let input;\n                for (const arg of this.args) {\n                    input = arg.evaluate(ctx);\n                    const pad = Padding.parse(input);\n                    if (pad) {\n                        return pad;\n                    }\n                }\n                throw new RuntimeError(`Could not parse padding from value '${typeof input === 'string' ? input : JSON.stringify(input)}'`);\n            }\n            case 'variableAnchorOffsetCollection': {\n                let input;\n                for (const arg of this.args) {\n                    input = arg.evaluate(ctx);\n                    const coll = VariableAnchorOffsetCollection.parse(input);\n                    if (coll) {\n                        return coll;\n                    }\n                }\n                throw new RuntimeError(`Could not parse variableAnchorOffsetCollection from value '${typeof input === 'string' ? input : JSON.stringify(input)}'`);\n            }\n            case 'number': {\n                let value = null;\n                for (const arg of this.args) {\n                    value = arg.evaluate(ctx);\n                    if (value === null)\n                        return 0;\n                    const num = Number(value);\n                    if (isNaN(num))\n                        continue;\n                    return num;\n                }\n                throw new RuntimeError(`Could not convert ${JSON.stringify(value)} to number.`);\n            }\n            case 'formatted':\n                // There is no explicit 'to-formatted' but this coercion can be implicitly\n                // created by properties that expect the 'formatted' type.\n                return Formatted.fromString(valueToString(this.args[0].evaluate(ctx)));\n            case 'resolvedImage':\n                return ResolvedImage.fromString(valueToString(this.args[0].evaluate(ctx)));\n            case 'projectionDefinition':\n                return this.args[0].evaluate(ctx);\n            default:\n                return valueToString(this.args[0].evaluate(ctx));\n        }\n    }\n    eachChild(fn) {\n        this.args.forEach(fn);\n    }\n    outputDefined() {\n        return this.args.every(arg => arg.outputDefined());\n    }\n}\n\n/**\n * Rearranges items so that all items in the [left, k] are the smallest.\n * The k-th element will have the (k - left + 1)-th smallest value in [left, right].\n *\n * @template T\n * @param {T[]} arr the array to partially sort (in place)\n * @param {number} k middle index for partial sorting (as defined above)\n * @param {number} [left=0] left index of the range to sort\n * @param {number} [right=arr.length-1] right index\n * @param {(a: T, b: T) => number} [compare = (a, b) => a - b] compare function\n */\nfunction quickselect(arr, k, left = 0, right = arr.length - 1, compare = defaultCompare) {\n\n    while (right > left) {\n        if (right - left > 600) {\n            const n = right - left + 1;\n            const m = k - left + 1;\n            const z = Math.log(n);\n            const s = 0.5 * Math.exp(2 * z / 3);\n            const sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);\n            const newLeft = Math.max(left, Math.floor(k - m * s / n + sd));\n            const newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));\n            quickselect(arr, k, newLeft, newRight, compare);\n        }\n\n        const t = arr[k];\n        let i = left;\n        /** @type {number} */\n        let j = right;\n\n        swap(arr, left, k);\n        if (compare(arr[right], t) > 0) swap(arr, left, right);\n\n        while (i < j) {\n            swap(arr, i, j);\n            i++;\n            j--;\n            while (compare(arr[i], t) < 0) i++;\n            while (compare(arr[j], t) > 0) j--;\n        }\n\n        if (compare(arr[left], t) === 0) swap(arr, left, j);\n        else {\n            j++;\n            swap(arr, j, right);\n        }\n\n        if (j <= k) left = j + 1;\n        if (k <= j) right = j - 1;\n    }\n}\n\n/**\n * @template T\n * @param {T[]} arr\n * @param {number} i\n * @param {number} j\n */\nfunction swap(arr, i, j) {\n    const tmp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = tmp;\n}\n\n/**\n * @template T\n * @param {T} a\n * @param {T} b\n * @returns {number}\n */\nfunction defaultCompare(a, b) {\n    return a < b ? -1 : a > b ? 1 : 0;\n}\n\n/**\n * Classifies an array of rings into polygons with outer rings and holes\n * @param rings - the rings to classify\n * @param maxRings - the maximum number of rings to include in a polygon, use 0 to include all rings\n * @returns an array of polygons with internal rings as holes\n */\nfunction classifyRings(rings, maxRings) {\n    const len = rings.length;\n    if (len <= 1)\n        return [rings];\n    const polygons = [];\n    let polygon;\n    let ccw;\n    for (const ring of rings) {\n        const area = calculateSignedArea(ring);\n        if (area === 0)\n            continue;\n        ring.area = Math.abs(area);\n        if (ccw === undefined)\n            ccw = area < 0;\n        if (ccw === area < 0) {\n            if (polygon)\n                polygons.push(polygon);\n            polygon = [ring];\n        }\n        else {\n            polygon.push(ring);\n        }\n    }\n    if (polygon)\n        polygons.push(polygon);\n    // Earcut performance degrades with the # of rings in a polygon. For this\n    // reason, we limit strip out all but the `maxRings` largest rings.\n    if (maxRings > 1) {\n        for (let j = 0; j < polygons.length; j++) {\n            if (polygons[j].length <= maxRings)\n                continue;\n            quickselect(polygons[j], maxRings, 1, polygons[j].length - 1, compareAreas);\n            polygons[j] = polygons[j].slice(0, maxRings);\n        }\n    }\n    return polygons;\n}\nfunction compareAreas(a, b) {\n    return b.area - a.area;\n}\n/**\n * Returns the signed area for the polygon ring.  Positive areas are exterior rings and\n * have a clockwise winding.  Negative areas are interior rings and have a counter clockwise\n * ordering.\n *\n * @param ring - Exterior or interior ring\n * @returns Signed area\n */\nfunction calculateSignedArea(ring) {\n    let sum = 0;\n    for (let i = 0, len = ring.length, j = len - 1, p1, p2; i < len; j = i++) {\n        p1 = ring[i];\n        p2 = ring[j];\n        sum += (p2.x - p1.x) * (p1.y + p2.y);\n    }\n    return sum;\n}\n/**\n * Returns if there are multiple outer rings.\n * The first ring is an outer ring. Its direction, cw or ccw, defines the direction of outer rings.\n *\n * @param rings - List of rings\n * @returns Are there multiple outer rings\n */\nfunction hasMultipleOuterRings(rings) {\n    // Following https://github.com/mapbox/vector-tile-js/blob/77851380b63b07fd0af3d5a3f144cc86fb39fdd1/lib/vectortilefeature.js#L197\n    const len = rings.length;\n    for (let i = 0, direction; i < len; i++) {\n        const area = calculateSignedArea(rings[i]);\n        if (area === 0)\n            continue;\n        if (direction === undefined) {\n            // Keep the direction of the first ring\n            direction = area < 0;\n        }\n        else if (direction === area < 0) {\n            // Same direction as the first ring -> a second outer ring\n            return true;\n        }\n    }\n    return false;\n}\n\nconst geometryTypes = ['Unknown', 'Point', 'LineString', 'Polygon'];\nconst simpleGeometryType = {\n    'Unknown': 'Unknown',\n    'Point': 'Point',\n    'MultiPoint': 'Point',\n    'LineString': 'LineString',\n    'MultiLineString': 'LineString',\n    'Polygon': 'Polygon',\n    'MultiPolygon': 'Polygon'\n};\nclass EvaluationContext {\n    constructor() {\n        this.globals = null;\n        this.feature = null;\n        this.featureState = null;\n        this.formattedSection = null;\n        this._parseColorCache = {};\n        this.availableImages = null;\n        this.canonical = null;\n    }\n    id() {\n        return this.feature && 'id' in this.feature ? this.feature.id : null;\n    }\n    geometryDollarType() {\n        return this.feature ?\n            typeof this.feature.type === 'number' ? geometryTypes[this.feature.type] : simpleGeometryType[this.feature.type] :\n            null;\n    }\n    geometryType() {\n        let geometryType = this.feature.type;\n        if (typeof geometryType !== 'number') {\n            return geometryType;\n        }\n        geometryType = geometryTypes[this.feature.type];\n        if (geometryType === 'Unknown') {\n            return geometryType;\n        }\n        const geom = this.geometry();\n        const len = geom.length;\n        if (len === 1) {\n            return geometryType;\n        }\n        if (geometryType !== 'Polygon') {\n            return `Multi${geometryType}`;\n        }\n        if (hasMultipleOuterRings(geom)) {\n            return 'MultiPolygon';\n        }\n        return 'Polygon';\n    }\n    geometry() {\n        return this.feature && 'geometry' in this.feature ? this.feature.geometry : null;\n    }\n    canonicalID() {\n        return this.canonical;\n    }\n    properties() {\n        return this.feature && this.feature.properties || {};\n    }\n    parseColor(input) {\n        let cached = this._parseColorCache[input];\n        if (!cached) {\n            cached = this._parseColorCache[input] = Color.parse(input);\n        }\n        return cached;\n    }\n}\n\n/**\n * State associated parsing at a given point in an expression tree.\n * @private\n */\nclass ParsingContext {\n    constructor(registry, isConstantFunc, path = [], expectedType, scope = new Scope(), errors = []) {\n        this.registry = registry;\n        this.path = path;\n        this.key = path.map(part => `[${part}]`).join('');\n        this.scope = scope;\n        this.errors = errors;\n        this.expectedType = expectedType;\n        this._isConstant = isConstantFunc;\n    }\n    /**\n     * @param expr the JSON expression to parse\n     * @param index the optional argument index if this expression is an argument of a parent expression that's being parsed\n     * @param options\n     * @param options.omitTypeAnnotations set true to omit inferred type annotations.  Caller beware: with this option set, the parsed expression's type will NOT satisfy `expectedType` if it would normally be wrapped in an inferred annotation.\n     * @private\n     */\n    parse(expr, index, expectedType, bindings, options = {}) {\n        if (index) {\n            return this.concat(index, expectedType, bindings)._parse(expr, options);\n        }\n        return this._parse(expr, options);\n    }\n    _parse(expr, options) {\n        if (expr === null || typeof expr === 'string' || typeof expr === 'boolean' || typeof expr === 'number') {\n            expr = ['literal', expr];\n        }\n        function annotate(parsed, type, typeAnnotation) {\n            if (typeAnnotation === 'assert') {\n                return new Assertion(type, [parsed]);\n            }\n            else if (typeAnnotation === 'coerce') {\n                return new Coercion(type, [parsed]);\n            }\n            else {\n                return parsed;\n            }\n        }\n        if (Array.isArray(expr)) {\n            if (expr.length === 0) {\n                return this.error('Expected an array with at least one element. If you wanted a literal array, use [\"literal\", []].');\n            }\n            const op = expr[0];\n            if (typeof op !== 'string') {\n                this.error(`Expression name must be a string, but found ${typeof op} instead. If you wanted a literal array, use [\"literal\", [...]].`, 0);\n                return null;\n            }\n            const Expr = this.registry[op];\n            if (Expr) {\n                let parsed = Expr.parse(expr, this);\n                if (!parsed)\n                    return null;\n                if (this.expectedType) {\n                    const expected = this.expectedType;\n                    const actual = parsed.type;\n                    // When we expect a number, string, boolean, or array but have a value, wrap it in an assertion.\n                    // When we expect a color or formatted string, but have a string or value, wrap it in a coercion.\n                    // Otherwise, we do static type-checking.\n                    //\n                    // These behaviors are overridable for:\n                    //   * The \"coalesce\" operator, which needs to omit type annotations.\n                    //   * String-valued properties (e.g. `text-field`), where coercion is more convenient than assertion.\n                    //\n                    if ((expected.kind === 'string' || expected.kind === 'number' || expected.kind === 'boolean' || expected.kind === 'object' || expected.kind === 'array') && actual.kind === 'value') {\n                        parsed = annotate(parsed, expected, options.typeAnnotation || 'assert');\n                    }\n                    else if ((expected.kind === 'projectionDefinition') && (actual.kind === 'string' || actual.kind === 'array')) {\n                        parsed = annotate(parsed, expected, options.typeAnnotation || 'coerce');\n                    }\n                    else if ((expected.kind === 'color' || expected.kind === 'formatted' || expected.kind === 'resolvedImage') && (actual.kind === 'value' || actual.kind === 'string')) {\n                        parsed = annotate(parsed, expected, options.typeAnnotation || 'coerce');\n                    }\n                    else if (expected.kind === 'padding' && (actual.kind === 'value' || actual.kind === 'number' || actual.kind === 'array')) {\n                        parsed = annotate(parsed, expected, options.typeAnnotation || 'coerce');\n                    }\n                    else if (expected.kind === 'variableAnchorOffsetCollection' && (actual.kind === 'value' || actual.kind === 'array')) {\n                        parsed = annotate(parsed, expected, options.typeAnnotation || 'coerce');\n                    }\n                    else if (this.checkSubtype(expected, actual)) {\n                        return null;\n                    }\n                }\n                // If an expression's arguments are all literals, we can evaluate\n                // it immediately and replace it with a literal value in the\n                // parsed/compiled result. Expressions that expect an image should\n                // not be resolved here so we can later get the available images.\n                if (!(parsed instanceof Literal) && (parsed.type.kind !== 'resolvedImage') && this._isConstant(parsed)) {\n                    const ec = new EvaluationContext();\n                    try {\n                        parsed = new Literal(parsed.type, parsed.evaluate(ec));\n                    }\n                    catch (e) {\n                        this.error(e.message);\n                        return null;\n                    }\n                }\n                return parsed;\n            }\n            return this.error(`Unknown expression \"${op}\". If you wanted a literal array, use [\"literal\", [...]].`, 0);\n        }\n        else if (typeof expr === 'undefined') {\n            return this.error('\\'undefined\\' value invalid. Use null instead.');\n        }\n        else if (typeof expr === 'object') {\n            return this.error('Bare objects invalid. Use [\"literal\", {...}] instead.');\n        }\n        else {\n            return this.error(`Expected an array, but found ${typeof expr} instead.`);\n        }\n    }\n    /**\n     * Returns a copy of this context suitable for parsing the subexpression at\n     * index `index`, optionally appending to 'let' binding map.\n     *\n     * Note that `errors` property, intended for collecting errors while\n     * parsing, is copied by reference rather than cloned.\n     * @private\n     */\n    concat(index, expectedType, bindings) {\n        const path = typeof index === 'number' ? this.path.concat(index) : this.path;\n        const scope = bindings ? this.scope.concat(bindings) : this.scope;\n        return new ParsingContext(this.registry, this._isConstant, path, expectedType || null, scope, this.errors);\n    }\n    /**\n     * Push a parsing (or type checking) error into the `this.errors`\n     * @param error The message\n     * @param keys Optionally specify the source of the error at a child\n     * of the current expression at `this.key`.\n     * @private\n     */\n    error(error, ...keys) {\n        const key = `${this.key}${keys.map(k => `[${k}]`).join('')}`;\n        this.errors.push(new ExpressionParsingError(key, error));\n    }\n    /**\n     * Returns null if `t` is a subtype of `expected`; otherwise returns an\n     * error message and also pushes it to `this.errors`.\n     * @param expected The expected type\n     * @param t The actual type\n     * @returns null if `t` is a subtype of `expected`; otherwise returns an error message\n     */\n    checkSubtype(expected, t) {\n        const error = checkSubtype(expected, t);\n        if (error)\n            this.error(error);\n        return error;\n    }\n}\n\nclass Let {\n    constructor(bindings, result) {\n        this.type = result.type;\n        this.bindings = [].concat(bindings);\n        this.result = result;\n    }\n    evaluate(ctx) {\n        return this.result.evaluate(ctx);\n    }\n    eachChild(fn) {\n        for (const binding of this.bindings) {\n            fn(binding[1]);\n        }\n        fn(this.result);\n    }\n    static parse(args, context) {\n        if (args.length < 4)\n            return context.error(`Expected at least 3 arguments, but found ${args.length - 1} instead.`);\n        const bindings = [];\n        for (let i = 1; i < args.length - 1; i += 2) {\n            const name = args[i];\n            if (typeof name !== 'string') {\n                return context.error(`Expected string, but found ${typeof name} instead.`, i);\n            }\n            if (/[^a-zA-Z0-9_]/.test(name)) {\n                return context.error('Variable names must contain only alphanumeric characters or \\'_\\'.', i);\n            }\n            const value = context.parse(args[i + 1], i + 1);\n            if (!value)\n                return null;\n            bindings.push([name, value]);\n        }\n        const result = context.parse(args[args.length - 1], args.length - 1, context.expectedType, bindings);\n        if (!result)\n            return null;\n        return new Let(bindings, result);\n    }\n    outputDefined() {\n        return this.result.outputDefined();\n    }\n}\n\nclass Var {\n    constructor(name, boundExpression) {\n        this.type = boundExpression.type;\n        this.name = name;\n        this.boundExpression = boundExpression;\n    }\n    static parse(args, context) {\n        if (args.length !== 2 || typeof args[1] !== 'string')\n            return context.error('\\'var\\' expression requires exactly one string literal argument.');\n        const name = args[1];\n        if (!context.scope.has(name)) {\n            return context.error(`Unknown variable \"${name}\". Make sure \"${name}\" has been bound in an enclosing \"let\" expression before using it.`, 1);\n        }\n        return new Var(name, context.scope.get(name));\n    }\n    evaluate(ctx) {\n        return this.boundExpression.evaluate(ctx);\n    }\n    eachChild() { }\n    outputDefined() {\n        return false;\n    }\n}\n\nclass At {\n    constructor(type, index, input) {\n        this.type = type;\n        this.index = index;\n        this.input = input;\n    }\n    static parse(args, context) {\n        if (args.length !== 3)\n            return context.error(`Expected 2 arguments, but found ${args.length - 1} instead.`);\n        const index = context.parse(args[1], 1, NumberType);\n        const input = context.parse(args[2], 2, array(context.expectedType || ValueType));\n        if (!index || !input)\n            return null;\n        const t = input.type;\n        return new At(t.itemType, index, input);\n    }\n    evaluate(ctx) {\n        const index = this.index.evaluate(ctx);\n        const array = this.input.evaluate(ctx);\n        if (index < 0) {\n            throw new RuntimeError(`Array index out of bounds: ${index} < 0.`);\n        }\n        if (index >= array.length) {\n            throw new RuntimeError(`Array index out of bounds: ${index} > ${array.length - 1}.`);\n        }\n        if (index !== Math.floor(index)) {\n            throw new RuntimeError(`Array index must be an integer, but found ${index} instead.`);\n        }\n        return array[index];\n    }\n    eachChild(fn) {\n        fn(this.index);\n        fn(this.input);\n    }\n    outputDefined() {\n        return false;\n    }\n}\n\nclass In {\n    constructor(needle, haystack) {\n        this.type = BooleanType;\n        this.needle = needle;\n        this.haystack = haystack;\n    }\n    static parse(args, context) {\n        if (args.length !== 3) {\n            return context.error(`Expected 2 arguments, but found ${args.length - 1} instead.`);\n        }\n        const needle = context.parse(args[1], 1, ValueType);\n        const haystack = context.parse(args[2], 2, ValueType);\n        if (!needle || !haystack)\n            return null;\n        if (!isValidType(needle.type, [BooleanType, StringType, NumberType, NullType, ValueType])) {\n            return context.error(`Expected first argument to be of type boolean, string, number or null, but found ${typeToString(needle.type)} instead`);\n        }\n        return new In(needle, haystack);\n    }\n    evaluate(ctx) {\n        const needle = this.needle.evaluate(ctx);\n        const haystack = this.haystack.evaluate(ctx);\n        if (!haystack)\n            return false;\n        if (!isValidNativeType(needle, ['boolean', 'string', 'number', 'null'])) {\n            throw new RuntimeError(`Expected first argument to be of type boolean, string, number or null, but found ${typeToString(typeOf(needle))} instead.`);\n        }\n        if (!isValidNativeType(haystack, ['string', 'array'])) {\n            throw new RuntimeError(`Expected second argument to be of type array or string, but found ${typeToString(typeOf(haystack))} instead.`);\n        }\n        return haystack.indexOf(needle) >= 0;\n    }\n    eachChild(fn) {\n        fn(this.needle);\n        fn(this.haystack);\n    }\n    outputDefined() {\n        return true;\n    }\n}\n\nclass IndexOf {\n    constructor(needle, haystack, fromIndex) {\n        this.type = NumberType;\n        this.needle = needle;\n        this.haystack = haystack;\n        this.fromIndex = fromIndex;\n    }\n    static parse(args, context) {\n        if (args.length <= 2 || args.length >= 5) {\n            return context.error(`Expected 3 or 4 arguments, but found ${args.length - 1} instead.`);\n        }\n        const needle = context.parse(args[1], 1, ValueType);\n        const haystack = context.parse(args[2], 2, ValueType);\n        if (!needle || !haystack)\n            return null;\n        if (!isValidType(needle.type, [BooleanType, StringType, NumberType, NullType, ValueType])) {\n            return context.error(`Expected first argument to be of type boolean, string, number or null, but found ${typeToString(needle.type)} instead`);\n        }\n        if (args.length === 4) {\n            const fromIndex = context.parse(args[3], 3, NumberType);\n            if (!fromIndex)\n                return null;\n            return new IndexOf(needle, haystack, fromIndex);\n        }\n        else {\n            return new IndexOf(needle, haystack);\n        }\n    }\n    evaluate(ctx) {\n        const needle = this.needle.evaluate(ctx);\n        const haystack = this.haystack.evaluate(ctx);\n        if (!isValidNativeType(needle, ['boolean', 'string', 'number', 'null'])) {\n            throw new RuntimeError(`Expected first argument to be of type boolean, string, number or null, but found ${typeToString(typeOf(needle))} instead.`);\n        }\n        let fromIndex;\n        if (this.fromIndex) {\n            fromIndex = this.fromIndex.evaluate(ctx);\n        }\n        if (isValidNativeType(haystack, ['string'])) {\n            const rawIndex = haystack.indexOf(needle, fromIndex);\n            if (rawIndex === -1) {\n                return -1;\n            }\n            else {\n                // The index may be affected by surrogate pairs, so get the length of the preceding substring.\n                return [...haystack.slice(0, rawIndex)].length;\n            }\n        }\n        else if (isValidNativeType(haystack, ['array'])) {\n            return haystack.indexOf(needle, fromIndex);\n        }\n        else {\n            throw new RuntimeError(`Expected second argument to be of type array or string, but found ${typeToString(typeOf(haystack))} instead.`);\n        }\n    }\n    eachChild(fn) {\n        fn(this.needle);\n        fn(this.haystack);\n        if (this.fromIndex) {\n            fn(this.fromIndex);\n        }\n    }\n    outputDefined() {\n        return false;\n    }\n}\n\nclass Match {\n    constructor(inputType, outputType, input, cases, outputs, otherwise) {\n        this.inputType = inputType;\n        this.type = outputType;\n        this.input = input;\n        this.cases = cases;\n        this.outputs = outputs;\n        this.otherwise = otherwise;\n    }\n    static parse(args, context) {\n        if (args.length < 5)\n            return context.error(`Expected at least 4 arguments, but found only ${args.length - 1}.`);\n        if (args.length % 2 !== 1)\n            return context.error('Expected an even number of arguments.');\n        let inputType;\n        let outputType;\n        if (context.expectedType && context.expectedType.kind !== 'value') {\n            outputType = context.expectedType;\n        }\n        const cases = {};\n        const outputs = [];\n        for (let i = 2; i < args.length - 1; i += 2) {\n            let labels = args[i];\n            const value = args[i + 1];\n            if (!Array.isArray(labels)) {\n                labels = [labels];\n            }\n            const labelContext = context.concat(i);\n            if (labels.length === 0) {\n                return labelContext.error('Expected at least one branch label.');\n            }\n            for (const label of labels) {\n                if (typeof label !== 'number' && typeof label !== 'string') {\n                    return labelContext.error('Branch labels must be numbers or strings.');\n                }\n                else if (typeof label === 'number' && Math.abs(label) > Number.MAX_SAFE_INTEGER) {\n                    return labelContext.error(`Branch labels must be integers no larger than ${Number.MAX_SAFE_INTEGER}.`);\n                }\n                else if (typeof label === 'number' && Math.floor(label) !== label) {\n                    return labelContext.error('Numeric branch labels must be integer values.');\n                }\n                else if (!inputType) {\n                    inputType = typeOf(label);\n                }\n                else if (labelContext.checkSubtype(inputType, typeOf(label))) {\n                    return null;\n                }\n                if (typeof cases[String(label)] !== 'undefined') {\n                    return labelContext.error('Branch labels must be unique.');\n                }\n                cases[String(label)] = outputs.length;\n            }\n            const result = context.parse(value, i, outputType);\n            if (!result)\n                return null;\n            outputType = outputType || result.type;\n            outputs.push(result);\n        }\n        const input = context.parse(args[1], 1, ValueType);\n        if (!input)\n            return null;\n        const otherwise = context.parse(args[args.length - 1], args.length - 1, outputType);\n        if (!otherwise)\n            return null;\n        if (input.type.kind !== 'value' && context.concat(1).checkSubtype(inputType, input.type)) {\n            return null;\n        }\n        return new Match(inputType, outputType, input, cases, outputs, otherwise);\n    }\n    evaluate(ctx) {\n        const input = this.input.evaluate(ctx);\n        const output = (typeOf(input) === this.inputType && this.outputs[this.cases[input]]) || this.otherwise;\n        return output.evaluate(ctx);\n    }\n    eachChild(fn) {\n        fn(this.input);\n        this.outputs.forEach(fn);\n        fn(this.otherwise);\n    }\n    outputDefined() {\n        return this.outputs.every(out => out.outputDefined()) && this.otherwise.outputDefined();\n    }\n}\n\nclass Case {\n    constructor(type, branches, otherwise) {\n        this.type = type;\n        this.branches = branches;\n        this.otherwise = otherwise;\n    }\n    static parse(args, context) {\n        if (args.length < 4)\n            return context.error(`Expected at least 3 arguments, but found only ${args.length - 1}.`);\n        if (args.length % 2 !== 0)\n            return context.error('Expected an odd number of arguments.');\n        let outputType;\n        if (context.expectedType && context.expectedType.kind !== 'value') {\n            outputType = context.expectedType;\n        }\n        const branches = [];\n        for (let i = 1; i < args.length - 1; i += 2) {\n            const test = context.parse(args[i], i, BooleanType);\n            if (!test)\n                return null;\n            const result = context.parse(args[i + 1], i + 1, outputType);\n            if (!result)\n                return null;\n            branches.push([test, result]);\n            outputType = outputType || result.type;\n        }\n        const otherwise = context.parse(args[args.length - 1], args.length - 1, outputType);\n        if (!otherwise)\n            return null;\n        if (!outputType)\n            throw new Error('Can\\'t infer output type');\n        return new Case(outputType, branches, otherwise);\n    }\n    evaluate(ctx) {\n        for (const [test, expression] of this.branches) {\n            if (test.evaluate(ctx)) {\n                return expression.evaluate(ctx);\n            }\n        }\n        return this.otherwise.evaluate(ctx);\n    }\n    eachChild(fn) {\n        for (const [test, expression] of this.branches) {\n            fn(test);\n            fn(expression);\n        }\n        fn(this.otherwise);\n    }\n    outputDefined() {\n        return this.branches.every(([_, out]) => out.outputDefined()) && this.otherwise.outputDefined();\n    }\n}\n\nclass Slice {\n    constructor(type, input, beginIndex, endIndex) {\n        this.type = type;\n        this.input = input;\n        this.beginIndex = beginIndex;\n        this.endIndex = endIndex;\n    }\n    static parse(args, context) {\n        if (args.length <= 2 || args.length >= 5) {\n            return context.error(`Expected 3 or 4 arguments, but found ${args.length - 1} instead.`);\n        }\n        const input = context.parse(args[1], 1, ValueType);\n        const beginIndex = context.parse(args[2], 2, NumberType);\n        if (!input || !beginIndex)\n            return null;\n        if (!isValidType(input.type, [array(ValueType), StringType, ValueType])) {\n            return context.error(`Expected first argument to be of type array or string, but found ${typeToString(input.type)} instead`);\n        }\n        if (args.length === 4) {\n            const endIndex = context.parse(args[3], 3, NumberType);\n            if (!endIndex)\n                return null;\n            return new Slice(input.type, input, beginIndex, endIndex);\n        }\n        else {\n            return new Slice(input.type, input, beginIndex);\n        }\n    }\n    evaluate(ctx) {\n        const input = this.input.evaluate(ctx);\n        const beginIndex = this.beginIndex.evaluate(ctx);\n        let endIndex;\n        if (this.endIndex) {\n            endIndex = this.endIndex.evaluate(ctx);\n        }\n        if (isValidNativeType(input, ['string'])) {\n            // Indices may be affected by surrogate pairs.\n            return [...input].slice(beginIndex, endIndex).join('');\n        }\n        else if (isValidNativeType(input, ['array'])) {\n            return input.slice(beginIndex, endIndex);\n        }\n        else {\n            throw new RuntimeError(`Expected first argument to be of type array or string, but found ${typeToString(typeOf(input))} instead.`);\n        }\n    }\n    eachChild(fn) {\n        fn(this.input);\n        fn(this.beginIndex);\n        if (this.endIndex) {\n            fn(this.endIndex);\n        }\n    }\n    outputDefined() {\n        return false;\n    }\n}\n\n/**\n * Returns the index of the last stop <= input, or 0 if it doesn't exist.\n * @private\n */\nfunction findStopLessThanOrEqualTo(stops, input) {\n    const lastIndex = stops.length - 1;\n    let lowerIndex = 0;\n    let upperIndex = lastIndex;\n    let currentIndex = 0;\n    let currentValue, nextValue;\n    while (lowerIndex <= upperIndex) {\n        currentIndex = Math.floor((lowerIndex + upperIndex) / 2);\n        currentValue = stops[currentIndex];\n        nextValue = stops[currentIndex + 1];\n        if (currentValue <= input) {\n            if (currentIndex === lastIndex || input < nextValue) { // Search complete\n                return currentIndex;\n            }\n            lowerIndex = currentIndex + 1;\n        }\n        else if (currentValue > input) {\n            upperIndex = currentIndex - 1;\n        }\n        else {\n            throw new RuntimeError('Input is not a number.');\n        }\n    }\n    return 0;\n}\n\nclass Step {\n    constructor(type, input, stops) {\n        this.type = type;\n        this.input = input;\n        this.labels = [];\n        this.outputs = [];\n        for (const [label, expression] of stops) {\n            this.labels.push(label);\n            this.outputs.push(expression);\n        }\n    }\n    static parse(args, context) {\n        if (args.length - 1 < 4) {\n            return context.error(`Expected at least 4 arguments, but found only ${args.length - 1}.`);\n        }\n        if ((args.length - 1) % 2 !== 0) {\n            return context.error('Expected an even number of arguments.');\n        }\n        const input = context.parse(args[1], 1, NumberType);\n        if (!input)\n            return null;\n        const stops = [];\n        let outputType = null;\n        if (context.expectedType && context.expectedType.kind !== 'value') {\n            outputType = context.expectedType;\n        }\n        for (let i = 1; i < args.length; i += 2) {\n            const label = i === 1 ? -Infinity : args[i];\n            const value = args[i + 1];\n            const labelKey = i;\n            const valueKey = i + 1;\n            if (typeof label !== 'number') {\n                return context.error('Input/output pairs for \"step\" expressions must be defined using literal numeric values (not computed expressions) for the input values.', labelKey);\n            }\n            if (stops.length && stops[stops.length - 1][0] >= label) {\n                return context.error('Input/output pairs for \"step\" expressions must be arranged with input values in strictly ascending order.', labelKey);\n            }\n            const parsed = context.parse(value, valueKey, outputType);\n            if (!parsed)\n                return null;\n            outputType = outputType || parsed.type;\n            stops.push([label, parsed]);\n        }\n        return new Step(outputType, input, stops);\n    }\n    evaluate(ctx) {\n        const labels = this.labels;\n        const outputs = this.outputs;\n        if (labels.length === 1) {\n            return outputs[0].evaluate(ctx);\n        }\n        const value = this.input.evaluate(ctx);\n        if (value <= labels[0]) {\n            return outputs[0].evaluate(ctx);\n        }\n        const stopCount = labels.length;\n        if (value >= labels[stopCount - 1]) {\n            return outputs[stopCount - 1].evaluate(ctx);\n        }\n        const index = findStopLessThanOrEqualTo(labels, value);\n        return outputs[index].evaluate(ctx);\n    }\n    eachChild(fn) {\n        fn(this.input);\n        for (const expression of this.outputs) {\n            fn(expression);\n        }\n    }\n    outputDefined() {\n        return this.outputs.every(out => out.outputDefined());\n    }\n}\n\nfunction getDefaultExportFromCjs (x) {\n\treturn x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;\n}\n\nvar unitbezier;\nvar hasRequiredUnitbezier;\n\nfunction requireUnitbezier () {\n\tif (hasRequiredUnitbezier) return unitbezier;\n\thasRequiredUnitbezier = 1;\n\n\tunitbezier = UnitBezier;\n\n\tfunction UnitBezier(p1x, p1y, p2x, p2y) {\n\t    // Calculate the polynomial coefficients, implicit first and last control points are (0,0) and (1,1).\n\t    this.cx = 3.0 * p1x;\n\t    this.bx = 3.0 * (p2x - p1x) - this.cx;\n\t    this.ax = 1.0 - this.cx - this.bx;\n\n\t    this.cy = 3.0 * p1y;\n\t    this.by = 3.0 * (p2y - p1y) - this.cy;\n\t    this.ay = 1.0 - this.cy - this.by;\n\n\t    this.p1x = p1x;\n\t    this.p1y = p1y;\n\t    this.p2x = p2x;\n\t    this.p2y = p2y;\n\t}\n\n\tUnitBezier.prototype = {\n\t    sampleCurveX: function (t) {\n\t        // `ax t^3 + bx t^2 + cx t' expanded using Horner's rule.\n\t        return ((this.ax * t + this.bx) * t + this.cx) * t;\n\t    },\n\n\t    sampleCurveY: function (t) {\n\t        return ((this.ay * t + this.by) * t + this.cy) * t;\n\t    },\n\n\t    sampleCurveDerivativeX: function (t) {\n\t        return (3.0 * this.ax * t + 2.0 * this.bx) * t + this.cx;\n\t    },\n\n\t    solveCurveX: function (x, epsilon) {\n\t        if (epsilon === undefined) epsilon = 1e-6;\n\n\t        if (x < 0.0) return 0.0;\n\t        if (x > 1.0) return 1.0;\n\n\t        var t = x;\n\n\t        // First try a few iterations of Newton's method - normally very fast.\n\t        for (var i = 0; i < 8; i++) {\n\t            var x2 = this.sampleCurveX(t) - x;\n\t            if (Math.abs(x2) < epsilon) return t;\n\n\t            var d2 = this.sampleCurveDerivativeX(t);\n\t            if (Math.abs(d2) < 1e-6) break;\n\n\t            t = t - x2 / d2;\n\t        }\n\n\t        // Fall back to the bisection method for reliability.\n\t        var t0 = 0.0;\n\t        var t1 = 1.0;\n\t        t = x;\n\n\t        for (i = 0; i < 20; i++) {\n\t            x2 = this.sampleCurveX(t);\n\t            if (Math.abs(x2 - x) < epsilon) break;\n\n\t            if (x > x2) {\n\t                t0 = t;\n\t            } else {\n\t                t1 = t;\n\t            }\n\n\t            t = (t1 - t0) * 0.5 + t0;\n\t        }\n\n\t        return t;\n\t    },\n\n\t    solve: function (x, epsilon) {\n\t        return this.sampleCurveY(this.solveCurveX(x, epsilon));\n\t    }\n\t};\n\treturn unitbezier;\n}\n\nvar unitbezierExports = requireUnitbezier();\nvar UnitBezier = /*@__PURE__*/getDefaultExportFromCjs(unitbezierExports);\n\nclass Interpolate {\n    constructor(type, operator, interpolation, input, stops) {\n        this.type = type;\n        this.operator = operator;\n        this.interpolation = interpolation;\n        this.input = input;\n        this.labels = [];\n        this.outputs = [];\n        for (const [label, expression] of stops) {\n            this.labels.push(label);\n            this.outputs.push(expression);\n        }\n    }\n    static interpolationFactor(interpolation, input, lower, upper) {\n        let t = 0;\n        if (interpolation.name === 'exponential') {\n            t = exponentialInterpolation(input, interpolation.base, lower, upper);\n        }\n        else if (interpolation.name === 'linear') {\n            t = exponentialInterpolation(input, 1, lower, upper);\n        }\n        else if (interpolation.name === 'cubic-bezier') {\n            const c = interpolation.controlPoints;\n            const ub = new UnitBezier(c[0], c[1], c[2], c[3]);\n            t = ub.solve(exponentialInterpolation(input, 1, lower, upper));\n        }\n        return t;\n    }\n    static parse(args, context) {\n        let [operator, interpolation, input, ...rest] = args;\n        if (!Array.isArray(interpolation) || interpolation.length === 0) {\n            return context.error('Expected an interpolation type expression.', 1);\n        }\n        if (interpolation[0] === 'linear') {\n            interpolation = { name: 'linear' };\n        }\n        else if (interpolation[0] === 'exponential') {\n            const base = interpolation[1];\n            if (typeof base !== 'number')\n                return context.error('Exponential interpolation requires a numeric base.', 1, 1);\n            interpolation = {\n                name: 'exponential',\n                base\n            };\n        }\n        else if (interpolation[0] === 'cubic-bezier') {\n            const controlPoints = interpolation.slice(1);\n            if (controlPoints.length !== 4 ||\n                controlPoints.some(t => typeof t !== 'number' || t < 0 || t > 1)) {\n                return context.error('Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.', 1);\n            }\n            interpolation = {\n                name: 'cubic-bezier',\n                controlPoints: controlPoints\n            };\n        }\n        else {\n            return context.error(`Unknown interpolation type ${String(interpolation[0])}`, 1, 0);\n        }\n        if (args.length - 1 < 4) {\n            return context.error(`Expected at least 4 arguments, but found only ${args.length - 1}.`);\n        }\n        if ((args.length - 1) % 2 !== 0) {\n            return context.error('Expected an even number of arguments.');\n        }\n        input = context.parse(input, 2, NumberType);\n        if (!input)\n            return null;\n        const stops = [];\n        let outputType = null;\n        if (operator === 'interpolate-hcl' || operator === 'interpolate-lab') {\n            outputType = ColorType;\n        }\n        else if (context.expectedType && context.expectedType.kind !== 'value') {\n            outputType = context.expectedType;\n        }\n        for (let i = 0; i < rest.length; i += 2) {\n            const label = rest[i];\n            const value = rest[i + 1];\n            const labelKey = i + 3;\n            const valueKey = i + 4;\n            if (typeof label !== 'number') {\n                return context.error('Input/output pairs for \"interpolate\" expressions must be defined using literal numeric values (not computed expressions) for the input values.', labelKey);\n            }\n            if (stops.length && stops[stops.length - 1][0] >= label) {\n                return context.error('Input/output pairs for \"interpolate\" expressions must be arranged with input values in strictly ascending order.', labelKey);\n            }\n            const parsed = context.parse(value, valueKey, outputType);\n            if (!parsed)\n                return null;\n            outputType = outputType || parsed.type;\n            stops.push([label, parsed]);\n        }\n        if (!verifyType(outputType, NumberType) &&\n            !verifyType(outputType, ProjectionDefinitionType) &&\n            !verifyType(outputType, ColorType) &&\n            !verifyType(outputType, PaddingType) &&\n            !verifyType(outputType, VariableAnchorOffsetCollectionType) &&\n            !verifyType(outputType, array(NumberType))) {\n            return context.error(`Type ${typeToString(outputType)} is not interpolatable.`);\n        }\n        return new Interpolate(outputType, operator, interpolation, input, stops);\n    }\n    evaluate(ctx) {\n        const labels = this.labels;\n        const outputs = this.outputs;\n        if (labels.length === 1) {\n            return outputs[0].evaluate(ctx);\n        }\n        const value = this.input.evaluate(ctx);\n        if (value <= labels[0]) {\n            return outputs[0].evaluate(ctx);\n        }\n        const stopCount = labels.length;\n        if (value >= labels[stopCount - 1]) {\n            return outputs[stopCount - 1].evaluate(ctx);\n        }\n        const index = findStopLessThanOrEqualTo(labels, value);\n        const lower = labels[index];\n        const upper = labels[index + 1];\n        const t = Interpolate.interpolationFactor(this.interpolation, value, lower, upper);\n        const outputLower = outputs[index].evaluate(ctx);\n        const outputUpper = outputs[index + 1].evaluate(ctx);\n        switch (this.operator) {\n            case 'interpolate':\n                switch (this.type.kind) {\n                    case 'number':\n                        return interpolateNumber(outputLower, outputUpper, t);\n                    case 'color':\n                        return Color.interpolate(outputLower, outputUpper, t);\n                    case 'padding':\n                        return Padding.interpolate(outputLower, outputUpper, t);\n                    case 'variableAnchorOffsetCollection':\n                        return VariableAnchorOffsetCollection.interpolate(outputLower, outputUpper, t);\n                    case 'array':\n                        return interpolateArray(outputLower, outputUpper, t);\n                    case 'projectionDefinition':\n                        return ProjectionDefinition.interpolate(outputLower, outputUpper, t);\n                }\n            case 'interpolate-hcl':\n                return Color.interpolate(outputLower, outputUpper, t, 'hcl');\n            case 'interpolate-lab':\n                return Color.interpolate(outputLower, outputUpper, t, 'lab');\n        }\n    }\n    eachChild(fn) {\n        fn(this.input);\n        for (const expression of this.outputs) {\n            fn(expression);\n        }\n    }\n    outputDefined() {\n        return this.outputs.every(out => out.outputDefined());\n    }\n}\n/**\n * Returns a ratio that can be used to interpolate between exponential function\n * stops.\n * How it works: Two consecutive stop values define a (scaled and shifted) exponential function `f(x) = a * base^x + b`, where `base` is the user-specified base,\n * and `a` and `b` are constants affording sufficient degrees of freedom to fit\n * the function to the given stops.\n *\n * Here's a bit of algebra that lets us compute `f(x)` directly from the stop\n * values without explicitly solving for `a` and `b`:\n *\n * First stop value: `f(x0) = y0 = a * base^x0 + b`\n * Second stop value: `f(x1) = y1 = a * base^x1 + b`\n * => `y1 - y0 = a(base^x1 - base^x0)`\n * => `a = (y1 - y0)/(base^x1 - base^x0)`\n *\n * Desired value: `f(x) = y = a * base^x + b`\n * => `f(x) = y0 + a * (base^x - base^x0)`\n *\n * From the above, we can replace the `a` in `a * (base^x - base^x0)` and do a\n * little algebra:\n * ```\n * a * (base^x - base^x0) = (y1 - y0)/(base^x1 - base^x0) * (base^x - base^x0)\n *                     = (y1 - y0) * (base^x - base^x0) / (base^x1 - base^x0)\n * ```\n *\n * If we let `(base^x - base^x0) / (base^x1 base^x0)`, then we have\n * `f(x) = y0 + (y1 - y0) * ratio`.  In other words, `ratio` may be treated as\n * an interpolation factor between the two stops' output values.\n *\n * (Note: a slightly different form for `ratio`,\n * `(base^(x-x0) - 1) / (base^(x1-x0) - 1) `, is equivalent, but requires fewer\n * expensive `Math.pow()` operations.)\n *\n * @private\n*/\nfunction exponentialInterpolation(input, base, lowerValue, upperValue) {\n    const difference = upperValue - lowerValue;\n    const progress = input - lowerValue;\n    if (difference === 0) {\n        return 0;\n    }\n    else if (base === 1) {\n        return progress / difference;\n    }\n    else {\n        return (Math.pow(base, progress) - 1) / (Math.pow(base, difference) - 1);\n    }\n}\nconst interpolateFactory = {\n    color: Color.interpolate,\n    number: interpolateNumber,\n    padding: Padding.interpolate,\n    variableAnchorOffsetCollection: VariableAnchorOffsetCollection.interpolate,\n    array: interpolateArray\n};\n\nclass Coalesce {\n    constructor(type, args) {\n        this.type = type;\n        this.args = args;\n    }\n    static parse(args, context) {\n        if (args.length < 2) {\n            return context.error('Expected at least one argument.');\n        }\n        let outputType = null;\n        const expectedType = context.expectedType;\n        if (expectedType && expectedType.kind !== 'value') {\n            outputType = expectedType;\n        }\n        const parsedArgs = [];\n        for (const arg of args.slice(1)) {\n            const parsed = context.parse(arg, 1 + parsedArgs.length, outputType, undefined, { typeAnnotation: 'omit' });\n            if (!parsed)\n                return null;\n            outputType = outputType || parsed.type;\n            parsedArgs.push(parsed);\n        }\n        if (!outputType)\n            throw new Error('No output type');\n        // Above, we parse arguments without inferred type annotation so that\n        // they don't produce a runtime error for `null` input, which would\n        // preempt the desired null-coalescing behavior.\n        // Thus, if any of our arguments would have needed an annotation, we\n        // need to wrap the enclosing coalesce expression with it instead.\n        const needsAnnotation = expectedType &&\n            parsedArgs.some(arg => checkSubtype(expectedType, arg.type));\n        return needsAnnotation ?\n            new Coalesce(ValueType, parsedArgs) :\n            new Coalesce(outputType, parsedArgs);\n    }\n    evaluate(ctx) {\n        let result = null;\n        let argCount = 0;\n        let requestedImageName;\n        for (const arg of this.args) {\n            argCount++;\n            result = arg.evaluate(ctx);\n            // we need to keep track of the first requested image in a coalesce statement\n            // if coalesce can't find a valid image, we return the first image name so styleimagemissing can fire\n            if (result && result instanceof ResolvedImage && !result.available) {\n                if (!requestedImageName) {\n                    requestedImageName = result.name;\n                }\n                result = null;\n                if (argCount === this.args.length) {\n                    result = requestedImageName;\n                }\n            }\n            if (result !== null)\n                break;\n        }\n        return result;\n    }\n    eachChild(fn) {\n        this.args.forEach(fn);\n    }\n    outputDefined() {\n        return this.args.every(arg => arg.outputDefined());\n    }\n}\n\nfunction isComparableType(op, type) {\n    if (op === '==' || op === '!=') {\n        // equality operator\n        return type.kind === 'boolean' ||\n            type.kind === 'string' ||\n            type.kind === 'number' ||\n            type.kind === 'null' ||\n            type.kind === 'value';\n    }\n    else {\n        // ordering operator\n        return type.kind === 'string' ||\n            type.kind === 'number' ||\n            type.kind === 'value';\n    }\n}\nfunction eq(ctx, a, b) { return a === b; }\nfunction neq(ctx, a, b) { return a !== b; }\nfunction lt(ctx, a, b) { return a < b; }\nfunction gt(ctx, a, b) { return a > b; }\nfunction lteq(ctx, a, b) { return a <= b; }\nfunction gteq(ctx, a, b) { return a >= b; }\nfunction eqCollate(ctx, a, b, c) { return c.compare(a, b) === 0; }\nfunction neqCollate(ctx, a, b, c) { return !eqCollate(ctx, a, b, c); }\nfunction ltCollate(ctx, a, b, c) { return c.compare(a, b) < 0; }\nfunction gtCollate(ctx, a, b, c) { return c.compare(a, b) > 0; }\nfunction lteqCollate(ctx, a, b, c) { return c.compare(a, b) <= 0; }\nfunction gteqCollate(ctx, a, b, c) { return c.compare(a, b) >= 0; }\n/**\n * Special form for comparison operators, implementing the signatures:\n * - (T, T, ?Collator) => boolean\n * - (T, value, ?Collator) => boolean\n * - (value, T, ?Collator) => boolean\n *\n * For inequalities, T must be either value, string, or number. For ==/!=, it\n * can also be boolean or null.\n *\n * Equality semantics are equivalent to Javascript's strict equality (===/!==)\n * -- i.e., when the arguments' types don't match, == evaluates to false, != to\n * true.\n *\n * When types don't match in an ordering comparison, a runtime error is thrown.\n *\n * @private\n */\nfunction makeComparison(op, compareBasic, compareWithCollator) {\n    const isOrderComparison = op !== '==' && op !== '!=';\n    return class Comparison {\n        constructor(lhs, rhs, collator) {\n            this.type = BooleanType;\n            this.lhs = lhs;\n            this.rhs = rhs;\n            this.collator = collator;\n            this.hasUntypedArgument = lhs.type.kind === 'value' || rhs.type.kind === 'value';\n        }\n        static parse(args, context) {\n            if (args.length !== 3 && args.length !== 4)\n                return context.error('Expected two or three arguments.');\n            const op = args[0];\n            let lhs = context.parse(args[1], 1, ValueType);\n            if (!lhs)\n                return null;\n            if (!isComparableType(op, lhs.type)) {\n                return context.concat(1).error(`\"${op}\" comparisons are not supported for type '${typeToString(lhs.type)}'.`);\n            }\n            let rhs = context.parse(args[2], 2, ValueType);\n            if (!rhs)\n                return null;\n            if (!isComparableType(op, rhs.type)) {\n                return context.concat(2).error(`\"${op}\" comparisons are not supported for type '${typeToString(rhs.type)}'.`);\n            }\n            if (lhs.type.kind !== rhs.type.kind &&\n                lhs.type.kind !== 'value' &&\n                rhs.type.kind !== 'value') {\n                return context.error(`Cannot compare types '${typeToString(lhs.type)}' and '${typeToString(rhs.type)}'.`);\n            }\n            if (isOrderComparison) {\n                // typing rules specific to less/greater than operators\n                if (lhs.type.kind === 'value' && rhs.type.kind !== 'value') {\n                    // (value, T)\n                    lhs = new Assertion(rhs.type, [lhs]);\n                }\n                else if (lhs.type.kind !== 'value' && rhs.type.kind === 'value') {\n                    // (T, value)\n                    rhs = new Assertion(lhs.type, [rhs]);\n                }\n            }\n            let collator = null;\n            if (args.length === 4) {\n                if (lhs.type.kind !== 'string' &&\n                    rhs.type.kind !== 'string' &&\n                    lhs.type.kind !== 'value' &&\n                    rhs.type.kind !== 'value') {\n                    return context.error('Cannot use collator to compare non-string types.');\n                }\n                collator = context.parse(args[3], 3, CollatorType);\n                if (!collator)\n                    return null;\n            }\n            return new Comparison(lhs, rhs, collator);\n        }\n        evaluate(ctx) {\n            const lhs = this.lhs.evaluate(ctx);\n            const rhs = this.rhs.evaluate(ctx);\n            if (isOrderComparison && this.hasUntypedArgument) {\n                const lt = typeOf(lhs);\n                const rt = typeOf(rhs);\n                // check that type is string or number, and equal\n                if (lt.kind !== rt.kind || !(lt.kind === 'string' || lt.kind === 'number')) {\n                    throw new RuntimeError(`Expected arguments for \"${op}\" to be (string, string) or (number, number), but found (${lt.kind}, ${rt.kind}) instead.`);\n                }\n            }\n            if (this.collator && !isOrderComparison && this.hasUntypedArgument) {\n                const lt = typeOf(lhs);\n                const rt = typeOf(rhs);\n                if (lt.kind !== 'string' || rt.kind !== 'string') {\n                    return compareBasic(ctx, lhs, rhs);\n                }\n            }\n            return this.collator ?\n                compareWithCollator(ctx, lhs, rhs, this.collator.evaluate(ctx)) :\n                compareBasic(ctx, lhs, rhs);\n        }\n        eachChild(fn) {\n            fn(this.lhs);\n            fn(this.rhs);\n            if (this.collator) {\n                fn(this.collator);\n            }\n        }\n        outputDefined() {\n            return true;\n        }\n    };\n}\nconst Equals = makeComparison('==', eq, eqCollate);\nconst NotEquals = makeComparison('!=', neq, neqCollate);\nconst LessThan = makeComparison('<', lt, ltCollate);\nconst GreaterThan = makeComparison('>', gt, gtCollate);\nconst LessThanOrEqual = makeComparison('<=', lteq, lteqCollate);\nconst GreaterThanOrEqual = makeComparison('>=', gteq, gteqCollate);\n\nclass CollatorExpression {\n    constructor(caseSensitive, diacriticSensitive, locale) {\n        this.type = CollatorType;\n        this.locale = locale;\n        this.caseSensitive = caseSensitive;\n        this.diacriticSensitive = diacriticSensitive;\n    }\n    static parse(args, context) {\n        if (args.length !== 2)\n            return context.error('Expected one argument.');\n        const options = args[1];\n        if (typeof options !== 'object' || Array.isArray(options))\n            return context.error('Collator options argument must be an object.');\n        const caseSensitive = context.parse(options['case-sensitive'] === undefined ? false : options['case-sensitive'], 1, BooleanType);\n        if (!caseSensitive)\n            return null;\n        const diacriticSensitive = context.parse(options['diacritic-sensitive'] === undefined ? false : options['diacritic-sensitive'], 1, BooleanType);\n        if (!diacriticSensitive)\n            return null;\n        let locale = null;\n        if (options['locale']) {\n            locale = context.parse(options['locale'], 1, StringType);\n            if (!locale)\n                return null;\n        }\n        return new CollatorExpression(caseSensitive, diacriticSensitive, locale);\n    }\n    evaluate(ctx) {\n        return new Collator(this.caseSensitive.evaluate(ctx), this.diacriticSensitive.evaluate(ctx), this.locale ? this.locale.evaluate(ctx) : null);\n    }\n    eachChild(fn) {\n        fn(this.caseSensitive);\n        fn(this.diacriticSensitive);\n        if (this.locale) {\n            fn(this.locale);\n        }\n    }\n    outputDefined() {\n        // Technically the set of possible outputs is the combinatoric set of Collators produced\n        // by all possible outputs of locale/caseSensitive/diacriticSensitive\n        // But for the primary use of Collators in comparison operators, we ignore the Collator's\n        // possible outputs anyway, so we can get away with leaving this false for now.\n        return false;\n    }\n}\n\nclass NumberFormat {\n    constructor(number, locale, currency, minFractionDigits, maxFractionDigits) {\n        this.type = StringType;\n        this.number = number;\n        this.locale = locale;\n        this.currency = currency;\n        this.minFractionDigits = minFractionDigits;\n        this.maxFractionDigits = maxFractionDigits;\n    }\n    static parse(args, context) {\n        if (args.length !== 3)\n            return context.error('Expected two arguments.');\n        const number = context.parse(args[1], 1, NumberType);\n        if (!number)\n            return null;\n        const options = args[2];\n        if (typeof options !== 'object' || Array.isArray(options))\n            return context.error('NumberFormat options argument must be an object.');\n        let locale = null;\n        if (options['locale']) {\n            locale = context.parse(options['locale'], 1, StringType);\n            if (!locale)\n                return null;\n        }\n        let currency = null;\n        if (options['currency']) {\n            currency = context.parse(options['currency'], 1, StringType);\n            if (!currency)\n                return null;\n        }\n        let minFractionDigits = null;\n        if (options['min-fraction-digits']) {\n            minFractionDigits = context.parse(options['min-fraction-digits'], 1, NumberType);\n            if (!minFractionDigits)\n                return null;\n        }\n        let maxFractionDigits = null;\n        if (options['max-fraction-digits']) {\n            maxFractionDigits = context.parse(options['max-fraction-digits'], 1, NumberType);\n            if (!maxFractionDigits)\n                return null;\n        }\n        return new NumberFormat(number, locale, currency, minFractionDigits, maxFractionDigits);\n    }\n    evaluate(ctx) {\n        return new Intl.NumberFormat(this.locale ? this.locale.evaluate(ctx) : [], {\n            style: this.currency ? 'currency' : 'decimal',\n            currency: this.currency ? this.currency.evaluate(ctx) : undefined,\n            minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(ctx) : undefined,\n            maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(ctx) : undefined,\n        }).format(this.number.evaluate(ctx));\n    }\n    eachChild(fn) {\n        fn(this.number);\n        if (this.locale) {\n            fn(this.locale);\n        }\n        if (this.currency) {\n            fn(this.currency);\n        }\n        if (this.minFractionDigits) {\n            fn(this.minFractionDigits);\n        }\n        if (this.maxFractionDigits) {\n            fn(this.maxFractionDigits);\n        }\n    }\n    outputDefined() {\n        return false;\n    }\n}\n\nclass FormatExpression {\n    constructor(sections) {\n        this.type = FormattedType;\n        this.sections = sections;\n    }\n    static parse(args, context) {\n        if (args.length < 2) {\n            return context.error('Expected at least one argument.');\n        }\n        const firstArg = args[1];\n        if (!Array.isArray(firstArg) && typeof firstArg === 'object') {\n            return context.error('First argument must be an image or text section.');\n        }\n        const sections = [];\n        let nextTokenMayBeObject = false;\n        for (let i = 1; i <= args.length - 1; ++i) {\n            const arg = args[i];\n            if (nextTokenMayBeObject && typeof arg === 'object' && !Array.isArray(arg)) {\n                nextTokenMayBeObject = false;\n                let scale = null;\n                if (arg['font-scale']) {\n                    scale = context.parse(arg['font-scale'], 1, NumberType);\n                    if (!scale)\n                        return null;\n                }\n                let font = null;\n                if (arg['text-font']) {\n                    font = context.parse(arg['text-font'], 1, array(StringType));\n                    if (!font)\n                        return null;\n                }\n                let textColor = null;\n                if (arg['text-color']) {\n                    textColor = context.parse(arg['text-color'], 1, ColorType);\n                    if (!textColor)\n                        return null;\n                }\n                const lastExpression = sections[sections.length - 1];\n                lastExpression.scale = scale;\n                lastExpression.font = font;\n                lastExpression.textColor = textColor;\n            }\n            else {\n                const content = context.parse(args[i], 1, ValueType);\n                if (!content)\n                    return null;\n                const kind = content.type.kind;\n                if (kind !== 'string' && kind !== 'value' && kind !== 'null' && kind !== 'resolvedImage')\n                    return context.error('Formatted text type must be \\'string\\', \\'value\\', \\'image\\' or \\'null\\'.');\n                nextTokenMayBeObject = true;\n                sections.push({ content, scale: null, font: null, textColor: null });\n            }\n        }\n        return new FormatExpression(sections);\n    }\n    evaluate(ctx) {\n        const evaluateSection = section => {\n            const evaluatedContent = section.content.evaluate(ctx);\n            if (typeOf(evaluatedContent) === ResolvedImageType) {\n                return new FormattedSection('', evaluatedContent, null, null, null);\n            }\n            return new FormattedSection(valueToString(evaluatedContent), null, section.scale ? section.scale.evaluate(ctx) : null, section.font ? section.font.evaluate(ctx).join(',') : null, section.textColor ? section.textColor.evaluate(ctx) : null);\n        };\n        return new Formatted(this.sections.map(evaluateSection));\n    }\n    eachChild(fn) {\n        for (const section of this.sections) {\n            fn(section.content);\n            if (section.scale) {\n                fn(section.scale);\n            }\n            if (section.font) {\n                fn(section.font);\n            }\n            if (section.textColor) {\n                fn(section.textColor);\n            }\n        }\n    }\n    outputDefined() {\n        // Technically the combinatoric set of all children\n        // Usually, this.text will be undefined anyway\n        return false;\n    }\n}\n\nclass ImageExpression {\n    constructor(input) {\n        this.type = ResolvedImageType;\n        this.input = input;\n    }\n    static parse(args, context) {\n        if (args.length !== 2) {\n            return context.error('Expected two arguments.');\n        }\n        const name = context.parse(args[1], 1, StringType);\n        if (!name)\n            return context.error('No image name provided.');\n        return new ImageExpression(name);\n    }\n    evaluate(ctx) {\n        const evaluatedImageName = this.input.evaluate(ctx);\n        const value = ResolvedImage.fromString(evaluatedImageName);\n        if (value && ctx.availableImages)\n            value.available = ctx.availableImages.indexOf(evaluatedImageName) > -1;\n        return value;\n    }\n    eachChild(fn) {\n        fn(this.input);\n    }\n    outputDefined() {\n        // The output of image is determined by the list of available images in the evaluation context\n        return false;\n    }\n}\n\nclass Length {\n    constructor(input) {\n        this.type = NumberType;\n        this.input = input;\n    }\n    static parse(args, context) {\n        if (args.length !== 2)\n            return context.error(`Expected 1 argument, but found ${args.length - 1} instead.`);\n        const input = context.parse(args[1], 1);\n        if (!input)\n            return null;\n        if (input.type.kind !== 'array' && input.type.kind !== 'string' && input.type.kind !== 'value')\n            return context.error(`Expected argument of type string or array, but found ${typeToString(input.type)} instead.`);\n        return new Length(input);\n    }\n    evaluate(ctx) {\n        const input = this.input.evaluate(ctx);\n        if (typeof input === 'string') {\n            // The length may be affected by surrogate pairs.\n            return [...input].length;\n        }\n        else if (Array.isArray(input)) {\n            return input.length;\n        }\n        else {\n            throw new RuntimeError(`Expected value to be of type string or array, but found ${typeToString(typeOf(input))} instead.`);\n        }\n    }\n    eachChild(fn) {\n        fn(this.input);\n    }\n    outputDefined() {\n        return false;\n    }\n}\n\nconst EXTENT = 8192;\nfunction getTileCoordinates(p, canonical) {\n    const x = mercatorXfromLng(p[0]);\n    const y = mercatorYfromLat(p[1]);\n    const tilesAtZoom = Math.pow(2, canonical.z);\n    return [Math.round(x * tilesAtZoom * EXTENT), Math.round(y * tilesAtZoom * EXTENT)];\n}\nfunction getLngLatFromTileCoord(coord, canonical) {\n    const tilesAtZoom = Math.pow(2, canonical.z);\n    const x = (coord[0] / EXTENT + canonical.x) / tilesAtZoom;\n    const y = (coord[1] / EXTENT + canonical.y) / tilesAtZoom;\n    return [lngFromMercatorXfromLng(x), latFromMercatorY(y)];\n}\nfunction mercatorXfromLng(lng) {\n    return (180 + lng) / 360;\n}\nfunction lngFromMercatorXfromLng(mercatorX) {\n    return mercatorX * 360 - 180;\n}\nfunction mercatorYfromLat(lat) {\n    return (180 - (180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + lat * Math.PI / 360)))) / 360;\n}\nfunction latFromMercatorY(mercatorY) {\n    return 360 / Math.PI * Math.atan(Math.exp((180 - mercatorY * 360) * Math.PI / 180)) - 90;\n}\nfunction updateBBox(bbox, coord) {\n    bbox[0] = Math.min(bbox[0], coord[0]);\n    bbox[1] = Math.min(bbox[1], coord[1]);\n    bbox[2] = Math.max(bbox[2], coord[0]);\n    bbox[3] = Math.max(bbox[3], coord[1]);\n}\nfunction boxWithinBox(bbox1, bbox2) {\n    if (bbox1[0] <= bbox2[0])\n        return false;\n    if (bbox1[2] >= bbox2[2])\n        return false;\n    if (bbox1[1] <= bbox2[1])\n        return false;\n    if (bbox1[3] >= bbox2[3])\n        return false;\n    return true;\n}\nfunction rayIntersect(p, p1, p2) {\n    return ((p1[1] > p[1]) !== (p2[1] > p[1])) && (p[0] < (p2[0] - p1[0]) * (p[1] - p1[1]) / (p2[1] - p1[1]) + p1[0]);\n}\nfunction pointOnBoundary(p, p1, p2) {\n    const x1 = p[0] - p1[0];\n    const y1 = p[1] - p1[1];\n    const x2 = p[0] - p2[0];\n    const y2 = p[1] - p2[1];\n    return (x1 * y2 - x2 * y1 === 0) && (x1 * x2 <= 0) && (y1 * y2 <= 0);\n}\n// a, b are end points for line segment1, c and d are end points for line segment2\nfunction segmentIntersectSegment(a, b, c, d) {\n    // check if two segments are parallel or not\n    // precondition is end point a, b is inside polygon, if line a->b is\n    // parallel to polygon edge c->d, then a->b won't intersect with c->d\n    const vectorP = [b[0] - a[0], b[1] - a[1]];\n    const vectorQ = [d[0] - c[0], d[1] - c[1]];\n    if (perp(vectorQ, vectorP) === 0)\n        return false;\n    // If lines are intersecting with each other, the relative location should be:\n    // a and b lie in different sides of segment c->d\n    // c and d lie in different sides of segment a->b\n    if (twoSided(a, b, c, d) && twoSided(c, d, a, b))\n        return true;\n    return false;\n}\nfunction lineIntersectPolygon(p1, p2, polygon) {\n    for (const ring of polygon) {\n        // loop through every edge of the ring\n        for (let j = 0; j < ring.length - 1; ++j) {\n            if (segmentIntersectSegment(p1, p2, ring[j], ring[j + 1])) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n// ray casting algorithm for detecting if point is in polygon\nfunction pointWithinPolygon(point, rings, trueIfOnBoundary = false) {\n    let inside = false;\n    for (const ring of rings) {\n        for (let j = 0; j < ring.length - 1; j++) {\n            if (pointOnBoundary(point, ring[j], ring[j + 1]))\n                return trueIfOnBoundary;\n            if (rayIntersect(point, ring[j], ring[j + 1]))\n                inside = !inside;\n        }\n    }\n    return inside;\n}\nfunction pointWithinPolygons(point, polygons) {\n    for (const polygon of polygons) {\n        if (pointWithinPolygon(point, polygon))\n            return true;\n    }\n    return false;\n}\nfunction lineStringWithinPolygon(line, polygon) {\n    // First, check if geometry points of line segments are all inside polygon\n    for (const point of line) {\n        if (!pointWithinPolygon(point, polygon)) {\n            return false;\n        }\n    }\n    // Second, check if there is line segment intersecting polygon edge\n    for (let i = 0; i < line.length - 1; ++i) {\n        if (lineIntersectPolygon(line[i], line[i + 1], polygon)) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction lineStringWithinPolygons(line, polygons) {\n    for (const polygon of polygons) {\n        if (lineStringWithinPolygon(line, polygon))\n            return true;\n    }\n    return false;\n}\nfunction perp(v1, v2) {\n    return (v1[0] * v2[1] - v1[1] * v2[0]);\n}\n// check if p1 and p2 are in different sides of line segment q1->q2\nfunction twoSided(p1, p2, q1, q2) {\n    // q1->p1 (x1, y1), q1->p2 (x2, y2), q1->q2 (x3, y3)\n    const x1 = p1[0] - q1[0];\n    const y1 = p1[1] - q1[1];\n    const x2 = p2[0] - q1[0];\n    const y2 = p2[1] - q1[1];\n    const x3 = q2[0] - q1[0];\n    const y3 = q2[1] - q1[1];\n    const det1 = (x1 * y3 - x3 * y1);\n    const det2 = (x2 * y3 - x3 * y2);\n    if ((det1 > 0 && det2 < 0) || (det1 < 0 && det2 > 0))\n        return true;\n    return false;\n}\n\nfunction getTilePolygon(coordinates, bbox, canonical) {\n    const polygon = [];\n    for (let i = 0; i < coordinates.length; i++) {\n        const ring = [];\n        for (let j = 0; j < coordinates[i].length; j++) {\n            const coord = getTileCoordinates(coordinates[i][j], canonical);\n            updateBBox(bbox, coord);\n            ring.push(coord);\n        }\n        polygon.push(ring);\n    }\n    return polygon;\n}\nfunction getTilePolygons(coordinates, bbox, canonical) {\n    const polygons = [];\n    for (let i = 0; i < coordinates.length; i++) {\n        const polygon = getTilePolygon(coordinates[i], bbox, canonical);\n        polygons.push(polygon);\n    }\n    return polygons;\n}\nfunction updatePoint(p, bbox, polyBBox, worldSize) {\n    if (p[0] < polyBBox[0] || p[0] > polyBBox[2]) {\n        const halfWorldSize = worldSize * 0.5;\n        let shift = (p[0] - polyBBox[0] > halfWorldSize) ? -worldSize : (polyBBox[0] - p[0] > halfWorldSize) ? worldSize : 0;\n        if (shift === 0) {\n            shift = (p[0] - polyBBox[2] > halfWorldSize) ? -worldSize : (polyBBox[2] - p[0] > halfWorldSize) ? worldSize : 0;\n        }\n        p[0] += shift;\n    }\n    updateBBox(bbox, p);\n}\nfunction resetBBox(bbox) {\n    bbox[0] = bbox[1] = Infinity;\n    bbox[2] = bbox[3] = -Infinity;\n}\nfunction getTilePoints(geometry, pointBBox, polyBBox, canonical) {\n    const worldSize = Math.pow(2, canonical.z) * EXTENT;\n    const shifts = [canonical.x * EXTENT, canonical.y * EXTENT];\n    const tilePoints = [];\n    for (const points of geometry) {\n        for (const point of points) {\n            const p = [point.x + shifts[0], point.y + shifts[1]];\n            updatePoint(p, pointBBox, polyBBox, worldSize);\n            tilePoints.push(p);\n        }\n    }\n    return tilePoints;\n}\nfunction getTileLines(geometry, lineBBox, polyBBox, canonical) {\n    const worldSize = Math.pow(2, canonical.z) * EXTENT;\n    const shifts = [canonical.x * EXTENT, canonical.y * EXTENT];\n    const tileLines = [];\n    for (const line of geometry) {\n        const tileLine = [];\n        for (const point of line) {\n            const p = [point.x + shifts[0], point.y + shifts[1]];\n            updateBBox(lineBBox, p);\n            tileLine.push(p);\n        }\n        tileLines.push(tileLine);\n    }\n    if (lineBBox[2] - lineBBox[0] <= worldSize / 2) {\n        resetBBox(lineBBox);\n        for (const line of tileLines) {\n            for (const p of line) {\n                updatePoint(p, lineBBox, polyBBox, worldSize);\n            }\n        }\n    }\n    return tileLines;\n}\nfunction pointsWithinPolygons(ctx, polygonGeometry) {\n    const pointBBox = [Infinity, Infinity, -Infinity, -Infinity];\n    const polyBBox = [Infinity, Infinity, -Infinity, -Infinity];\n    const canonical = ctx.canonicalID();\n    if (polygonGeometry.type === 'Polygon') {\n        const tilePolygon = getTilePolygon(polygonGeometry.coordinates, polyBBox, canonical);\n        const tilePoints = getTilePoints(ctx.geometry(), pointBBox, polyBBox, canonical);\n        if (!boxWithinBox(pointBBox, polyBBox))\n            return false;\n        for (const point of tilePoints) {\n            if (!pointWithinPolygon(point, tilePolygon))\n                return false;\n        }\n    }\n    if (polygonGeometry.type === 'MultiPolygon') {\n        const tilePolygons = getTilePolygons(polygonGeometry.coordinates, polyBBox, canonical);\n        const tilePoints = getTilePoints(ctx.geometry(), pointBBox, polyBBox, canonical);\n        if (!boxWithinBox(pointBBox, polyBBox))\n            return false;\n        for (const point of tilePoints) {\n            if (!pointWithinPolygons(point, tilePolygons))\n                return false;\n        }\n    }\n    return true;\n}\nfunction linesWithinPolygons(ctx, polygonGeometry) {\n    const lineBBox = [Infinity, Infinity, -Infinity, -Infinity];\n    const polyBBox = [Infinity, Infinity, -Infinity, -Infinity];\n    const canonical = ctx.canonicalID();\n    if (polygonGeometry.type === 'Polygon') {\n        const tilePolygon = getTilePolygon(polygonGeometry.coordinates, polyBBox, canonical);\n        const tileLines = getTileLines(ctx.geometry(), lineBBox, polyBBox, canonical);\n        if (!boxWithinBox(lineBBox, polyBBox))\n            return false;\n        for (const line of tileLines) {\n            if (!lineStringWithinPolygon(line, tilePolygon))\n                return false;\n        }\n    }\n    if (polygonGeometry.type === 'MultiPolygon') {\n        const tilePolygons = getTilePolygons(polygonGeometry.coordinates, polyBBox, canonical);\n        const tileLines = getTileLines(ctx.geometry(), lineBBox, polyBBox, canonical);\n        if (!boxWithinBox(lineBBox, polyBBox))\n            return false;\n        for (const line of tileLines) {\n            if (!lineStringWithinPolygons(line, tilePolygons))\n                return false;\n        }\n    }\n    return true;\n}\nclass Within {\n    constructor(geojson, geometries) {\n        this.type = BooleanType;\n        this.geojson = geojson;\n        this.geometries = geometries;\n    }\n    static parse(args, context) {\n        if (args.length !== 2)\n            return context.error(`'within' expression requires exactly one argument, but found ${args.length - 1} instead.`);\n        if (isValue(args[1])) {\n            const geojson = args[1];\n            if (geojson.type === 'FeatureCollection') {\n                const polygonsCoords = [];\n                for (const polygon of geojson.features) {\n                    const { type, coordinates } = polygon.geometry;\n                    if (type === 'Polygon') {\n                        polygonsCoords.push(coordinates);\n                    }\n                    if (type === 'MultiPolygon') {\n                        polygonsCoords.push(...coordinates);\n                    }\n                }\n                if (polygonsCoords.length) {\n                    const multipolygonWrapper = {\n                        type: 'MultiPolygon',\n                        coordinates: polygonsCoords\n                    };\n                    return new Within(geojson, multipolygonWrapper);\n                }\n            }\n            else if (geojson.type === 'Feature') {\n                const type = geojson.geometry.type;\n                if (type === 'Polygon' || type === 'MultiPolygon') {\n                    return new Within(geojson, geojson.geometry);\n                }\n            }\n            else if (geojson.type === 'Polygon' || geojson.type === 'MultiPolygon') {\n                return new Within(geojson, geojson);\n            }\n        }\n        return context.error('\\'within\\' expression requires valid geojson object that contains polygon geometry type.');\n    }\n    evaluate(ctx) {\n        if (ctx.geometry() != null && ctx.canonicalID() != null) {\n            if (ctx.geometryDollarType() === 'Point') {\n                return pointsWithinPolygons(ctx, this.geometries);\n            }\n            else if (ctx.geometryDollarType() === 'LineString') {\n                return linesWithinPolygons(ctx, this.geometries);\n            }\n        }\n        return false;\n    }\n    eachChild() { }\n    outputDefined() {\n        return true;\n    }\n}\n\nclass TinyQueue {\n    constructor(data = [], compare = (a, b) => (a < b ? -1 : a > b ? 1 : 0)) {\n        this.data = data;\n        this.length = this.data.length;\n        this.compare = compare;\n\n        if (this.length > 0) {\n            for (let i = (this.length >> 1) - 1; i >= 0; i--) this._down(i);\n        }\n    }\n\n    push(item) {\n        this.data.push(item);\n        this._up(this.length++);\n    }\n\n    pop() {\n        if (this.length === 0) return undefined;\n\n        const top = this.data[0];\n        const bottom = this.data.pop();\n\n        if (--this.length > 0) {\n            this.data[0] = bottom;\n            this._down(0);\n        }\n\n        return top;\n    }\n\n    peek() {\n        return this.data[0];\n    }\n\n    _up(pos) {\n        const {data, compare} = this;\n        const item = data[pos];\n\n        while (pos > 0) {\n            const parent = (pos - 1) >> 1;\n            const current = data[parent];\n            if (compare(item, current) >= 0) break;\n            data[pos] = current;\n            pos = parent;\n        }\n\n        data[pos] = item;\n    }\n\n    _down(pos) {\n        const {data, compare} = this;\n        const halfLength = this.length >> 1;\n        const item = data[pos];\n\n        while (pos < halfLength) {\n            let bestChild = (pos << 1) + 1; // initially it is the left child\n            const right = bestChild + 1;\n\n            if (right < this.length && compare(data[right], data[bestChild]) < 0) {\n                bestChild = right;\n            }\n            if (compare(data[bestChild], item) >= 0) break;\n\n            data[pos] = data[bestChild];\n            pos = bestChild;\n        }\n\n        data[pos] = item;\n    }\n}\n\n// This is taken from https://github.com/mapbox/cheap-ruler/ in order to take only the relevant parts\n// Values that define WGS84 ellipsoid model of the Earth\nconst RE = 6378.137; // equatorial radius\nconst FE = 1 / 298.257223563; // flattening\nconst E2 = FE * (2 - FE);\nconst RAD = Math.PI / 180;\nclass CheapRuler {\n    constructor(lat) {\n        // Curvature formulas from https://en.wikipedia.org/wiki/Earth_radius#Meridional\n        const m = RAD * RE * 1000;\n        const coslat = Math.cos(lat * RAD);\n        const w2 = 1 / (1 - E2 * (1 - coslat * coslat));\n        const w = Math.sqrt(w2);\n        // multipliers for converting longitude and latitude degrees into distance\n        this.kx = m * w * coslat; // based on normal radius of curvature\n        this.ky = m * w * w2 * (1 - E2); // based on meridional radius of curvature\n    }\n    /**\n     * Given two points of the form [longitude, latitude], returns the distance.\n     *\n     * @param a - point [longitude, latitude]\n     * @param b - point [longitude, latitude]\n     * @returns distance\n     * @example\n     * const distance = ruler.distance([30.5, 50.5], [30.51, 50.49]);\n     * //=distance\n     */\n    distance(a, b) {\n        const dx = this.wrap(a[0] - b[0]) * this.kx;\n        const dy = (a[1] - b[1]) * this.ky;\n        return Math.sqrt(dx * dx + dy * dy);\n    }\n    /**\n     * Returns an object of the form {point, index, t}, where point is closest point on the line\n     * from the given point, index is the start index of the segment with the closest point,\n     * and t is a parameter from 0 to 1 that indicates where the closest point is on that segment.\n     *\n     * @param line - an array of points that form the line\n     * @param p - point [longitude, latitude]\n     * @returns the nearest point, its index in the array and the proportion along the line\n     * @example\n     * const point = ruler.pointOnLine(line, [-67.04, 50.5]).point;\n     * //=point\n     */\n    pointOnLine(line, p) {\n        let minDist = Infinity;\n        let minX, minY, minI, minT;\n        for (let i = 0; i < line.length - 1; i++) {\n            let x = line[i][0];\n            let y = line[i][1];\n            let dx = this.wrap(line[i + 1][0] - x) * this.kx;\n            let dy = (line[i + 1][1] - y) * this.ky;\n            let t = 0;\n            if (dx !== 0 || dy !== 0) {\n                t = (this.wrap(p[0] - x) * this.kx * dx + (p[1] - y) * this.ky * dy) / (dx * dx + dy * dy);\n                if (t > 1) {\n                    x = line[i + 1][0];\n                    y = line[i + 1][1];\n                }\n                else if (t > 0) {\n                    x += (dx / this.kx) * t;\n                    y += (dy / this.ky) * t;\n                }\n            }\n            dx = this.wrap(p[0] - x) * this.kx;\n            dy = (p[1] - y) * this.ky;\n            const sqDist = dx * dx + dy * dy;\n            if (sqDist < minDist) {\n                minDist = sqDist;\n                minX = x;\n                minY = y;\n                minI = i;\n                minT = t;\n            }\n        }\n        return {\n            point: [minX, minY],\n            index: minI,\n            t: Math.max(0, Math.min(1, minT))\n        };\n    }\n    wrap(deg) {\n        while (deg < -180)\n            deg += 360;\n        while (deg > 180)\n            deg -= 360;\n        return deg;\n    }\n}\n\nconst MinPointsSize = 100;\nconst MinLinePointsSize = 50;\nfunction compareDistPair(a, b) {\n    return b[0] - a[0];\n}\nfunction getRangeSize(range) {\n    return range[1] - range[0] + 1;\n}\nfunction isRangeSafe(range, threshold) {\n    return range[1] >= range[0] && range[1] < threshold;\n}\nfunction splitRange(range, isLine) {\n    if (range[0] > range[1]) {\n        return [null, null];\n    }\n    const size = getRangeSize(range);\n    if (isLine) {\n        if (size === 2) {\n            return [range, null];\n        }\n        const size1 = Math.floor(size / 2);\n        return [[range[0], range[0] + size1],\n            [range[0] + size1, range[1]]];\n    }\n    if (size === 1) {\n        return [range, null];\n    }\n    const size1 = Math.floor(size / 2) - 1;\n    return [[range[0], range[0] + size1],\n        [range[0] + size1 + 1, range[1]]];\n}\nfunction getBBox(coords, range) {\n    if (!isRangeSafe(range, coords.length)) {\n        return [Infinity, Infinity, -Infinity, -Infinity];\n    }\n    const bbox = [Infinity, Infinity, -Infinity, -Infinity];\n    for (let i = range[0]; i <= range[1]; ++i) {\n        updateBBox(bbox, coords[i]);\n    }\n    return bbox;\n}\nfunction getPolygonBBox(polygon) {\n    const bbox = [Infinity, Infinity, -Infinity, -Infinity];\n    for (const ring of polygon) {\n        for (const coord of ring) {\n            updateBBox(bbox, coord);\n        }\n    }\n    return bbox;\n}\nfunction isValidBBox(bbox) {\n    return bbox[0] !== -Infinity && bbox[1] !== -Infinity && bbox[2] !== Infinity && bbox[3] !== Infinity;\n}\n// Calculate the distance between two bounding boxes.\n// Calculate the delta in x and y direction, and use two fake points {0.0, 0.0}\n// and {dx, dy} to calculate the distance. Distance will be 0.0 if bounding box are overlapping.\nfunction bboxToBBoxDistance(bbox1, bbox2, ruler) {\n    if (!isValidBBox(bbox1) || !isValidBBox(bbox2)) {\n        return NaN;\n    }\n    let dx = 0.0;\n    let dy = 0.0;\n    // bbox1 in left side\n    if (bbox1[2] < bbox2[0]) {\n        dx = bbox2[0] - bbox1[2];\n    }\n    // bbox1 in right side\n    if (bbox1[0] > bbox2[2]) {\n        dx = bbox1[0] - bbox2[2];\n    }\n    // bbox1 in above side\n    if (bbox1[1] > bbox2[3]) {\n        dy = bbox1[1] - bbox2[3];\n    }\n    // bbox1 in down side\n    if (bbox1[3] < bbox2[1]) {\n        dy = bbox2[1] - bbox1[3];\n    }\n    return ruler.distance([0.0, 0.0], [dx, dy]);\n}\nfunction pointToLineDistance(point, line, ruler) {\n    const nearestPoint = ruler.pointOnLine(line, point);\n    return ruler.distance(point, nearestPoint.point);\n}\nfunction segmentToSegmentDistance(p1, p2, q1, q2, ruler) {\n    const dist1 = Math.min(pointToLineDistance(p1, [q1, q2], ruler), pointToLineDistance(p2, [q1, q2], ruler));\n    const dist2 = Math.min(pointToLineDistance(q1, [p1, p2], ruler), pointToLineDistance(q2, [p1, p2], ruler));\n    return Math.min(dist1, dist2);\n}\nfunction lineToLineDistance(line1, range1, line2, range2, ruler) {\n    const rangeSafe = isRangeSafe(range1, line1.length) && isRangeSafe(range2, line2.length);\n    if (!rangeSafe) {\n        return Infinity;\n    }\n    let dist = Infinity;\n    for (let i = range1[0]; i < range1[1]; ++i) {\n        const p1 = line1[i];\n        const p2 = line1[i + 1];\n        for (let j = range2[0]; j < range2[1]; ++j) {\n            const q1 = line2[j];\n            const q2 = line2[j + 1];\n            if (segmentIntersectSegment(p1, p2, q1, q2)) {\n                return 0.0;\n            }\n            dist = Math.min(dist, segmentToSegmentDistance(p1, p2, q1, q2, ruler));\n        }\n    }\n    return dist;\n}\nfunction pointsToPointsDistance(points1, range1, points2, range2, ruler) {\n    const rangeSafe = isRangeSafe(range1, points1.length) && isRangeSafe(range2, points2.length);\n    if (!rangeSafe) {\n        return NaN;\n    }\n    let dist = Infinity;\n    for (let i = range1[0]; i <= range1[1]; ++i) {\n        for (let j = range2[0]; j <= range2[1]; ++j) {\n            dist = Math.min(dist, ruler.distance(points1[i], points2[j]));\n            if (dist === 0.0) {\n                return dist;\n            }\n        }\n    }\n    return dist;\n}\nfunction pointToPolygonDistance(point, polygon, ruler) {\n    if (pointWithinPolygon(point, polygon, true)) {\n        return 0.0;\n    }\n    let dist = Infinity;\n    for (const ring of polygon) {\n        const front = ring[0];\n        const back = ring[ring.length - 1];\n        if (front !== back) {\n            dist = Math.min(dist, pointToLineDistance(point, [back, front], ruler));\n            if (dist === 0.0) {\n                return dist;\n            }\n        }\n        const nearestPoint = ruler.pointOnLine(ring, point);\n        dist = Math.min(dist, ruler.distance(point, nearestPoint.point));\n        if (dist === 0.0) {\n            return dist;\n        }\n    }\n    return dist;\n}\nfunction lineToPolygonDistance(line, range, polygon, ruler) {\n    if (!isRangeSafe(range, line.length)) {\n        return NaN;\n    }\n    for (let i = range[0]; i <= range[1]; ++i) {\n        if (pointWithinPolygon(line[i], polygon, true)) {\n            return 0.0;\n        }\n    }\n    let dist = Infinity;\n    for (let i = range[0]; i < range[1]; ++i) {\n        const p1 = line[i];\n        const p2 = line[i + 1];\n        for (const ring of polygon) {\n            for (let j = 0, len = ring.length, k = len - 1; j < len; k = j++) {\n                const q1 = ring[k];\n                const q2 = ring[j];\n                if (segmentIntersectSegment(p1, p2, q1, q2)) {\n                    return 0.0;\n                }\n                dist = Math.min(dist, segmentToSegmentDistance(p1, p2, q1, q2, ruler));\n            }\n        }\n    }\n    return dist;\n}\nfunction polygonIntersect(poly1, poly2) {\n    for (const ring of poly1) {\n        for (const point of ring) {\n            if (pointWithinPolygon(point, poly2, true)) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\nfunction polygonToPolygonDistance(polygon1, polygon2, ruler, currentMiniDist = Infinity) {\n    const bbox1 = getPolygonBBox(polygon1);\n    const bbox2 = getPolygonBBox(polygon2);\n    if (currentMiniDist !== Infinity && bboxToBBoxDistance(bbox1, bbox2, ruler) >= currentMiniDist) {\n        return currentMiniDist;\n    }\n    if (boxWithinBox(bbox1, bbox2)) {\n        if (polygonIntersect(polygon1, polygon2)) {\n            return 0.0;\n        }\n    }\n    else if (polygonIntersect(polygon2, polygon1)) {\n        return 0.0;\n    }\n    let dist = Infinity;\n    for (const ring1 of polygon1) {\n        for (let i = 0, len1 = ring1.length, l = len1 - 1; i < len1; l = i++) {\n            const p1 = ring1[l];\n            const p2 = ring1[i];\n            for (const ring2 of polygon2) {\n                for (let j = 0, len2 = ring2.length, k = len2 - 1; j < len2; k = j++) {\n                    const q1 = ring2[k];\n                    const q2 = ring2[j];\n                    if (segmentIntersectSegment(p1, p2, q1, q2)) {\n                        return 0.0;\n                    }\n                    dist = Math.min(dist, segmentToSegmentDistance(p1, p2, q1, q2, ruler));\n                }\n            }\n        }\n    }\n    return dist;\n}\nfunction updateQueue(distQueue, miniDist, ruler, points, polyBBox, rangeA) {\n    if (!rangeA) {\n        return;\n    }\n    const tempDist = bboxToBBoxDistance(getBBox(points, rangeA), polyBBox, ruler);\n    // Insert new pair to the queue if the bbox distance is less than\n    // miniDist, The pair with biggest distance will be at the top\n    if (tempDist < miniDist) {\n        distQueue.push([tempDist, rangeA, [0, 0]]);\n    }\n}\nfunction updateQueueTwoSets(distQueue, miniDist, ruler, pointSet1, pointSet2, range1, range2) {\n    if (!range1 || !range2) {\n        return;\n    }\n    const tempDist = bboxToBBoxDistance(getBBox(pointSet1, range1), getBBox(pointSet2, range2), ruler);\n    // Insert new pair to the queue if the bbox distance is less than\n    // miniDist, The pair with biggest distance will be at the top\n    if (tempDist < miniDist) {\n        distQueue.push([tempDist, range1, range2]);\n    }\n}\n// Divide and conquer, the time complexity is O(n*lgn), faster than Brute force\n// O(n*n) Most of the time, use index for in-place processing.\nfunction pointsToPolygonDistance(points, isLine, polygon, ruler, currentMiniDist = Infinity) {\n    let miniDist = Math.min(ruler.distance(points[0], polygon[0][0]), currentMiniDist);\n    if (miniDist === 0.0) {\n        return miniDist;\n    }\n    const distQueue = new TinyQueue([[0, [0, points.length - 1], [0, 0]]], compareDistPair);\n    const polyBBox = getPolygonBBox(polygon);\n    while (distQueue.length > 0) {\n        const distPair = distQueue.pop();\n        if (distPair[0] >= miniDist) {\n            continue;\n        }\n        const range = distPair[1];\n        // In case the set size are relatively small, we could use brute-force directly\n        const threshold = isLine ? MinLinePointsSize : MinPointsSize;\n        if (getRangeSize(range) <= threshold) {\n            if (!isRangeSafe(range, points.length)) {\n                return NaN;\n            }\n            if (isLine) {\n                const tempDist = lineToPolygonDistance(points, range, polygon, ruler);\n                if (isNaN(tempDist) || tempDist === 0.0) {\n                    return tempDist;\n                }\n                miniDist = Math.min(miniDist, tempDist);\n            }\n            else {\n                for (let i = range[0]; i <= range[1]; ++i) {\n                    const tempDist = pointToPolygonDistance(points[i], polygon, ruler);\n                    miniDist = Math.min(miniDist, tempDist);\n                    if (miniDist === 0.0) {\n                        return 0.0;\n                    }\n                }\n            }\n        }\n        else {\n            const newRangesA = splitRange(range, isLine);\n            updateQueue(distQueue, miniDist, ruler, points, polyBBox, newRangesA[0]);\n            updateQueue(distQueue, miniDist, ruler, points, polyBBox, newRangesA[1]);\n        }\n    }\n    return miniDist;\n}\nfunction pointSetToPointSetDistance(pointSet1, isLine1, pointSet2, isLine2, ruler, currentMiniDist = Infinity) {\n    let miniDist = Math.min(currentMiniDist, ruler.distance(pointSet1[0], pointSet2[0]));\n    if (miniDist === 0.0) {\n        return miniDist;\n    }\n    const distQueue = new TinyQueue([[0, [0, pointSet1.length - 1], [0, pointSet2.length - 1]]], compareDistPair);\n    while (distQueue.length > 0) {\n        const distPair = distQueue.pop();\n        if (distPair[0] >= miniDist) {\n            continue;\n        }\n        const rangeA = distPair[1];\n        const rangeB = distPair[2];\n        const threshold1 = isLine1 ? MinLinePointsSize : MinPointsSize;\n        const threshold2 = isLine2 ? MinLinePointsSize : MinPointsSize;\n        // In case the set size are relatively small, we could use brute-force directly\n        if (getRangeSize(rangeA) <= threshold1 && getRangeSize(rangeB) <= threshold2) {\n            if (!isRangeSafe(rangeA, pointSet1.length) && isRangeSafe(rangeB, pointSet2.length)) {\n                return NaN;\n            }\n            let tempDist;\n            if (isLine1 && isLine2) {\n                tempDist = lineToLineDistance(pointSet1, rangeA, pointSet2, rangeB, ruler);\n                miniDist = Math.min(miniDist, tempDist);\n            }\n            else if (isLine1 && !isLine2) {\n                const sublibe = pointSet1.slice(rangeA[0], rangeA[1] + 1);\n                for (let i = rangeB[0]; i <= rangeB[1]; ++i) {\n                    tempDist = pointToLineDistance(pointSet2[i], sublibe, ruler);\n                    miniDist = Math.min(miniDist, tempDist);\n                    if (miniDist === 0.0) {\n                        return miniDist;\n                    }\n                }\n            }\n            else if (!isLine1 && isLine2) {\n                const sublibe = pointSet2.slice(rangeB[0], rangeB[1] + 1);\n                for (let i = rangeA[0]; i <= rangeA[1]; ++i) {\n                    tempDist = pointToLineDistance(pointSet1[i], sublibe, ruler);\n                    miniDist = Math.min(miniDist, tempDist);\n                    if (miniDist === 0.0) {\n                        return miniDist;\n                    }\n                }\n            }\n            else {\n                tempDist = pointsToPointsDistance(pointSet1, rangeA, pointSet2, rangeB, ruler);\n                miniDist = Math.min(miniDist, tempDist);\n            }\n        }\n        else {\n            const newRangesA = splitRange(rangeA, isLine1);\n            const newRangesB = splitRange(rangeB, isLine2);\n            updateQueueTwoSets(distQueue, miniDist, ruler, pointSet1, pointSet2, newRangesA[0], newRangesB[0]);\n            updateQueueTwoSets(distQueue, miniDist, ruler, pointSet1, pointSet2, newRangesA[0], newRangesB[1]);\n            updateQueueTwoSets(distQueue, miniDist, ruler, pointSet1, pointSet2, newRangesA[1], newRangesB[0]);\n            updateQueueTwoSets(distQueue, miniDist, ruler, pointSet1, pointSet2, newRangesA[1], newRangesB[1]);\n        }\n    }\n    return miniDist;\n}\nfunction pointToGeometryDistance(ctx, geometries) {\n    const tilePoints = ctx.geometry();\n    const pointPosition = tilePoints.flat().map(p => getLngLatFromTileCoord([p.x, p.y], ctx.canonical));\n    if (tilePoints.length === 0) {\n        return NaN;\n    }\n    const ruler = new CheapRuler(pointPosition[0][1]);\n    let dist = Infinity;\n    for (const geometry of geometries) {\n        switch (geometry.type) {\n            case 'Point':\n                dist = Math.min(dist, pointSetToPointSetDistance(pointPosition, false, [geometry.coordinates], false, ruler, dist));\n                break;\n            case 'LineString':\n                dist = Math.min(dist, pointSetToPointSetDistance(pointPosition, false, geometry.coordinates, true, ruler, dist));\n                break;\n            case 'Polygon':\n                dist = Math.min(dist, pointsToPolygonDistance(pointPosition, false, geometry.coordinates, ruler, dist));\n                break;\n        }\n        if (dist === 0.0) {\n            return dist;\n        }\n    }\n    return dist;\n}\nfunction lineStringToGeometryDistance(ctx, geometries) {\n    const tileLine = ctx.geometry();\n    const linePositions = tileLine.flat().map(p => getLngLatFromTileCoord([p.x, p.y], ctx.canonical));\n    if (tileLine.length === 0) {\n        return NaN;\n    }\n    const ruler = new CheapRuler(linePositions[0][1]);\n    let dist = Infinity;\n    for (const geometry of geometries) {\n        switch (geometry.type) {\n            case 'Point':\n                dist = Math.min(dist, pointSetToPointSetDistance(linePositions, true, [geometry.coordinates], false, ruler, dist));\n                break;\n            case 'LineString':\n                dist = Math.min(dist, pointSetToPointSetDistance(linePositions, true, geometry.coordinates, true, ruler, dist));\n                break;\n            case 'Polygon':\n                dist = Math.min(dist, pointsToPolygonDistance(linePositions, true, geometry.coordinates, ruler, dist));\n                break;\n        }\n        if (dist === 0.0) {\n            return dist;\n        }\n    }\n    return dist;\n}\nfunction polygonToGeometryDistance(ctx, geometries) {\n    const tilePolygon = ctx.geometry();\n    if (tilePolygon.length === 0 || tilePolygon[0].length === 0) {\n        return NaN;\n    }\n    const polygons = classifyRings(tilePolygon, 0).map(polygon => {\n        return polygon.map(ring => {\n            return ring.map(p => getLngLatFromTileCoord([p.x, p.y], ctx.canonical));\n        });\n    });\n    const ruler = new CheapRuler(polygons[0][0][0][1]);\n    let dist = Infinity;\n    for (const geometry of geometries) {\n        for (const polygon of polygons) {\n            switch (geometry.type) {\n                case 'Point':\n                    dist = Math.min(dist, pointsToPolygonDistance([geometry.coordinates], false, polygon, ruler, dist));\n                    break;\n                case 'LineString':\n                    dist = Math.min(dist, pointsToPolygonDistance(geometry.coordinates, true, polygon, ruler, dist));\n                    break;\n                case 'Polygon':\n                    dist = Math.min(dist, polygonToPolygonDistance(polygon, geometry.coordinates, ruler, dist));\n                    break;\n            }\n            if (dist === 0.0) {\n                return dist;\n            }\n        }\n    }\n    return dist;\n}\nfunction toSimpleGeometry(geometry) {\n    if (geometry.type === 'MultiPolygon') {\n        return geometry.coordinates.map(polygon => {\n            return {\n                type: 'Polygon',\n                coordinates: polygon\n            };\n        });\n    }\n    if (geometry.type === 'MultiLineString') {\n        return geometry.coordinates.map(lineString => {\n            return {\n                type: 'LineString',\n                coordinates: lineString\n            };\n        });\n    }\n    if (geometry.type === 'MultiPoint') {\n        return geometry.coordinates.map(point => {\n            return {\n                type: 'Point',\n                coordinates: point\n            };\n        });\n    }\n    return [geometry];\n}\nclass Distance {\n    constructor(geojson, geometries) {\n        this.type = NumberType;\n        this.geojson = geojson;\n        this.geometries = geometries;\n    }\n    static parse(args, context) {\n        if (args.length !== 2)\n            return context.error(`'distance' expression requires exactly one argument, but found ${args.length - 1} instead.`);\n        if (isValue(args[1])) {\n            const geojson = args[1];\n            if (geojson.type === 'FeatureCollection') {\n                return new Distance(geojson, geojson.features.map(feature => toSimpleGeometry(feature.geometry)).flat());\n            }\n            else if (geojson.type === 'Feature') {\n                return new Distance(geojson, toSimpleGeometry(geojson.geometry));\n            }\n            else if ('type' in geojson && 'coordinates' in geojson) {\n                return new Distance(geojson, toSimpleGeometry(geojson));\n            }\n        }\n        return context.error('\\'distance\\' expression requires valid geojson object that contains polygon geometry type.');\n    }\n    evaluate(ctx) {\n        if (ctx.geometry() != null && ctx.canonicalID() != null) {\n            if (ctx.geometryType() === 'Point') {\n                return pointToGeometryDistance(ctx, this.geometries);\n            }\n            else if (ctx.geometryType() === 'LineString') {\n                return lineStringToGeometryDistance(ctx, this.geometries);\n            }\n            else if (ctx.geometryType() === 'Polygon') {\n                return polygonToGeometryDistance(ctx, this.geometries);\n            }\n        }\n        return NaN;\n    }\n    eachChild() { }\n    outputDefined() {\n        return true;\n    }\n}\n\nconst expressions$1 = {\n    // special forms\n    '==': Equals,\n    '!=': NotEquals,\n    '>': GreaterThan,\n    '<': LessThan,\n    '>=': GreaterThanOrEqual,\n    '<=': LessThanOrEqual,\n    'array': Assertion,\n    'at': At,\n    'boolean': Assertion,\n    'case': Case,\n    'coalesce': Coalesce,\n    'collator': CollatorExpression,\n    'format': FormatExpression,\n    'image': ImageExpression,\n    'in': In,\n    'index-of': IndexOf,\n    'interpolate': Interpolate,\n    'interpolate-hcl': Interpolate,\n    'interpolate-lab': Interpolate,\n    'length': Length,\n    'let': Let,\n    'literal': Literal,\n    'match': Match,\n    'number': Assertion,\n    'number-format': NumberFormat,\n    'object': Assertion,\n    'slice': Slice,\n    'step': Step,\n    'string': Assertion,\n    'to-boolean': Coercion,\n    'to-color': Coercion,\n    'to-number': Coercion,\n    'to-string': Coercion,\n    'var': Var,\n    'within': Within,\n    'distance': Distance\n};\n\nclass CompoundExpression {\n    constructor(name, type, evaluate, args) {\n        this.name = name;\n        this.type = type;\n        this._evaluate = evaluate;\n        this.args = args;\n    }\n    evaluate(ctx) {\n        return this._evaluate(ctx, this.args);\n    }\n    eachChild(fn) {\n        this.args.forEach(fn);\n    }\n    outputDefined() {\n        return false;\n    }\n    static parse(args, context) {\n        const op = args[0];\n        const definition = CompoundExpression.definitions[op];\n        if (!definition) {\n            return context.error(`Unknown expression \"${op}\". If you wanted a literal array, use [\"literal\", [...]].`, 0);\n        }\n        // Now check argument types against each signature\n        const type = Array.isArray(definition) ?\n            definition[0] : definition.type;\n        const availableOverloads = Array.isArray(definition) ?\n            [[definition[1], definition[2]]] :\n            definition.overloads;\n        const overloads = availableOverloads.filter(([signature]) => (!Array.isArray(signature) || // varags\n            signature.length === args.length - 1 // correct param count\n        ));\n        let signatureContext = null;\n        for (const [params, evaluate] of overloads) {\n            // Use a fresh context for each attempted signature so that, if\n            // we eventually succeed, we haven't polluted `context.errors`.\n            signatureContext = new ParsingContext(context.registry, isExpressionConstant, context.path, null, context.scope);\n            // First parse all the args, potentially coercing to the\n            // types expected by this overload.\n            const parsedArgs = [];\n            let argParseFailed = false;\n            for (let i = 1; i < args.length; i++) {\n                const arg = args[i];\n                const expectedType = Array.isArray(params) ?\n                    params[i - 1] :\n                    params.type;\n                const parsed = signatureContext.parse(arg, 1 + parsedArgs.length, expectedType);\n                if (!parsed) {\n                    argParseFailed = true;\n                    break;\n                }\n                parsedArgs.push(parsed);\n            }\n            if (argParseFailed) {\n                // Couldn't coerce args of this overload to expected type, move\n                // on to next one.\n                continue;\n            }\n            if (Array.isArray(params)) {\n                if (params.length !== parsedArgs.length) {\n                    signatureContext.error(`Expected ${params.length} arguments, but found ${parsedArgs.length} instead.`);\n                    continue;\n                }\n            }\n            for (let i = 0; i < parsedArgs.length; i++) {\n                const expected = Array.isArray(params) ? params[i] : params.type;\n                const arg = parsedArgs[i];\n                signatureContext.concat(i + 1).checkSubtype(expected, arg.type);\n            }\n            if (signatureContext.errors.length === 0) {\n                return new CompoundExpression(op, type, evaluate, parsedArgs);\n            }\n        }\n        if (overloads.length === 1) {\n            context.errors.push(...signatureContext.errors);\n        }\n        else {\n            const expected = overloads.length ? overloads : availableOverloads;\n            const signatures = expected\n                .map(([params]) => stringifySignature(params))\n                .join(' | ');\n            const actualTypes = [];\n            // For error message, re-parse arguments without trying to\n            // apply any coercions\n            for (let i = 1; i < args.length; i++) {\n                const parsed = context.parse(args[i], 1 + actualTypes.length);\n                if (!parsed)\n                    return null;\n                actualTypes.push(typeToString(parsed.type));\n            }\n            context.error(`Expected arguments of type ${signatures}, but found (${actualTypes.join(', ')}) instead.`);\n        }\n        return null;\n    }\n    static register(registry, definitions) {\n        CompoundExpression.definitions = definitions;\n        for (const name in definitions) {\n            registry[name] = CompoundExpression;\n        }\n    }\n}\nfunction rgba(ctx, [r, g, b, a]) {\n    r = r.evaluate(ctx);\n    g = g.evaluate(ctx);\n    b = b.evaluate(ctx);\n    const alpha = a ? a.evaluate(ctx) : 1;\n    const error = validateRGBA(r, g, b, alpha);\n    if (error)\n        throw new RuntimeError(error);\n    return new Color(r / 255, g / 255, b / 255, alpha, false);\n}\nfunction has(key, obj) {\n    return key in obj;\n}\nfunction get(key, obj) {\n    const v = obj[key];\n    return typeof v === 'undefined' ? null : v;\n}\nfunction binarySearch(v, a, i, j) {\n    while (i <= j) {\n        const m = (i + j) >> 1;\n        if (a[m] === v)\n            return true;\n        if (a[m] > v)\n            j = m - 1;\n        else\n            i = m + 1;\n    }\n    return false;\n}\nfunction varargs(type) {\n    return { type };\n}\nCompoundExpression.register(expressions$1, {\n    'error': [\n        ErrorType,\n        [StringType],\n        (ctx, [v]) => { throw new RuntimeError(v.evaluate(ctx)); }\n    ],\n    'typeof': [\n        StringType,\n        [ValueType],\n        (ctx, [v]) => typeToString(typeOf(v.evaluate(ctx)))\n    ],\n    'to-rgba': [\n        array(NumberType, 4),\n        [ColorType],\n        (ctx, [v]) => {\n            const [r, g, b, a] = v.evaluate(ctx).rgb;\n            return [r * 255, g * 255, b * 255, a];\n        },\n    ],\n    'rgb': [\n        ColorType,\n        [NumberType, NumberType, NumberType],\n        rgba\n    ],\n    'rgba': [\n        ColorType,\n        [NumberType, NumberType, NumberType, NumberType],\n        rgba\n    ],\n    'has': {\n        type: BooleanType,\n        overloads: [\n            [\n                [StringType],\n                (ctx, [key]) => has(key.evaluate(ctx), ctx.properties())\n            ], [\n                [StringType, ObjectType],\n                (ctx, [key, obj]) => has(key.evaluate(ctx), obj.evaluate(ctx))\n            ]\n        ]\n    },\n    'get': {\n        type: ValueType,\n        overloads: [\n            [\n                [StringType],\n                (ctx, [key]) => get(key.evaluate(ctx), ctx.properties())\n            ], [\n                [StringType, ObjectType],\n                (ctx, [key, obj]) => get(key.evaluate(ctx), obj.evaluate(ctx))\n            ]\n        ]\n    },\n    'feature-state': [\n        ValueType,\n        [StringType],\n        (ctx, [key]) => get(key.evaluate(ctx), ctx.featureState || {})\n    ],\n    'properties': [\n        ObjectType,\n        [],\n        (ctx) => ctx.properties()\n    ],\n    'geometry-type': [\n        StringType,\n        [],\n        (ctx) => ctx.geometryType()\n    ],\n    'id': [\n        ValueType,\n        [],\n        (ctx) => ctx.id()\n    ],\n    'zoom': [\n        NumberType,\n        [],\n        (ctx) => ctx.globals.zoom\n    ],\n    'heatmap-density': [\n        NumberType,\n        [],\n        (ctx) => ctx.globals.heatmapDensity || 0\n    ],\n    'line-progress': [\n        NumberType,\n        [],\n        (ctx) => ctx.globals.lineProgress || 0\n    ],\n    'accumulated': [\n        ValueType,\n        [],\n        (ctx) => ctx.globals.accumulated === undefined ? null : ctx.globals.accumulated\n    ],\n    '+': [\n        NumberType,\n        varargs(NumberType),\n        (ctx, args) => {\n            let result = 0;\n            for (const arg of args) {\n                result += arg.evaluate(ctx);\n            }\n            return result;\n        }\n    ],\n    '*': [\n        NumberType,\n        varargs(NumberType),\n        (ctx, args) => {\n            let result = 1;\n            for (const arg of args) {\n                result *= arg.evaluate(ctx);\n            }\n            return result;\n        }\n    ],\n    '-': {\n        type: NumberType,\n        overloads: [\n            [\n                [NumberType, NumberType],\n                (ctx, [a, b]) => a.evaluate(ctx) - b.evaluate(ctx)\n            ], [\n                [NumberType],\n                (ctx, [a]) => -a.evaluate(ctx)\n            ]\n        ]\n    },\n    '/': [\n        NumberType,\n        [NumberType, NumberType],\n        (ctx, [a, b]) => a.evaluate(ctx) / b.evaluate(ctx)\n    ],\n    '%': [\n        NumberType,\n        [NumberType, NumberType],\n        (ctx, [a, b]) => a.evaluate(ctx) % b.evaluate(ctx)\n    ],\n    'ln2': [\n        NumberType,\n        [],\n        () => Math.LN2\n    ],\n    'pi': [\n        NumberType,\n        [],\n        () => Math.PI\n    ],\n    'e': [\n        NumberType,\n        [],\n        () => Math.E\n    ],\n    '^': [\n        NumberType,\n        [NumberType, NumberType],\n        (ctx, [b, e]) => Math.pow(b.evaluate(ctx), e.evaluate(ctx))\n    ],\n    'sqrt': [\n        NumberType,\n        [NumberType],\n        (ctx, [x]) => Math.sqrt(x.evaluate(ctx))\n    ],\n    'log10': [\n        NumberType,\n        [NumberType],\n        (ctx, [n]) => Math.log(n.evaluate(ctx)) / Math.LN10\n    ],\n    'ln': [\n        NumberType,\n        [NumberType],\n        (ctx, [n]) => Math.log(n.evaluate(ctx))\n    ],\n    'log2': [\n        NumberType,\n        [NumberType],\n        (ctx, [n]) => Math.log(n.evaluate(ctx)) / Math.LN2\n    ],\n    'sin': [\n        NumberType,\n        [NumberType],\n        (ctx, [n]) => Math.sin(n.evaluate(ctx))\n    ],\n    'cos': [\n        NumberType,\n        [NumberType],\n        (ctx, [n]) => Math.cos(n.evaluate(ctx))\n    ],\n    'tan': [\n        NumberType,\n        [NumberType],\n        (ctx, [n]) => Math.tan(n.evaluate(ctx))\n    ],\n    'asin': [\n        NumberType,\n        [NumberType],\n        (ctx, [n]) => Math.asin(n.evaluate(ctx))\n    ],\n    'acos': [\n        NumberType,\n        [NumberType],\n        (ctx, [n]) => Math.acos(n.evaluate(ctx))\n    ],\n    'atan': [\n        NumberType,\n        [NumberType],\n        (ctx, [n]) => Math.atan(n.evaluate(ctx))\n    ],\n    'min': [\n        NumberType,\n        varargs(NumberType),\n        (ctx, args) => Math.min(...args.map(arg => arg.evaluate(ctx)))\n    ],\n    'max': [\n        NumberType,\n        varargs(NumberType),\n        (ctx, args) => Math.max(...args.map(arg => arg.evaluate(ctx)))\n    ],\n    'abs': [\n        NumberType,\n        [NumberType],\n        (ctx, [n]) => Math.abs(n.evaluate(ctx))\n    ],\n    'round': [\n        NumberType,\n        [NumberType],\n        (ctx, [n]) => {\n            const v = n.evaluate(ctx);\n            // Javascript's Math.round() rounds towards +Infinity for halfway\n            // values, even when they're negative. It's more common to round\n            // away from 0 (e.g., this is what python and C++ do)\n            return v < 0 ? -Math.round(-v) : Math.round(v);\n        }\n    ],\n    'floor': [\n        NumberType,\n        [NumberType],\n        (ctx, [n]) => Math.floor(n.evaluate(ctx))\n    ],\n    'ceil': [\n        NumberType,\n        [NumberType],\n        (ctx, [n]) => Math.ceil(n.evaluate(ctx))\n    ],\n    'filter-==': [\n        BooleanType,\n        [StringType, ValueType],\n        (ctx, [k, v]) => ctx.properties()[k.value] === v.value\n    ],\n    'filter-id-==': [\n        BooleanType,\n        [ValueType],\n        (ctx, [v]) => ctx.id() === v.value\n    ],\n    'filter-type-==': [\n        BooleanType,\n        [StringType],\n        (ctx, [v]) => ctx.geometryDollarType() === v.value\n    ],\n    'filter-<': [\n        BooleanType,\n        [StringType, ValueType],\n        (ctx, [k, v]) => {\n            const a = ctx.properties()[k.value];\n            const b = v.value;\n            return typeof a === typeof b && a < b;\n        }\n    ],\n    'filter-id-<': [\n        BooleanType,\n        [ValueType],\n        (ctx, [v]) => {\n            const a = ctx.id();\n            const b = v.value;\n            return typeof a === typeof b && a < b;\n        }\n    ],\n    'filter->': [\n        BooleanType,\n        [StringType, ValueType],\n        (ctx, [k, v]) => {\n            const a = ctx.properties()[k.value];\n            const b = v.value;\n            return typeof a === typeof b && a > b;\n        }\n    ],\n    'filter-id->': [\n        BooleanType,\n        [ValueType],\n        (ctx, [v]) => {\n            const a = ctx.id();\n            const b = v.value;\n            return typeof a === typeof b && a > b;\n        }\n    ],\n    'filter-<=': [\n        BooleanType,\n        [StringType, ValueType],\n        (ctx, [k, v]) => {\n            const a = ctx.properties()[k.value];\n            const b = v.value;\n            return typeof a === typeof b && a <= b;\n        }\n    ],\n    'filter-id-<=': [\n        BooleanType,\n        [ValueType],\n        (ctx, [v]) => {\n            const a = ctx.id();\n            const b = v.value;\n            return typeof a === typeof b && a <= b;\n        }\n    ],\n    'filter->=': [\n        BooleanType,\n        [StringType, ValueType],\n        (ctx, [k, v]) => {\n            const a = ctx.properties()[k.value];\n            const b = v.value;\n            return typeof a === typeof b && a >= b;\n        }\n    ],\n    'filter-id->=': [\n        BooleanType,\n        [ValueType],\n        (ctx, [v]) => {\n            const a = ctx.id();\n            const b = v.value;\n            return typeof a === typeof b && a >= b;\n        }\n    ],\n    'filter-has': [\n        BooleanType,\n        [ValueType],\n        (ctx, [k]) => k.value in ctx.properties()\n    ],\n    'filter-has-id': [\n        BooleanType,\n        [],\n        (ctx) => (ctx.id() !== null && ctx.id() !== undefined)\n    ],\n    'filter-type-in': [\n        BooleanType,\n        [array(StringType)],\n        (ctx, [v]) => v.value.indexOf(ctx.geometryDollarType()) >= 0\n    ],\n    'filter-id-in': [\n        BooleanType,\n        [array(ValueType)],\n        (ctx, [v]) => v.value.indexOf(ctx.id()) >= 0\n    ],\n    'filter-in-small': [\n        BooleanType,\n        [StringType, array(ValueType)],\n        // assumes v is an array literal\n        (ctx, [k, v]) => v.value.indexOf(ctx.properties()[k.value]) >= 0\n    ],\n    'filter-in-large': [\n        BooleanType,\n        [StringType, array(ValueType)],\n        // assumes v is a array literal with values sorted in ascending order and of a single type\n        (ctx, [k, v]) => binarySearch(ctx.properties()[k.value], v.value, 0, v.value.length - 1)\n    ],\n    'all': {\n        type: BooleanType,\n        overloads: [\n            [\n                [BooleanType, BooleanType],\n                (ctx, [a, b]) => a.evaluate(ctx) && b.evaluate(ctx)\n            ],\n            [\n                varargs(BooleanType),\n                (ctx, args) => {\n                    for (const arg of args) {\n                        if (!arg.evaluate(ctx))\n                            return false;\n                    }\n                    return true;\n                }\n            ]\n        ]\n    },\n    'any': {\n        type: BooleanType,\n        overloads: [\n            [\n                [BooleanType, BooleanType],\n                (ctx, [a, b]) => a.evaluate(ctx) || b.evaluate(ctx)\n            ],\n            [\n                varargs(BooleanType),\n                (ctx, args) => {\n                    for (const arg of args) {\n                        if (arg.evaluate(ctx))\n                            return true;\n                    }\n                    return false;\n                }\n            ]\n        ]\n    },\n    '!': [\n        BooleanType,\n        [BooleanType],\n        (ctx, [b]) => !b.evaluate(ctx)\n    ],\n    'is-supported-script': [\n        BooleanType,\n        [StringType],\n        // At parse time this will always return true, so we need to exclude this expression with isGlobalPropertyConstant\n        (ctx, [s]) => {\n            const isSupportedScript = ctx.globals && ctx.globals.isSupportedScript;\n            if (isSupportedScript) {\n                return isSupportedScript(s.evaluate(ctx));\n            }\n            return true;\n        }\n    ],\n    'upcase': [\n        StringType,\n        [StringType],\n        (ctx, [s]) => s.evaluate(ctx).toUpperCase()\n    ],\n    'downcase': [\n        StringType,\n        [StringType],\n        (ctx, [s]) => s.evaluate(ctx).toLowerCase()\n    ],\n    'concat': [\n        StringType,\n        varargs(ValueType),\n        (ctx, args) => args.map(arg => valueToString(arg.evaluate(ctx))).join('')\n    ],\n    'resolved-locale': [\n        StringType,\n        [CollatorType],\n        (ctx, [collator]) => collator.evaluate(ctx).resolvedLocale()\n    ]\n});\nfunction stringifySignature(signature) {\n    if (Array.isArray(signature)) {\n        return `(${signature.map(typeToString).join(', ')})`;\n    }\n    else {\n        return `(${typeToString(signature.type)}...)`;\n    }\n}\nfunction isExpressionConstant(expression) {\n    if (expression instanceof Var) {\n        return isExpressionConstant(expression.boundExpression);\n    }\n    else if (expression instanceof CompoundExpression && expression.name === 'error') {\n        return false;\n    }\n    else if (expression instanceof CollatorExpression) {\n        // Although the results of a Collator expression with fixed arguments\n        // generally shouldn't change between executions, we can't serialize them\n        // as constant expressions because results change based on environment.\n        return false;\n    }\n    else if (expression instanceof Within) {\n        return false;\n    }\n    else if (expression instanceof Distance) {\n        return false;\n    }\n    const isTypeAnnotation = expression instanceof Coercion ||\n        expression instanceof Assertion;\n    let childrenConstant = true;\n    expression.eachChild(child => {\n        // We can _almost_ assume that if `expressions` children are constant,\n        // they would already have been evaluated to Literal values when they\n        // were parsed.  Type annotations are the exception, because they might\n        // have been inferred and added after a child was parsed.\n        // So we recurse into isConstant() for the children of type annotations,\n        // but otherwise simply check whether they are Literals.\n        if (isTypeAnnotation) {\n            childrenConstant = childrenConstant && isExpressionConstant(child);\n        }\n        else {\n            childrenConstant = childrenConstant && child instanceof Literal;\n        }\n    });\n    if (!childrenConstant) {\n        return false;\n    }\n    return isFeatureConstant(expression) &&\n        isGlobalPropertyConstant(expression, ['zoom', 'heatmap-density', 'line-progress', 'accumulated', 'is-supported-script']);\n}\nfunction isFeatureConstant(e) {\n    if (e instanceof CompoundExpression) {\n        if (e.name === 'get' && e.args.length === 1) {\n            return false;\n        }\n        else if (e.name === 'feature-state') {\n            return false;\n        }\n        else if (e.name === 'has' && e.args.length === 1) {\n            return false;\n        }\n        else if (e.name === 'properties' ||\n            e.name === 'geometry-type' ||\n            e.name === 'id') {\n            return false;\n        }\n        else if (/^filter-/.test(e.name)) {\n            return false;\n        }\n    }\n    if (e instanceof Within) {\n        return false;\n    }\n    if (e instanceof Distance) {\n        return false;\n    }\n    let result = true;\n    e.eachChild(arg => {\n        if (result && !isFeatureConstant(arg)) {\n            result = false;\n        }\n    });\n    return result;\n}\nfunction isStateConstant(e) {\n    if (e instanceof CompoundExpression) {\n        if (e.name === 'feature-state') {\n            return false;\n        }\n    }\n    let result = true;\n    e.eachChild(arg => {\n        if (result && !isStateConstant(arg)) {\n            result = false;\n        }\n    });\n    return result;\n}\nfunction isGlobalPropertyConstant(e, properties) {\n    if (e instanceof CompoundExpression && properties.indexOf(e.name) >= 0) {\n        return false;\n    }\n    let result = true;\n    e.eachChild((arg) => {\n        if (result && !isGlobalPropertyConstant(arg, properties)) {\n            result = false;\n        }\n    });\n    return result;\n}\n\nfunction success(value) {\n    return { result: 'success', value };\n}\nfunction error(value) {\n    return { result: 'error', value };\n}\n\nfunction supportsPropertyExpression(spec) {\n    return spec['property-type'] === 'data-driven' || spec['property-type'] === 'cross-faded-data-driven';\n}\nfunction supportsZoomExpression(spec) {\n    return !!spec.expression && spec.expression.parameters.indexOf('zoom') > -1;\n}\nfunction supportsInterpolation(spec) {\n    return !!spec.expression && spec.expression.interpolated;\n}\n\nfunction getType(val) {\n    if (val instanceof Number) {\n        return 'number';\n    }\n    else if (val instanceof String) {\n        return 'string';\n    }\n    else if (val instanceof Boolean) {\n        return 'boolean';\n    }\n    else if (Array.isArray(val)) {\n        return 'array';\n    }\n    else if (val === null) {\n        return 'null';\n    }\n    else {\n        return typeof val;\n    }\n}\n\nfunction isFunction$1(value) {\n    return typeof value === 'object' && value !== null && !Array.isArray(value);\n}\nfunction identityFunction(x) {\n    return x;\n}\nfunction createFunction(parameters, propertySpec) {\n    const isColor = propertySpec.type === 'color';\n    const zoomAndFeatureDependent = parameters.stops && typeof parameters.stops[0][0] === 'object';\n    const featureDependent = zoomAndFeatureDependent || parameters.property !== undefined;\n    const zoomDependent = zoomAndFeatureDependent || !featureDependent;\n    const type = parameters.type || (supportsInterpolation(propertySpec) ? 'exponential' : 'interval');\n    if (isColor || propertySpec.type === 'padding') {\n        const parseFn = isColor ? Color.parse : Padding.parse;\n        parameters = extendBy({}, parameters);\n        if (parameters.stops) {\n            parameters.stops = parameters.stops.map((stop) => {\n                return [stop[0], parseFn(stop[1])];\n            });\n        }\n        if (parameters.default) {\n            parameters.default = parseFn(parameters.default);\n        }\n        else {\n            parameters.default = parseFn(propertySpec.default);\n        }\n    }\n    if (parameters.colorSpace && !isSupportedInterpolationColorSpace(parameters.colorSpace)) {\n        throw new Error(`Unknown color space: \"${parameters.colorSpace}\"`);\n    }\n    let innerFun;\n    let hashedStops;\n    let categoricalKeyType;\n    if (type === 'exponential') {\n        innerFun = evaluateExponentialFunction;\n    }\n    else if (type === 'interval') {\n        innerFun = evaluateIntervalFunction;\n    }\n    else if (type === 'categorical') {\n        innerFun = evaluateCategoricalFunction;\n        // For categorical functions, generate an Object as a hashmap of the stops for fast searching\n        hashedStops = Object.create(null);\n        for (const stop of parameters.stops) {\n            hashedStops[stop[0]] = stop[1];\n        }\n        // Infer key type based on first stop key-- used to encforce strict type checking later\n        categoricalKeyType = typeof parameters.stops[0][0];\n    }\n    else if (type === 'identity') {\n        innerFun = evaluateIdentityFunction;\n    }\n    else {\n        throw new Error(`Unknown function type \"${type}\"`);\n    }\n    if (zoomAndFeatureDependent) {\n        const featureFunctions = {};\n        const zoomStops = [];\n        for (let s = 0; s < parameters.stops.length; s++) {\n            const stop = parameters.stops[s];\n            const zoom = stop[0].zoom;\n            if (featureFunctions[zoom] === undefined) {\n                featureFunctions[zoom] = {\n                    zoom,\n                    type: parameters.type,\n                    property: parameters.property,\n                    default: parameters.default,\n                    stops: []\n                };\n                zoomStops.push(zoom);\n            }\n            featureFunctions[zoom].stops.push([stop[0].value, stop[1]]);\n        }\n        const featureFunctionStops = [];\n        for (const z of zoomStops) {\n            featureFunctionStops.push([featureFunctions[z].zoom, createFunction(featureFunctions[z], propertySpec)]);\n        }\n        const interpolationType = { name: 'linear' };\n        return {\n            kind: 'composite',\n            interpolationType,\n            interpolationFactor: Interpolate.interpolationFactor.bind(undefined, interpolationType),\n            zoomStops: featureFunctionStops.map(s => s[0]),\n            evaluate({ zoom }, properties) {\n                return evaluateExponentialFunction({\n                    stops: featureFunctionStops,\n                    base: parameters.base\n                }, propertySpec, zoom).evaluate(zoom, properties);\n            }\n        };\n    }\n    else if (zoomDependent) {\n        const interpolationType = type === 'exponential' ?\n            { name: 'exponential', base: parameters.base !== undefined ? parameters.base : 1 } : null;\n        return {\n            kind: 'camera',\n            interpolationType,\n            interpolationFactor: Interpolate.interpolationFactor.bind(undefined, interpolationType),\n            zoomStops: parameters.stops.map(s => s[0]),\n            evaluate: ({ zoom }) => innerFun(parameters, propertySpec, zoom, hashedStops, categoricalKeyType)\n        };\n    }\n    else {\n        return {\n            kind: 'source',\n            evaluate(_, feature) {\n                const value = feature && feature.properties ? feature.properties[parameters.property] : undefined;\n                if (value === undefined) {\n                    return coalesce$1(parameters.default, propertySpec.default);\n                }\n                return innerFun(parameters, propertySpec, value, hashedStops, categoricalKeyType);\n            }\n        };\n    }\n}\nfunction coalesce$1(a, b, c) {\n    if (a !== undefined)\n        return a;\n    if (b !== undefined)\n        return b;\n    if (c !== undefined)\n        return c;\n}\nfunction evaluateCategoricalFunction(parameters, propertySpec, input, hashedStops, keyType) {\n    const evaluated = typeof input === keyType ? hashedStops[input] : undefined; // Enforce strict typing on input\n    return coalesce$1(evaluated, parameters.default, propertySpec.default);\n}\nfunction evaluateIntervalFunction(parameters, propertySpec, input) {\n    // Edge cases\n    if (getType(input) !== 'number')\n        return coalesce$1(parameters.default, propertySpec.default);\n    const n = parameters.stops.length;\n    if (n === 1)\n        return parameters.stops[0][1];\n    if (input <= parameters.stops[0][0])\n        return parameters.stops[0][1];\n    if (input >= parameters.stops[n - 1][0])\n        return parameters.stops[n - 1][1];\n    const index = findStopLessThanOrEqualTo(parameters.stops.map((stop) => stop[0]), input);\n    return parameters.stops[index][1];\n}\nfunction evaluateExponentialFunction(parameters, propertySpec, input) {\n    const base = parameters.base !== undefined ? parameters.base : 1;\n    // Edge cases\n    if (getType(input) !== 'number')\n        return coalesce$1(parameters.default, propertySpec.default);\n    const n = parameters.stops.length;\n    if (n === 1)\n        return parameters.stops[0][1];\n    if (input <= parameters.stops[0][0])\n        return parameters.stops[0][1];\n    if (input >= parameters.stops[n - 1][0])\n        return parameters.stops[n - 1][1];\n    const index = findStopLessThanOrEqualTo(parameters.stops.map((stop) => stop[0]), input);\n    const t = interpolationFactor(input, base, parameters.stops[index][0], parameters.stops[index + 1][0]);\n    const outputLower = parameters.stops[index][1];\n    const outputUpper = parameters.stops[index + 1][1];\n    const interp = interpolateFactory[propertySpec.type] || identityFunction;\n    if (typeof outputLower.evaluate === 'function') {\n        return {\n            evaluate(...args) {\n                const evaluatedLower = outputLower.evaluate.apply(undefined, args);\n                const evaluatedUpper = outputUpper.evaluate.apply(undefined, args);\n                // Special case for fill-outline-color, which has no spec default.\n                if (evaluatedLower === undefined || evaluatedUpper === undefined) {\n                    return undefined;\n                }\n                return interp(evaluatedLower, evaluatedUpper, t, parameters.colorSpace);\n            }\n        };\n    }\n    return interp(outputLower, outputUpper, t, parameters.colorSpace);\n}\nfunction evaluateIdentityFunction(parameters, propertySpec, input) {\n    switch (propertySpec.type) {\n        case 'color':\n            input = Color.parse(input);\n            break;\n        case 'formatted':\n            input = Formatted.fromString(input.toString());\n            break;\n        case 'resolvedImage':\n            input = ResolvedImage.fromString(input.toString());\n            break;\n        case 'padding':\n            input = Padding.parse(input);\n            break;\n        default:\n            if (getType(input) !== propertySpec.type && (propertySpec.type !== 'enum' || !propertySpec.values[input])) {\n                input = undefined;\n            }\n    }\n    return coalesce$1(input, parameters.default, propertySpec.default);\n}\n/**\n * Returns a ratio that can be used to interpolate between exponential function\n * stops.\n *\n * How it works:\n * Two consecutive stop values define a (scaled and shifted) exponential\n * function `f(x) = a * base^x + b`, where `base` is the user-specified base,\n * and `a` and `b` are constants affording sufficient degrees of freedom to fit\n * the function to the given stops.\n *\n * Here's a bit of algebra that lets us compute `f(x)` directly from the stop\n * values without explicitly solving for `a` and `b`:\n *\n * First stop value: `f(x0) = y0 = a * base^x0 + b`\n * Second stop value: `f(x1) = y1 = a * base^x1 + b`\n * => `y1 - y0 = a(base^x1 - base^x0)`\n * => `a = (y1 - y0)/(base^x1 - base^x0)`\n *\n * Desired value: `f(x) = y = a * base^x + b`\n * => `f(x) = y0 + a * (base^x - base^x0)`\n *\n * From the above, we can replace the `a` in `a * (base^x - base^x0)` and do a\n * little algebra:\n * ```\n * a * (base^x - base^x0) = (y1 - y0)/(base^x1 - base^x0) * (base^x - base^x0)\n *                     = (y1 - y0) * (base^x - base^x0) / (base^x1 - base^x0)\n * ```\n *\n * If we let `(base^x - base^x0) / (base^x1 base^x0)`, then we have\n * `f(x) = y0 + (y1 - y0) * ratio`.  In other words, `ratio` may be treated as\n * an interpolation factor between the two stops' output values.\n *\n * (Note: a slightly different form for `ratio`,\n * `(base^(x-x0) - 1) / (base^(x1-x0) - 1) `, is equivalent, but requires fewer\n * expensive `Math.pow()` operations.)\n *\n * @private\n */\nfunction interpolationFactor(input, base, lowerValue, upperValue) {\n    const difference = upperValue - lowerValue;\n    const progress = input - lowerValue;\n    if (difference === 0) {\n        return 0;\n    }\n    else if (base === 1) {\n        return progress / difference;\n    }\n    else {\n        return (Math.pow(base, progress) - 1) / (Math.pow(base, difference) - 1);\n    }\n}\n\nclass StyleExpression {\n    constructor(expression, propertySpec) {\n        this.expression = expression;\n        this._warningHistory = {};\n        this._evaluator = new EvaluationContext();\n        this._defaultValue = propertySpec ? getDefaultValue(propertySpec) : null;\n        this._enumValues = propertySpec && propertySpec.type === 'enum' ? propertySpec.values : null;\n    }\n    evaluateWithoutErrorHandling(globals, feature, featureState, canonical, availableImages, formattedSection) {\n        this._evaluator.globals = globals;\n        this._evaluator.feature = feature;\n        this._evaluator.featureState = featureState;\n        this._evaluator.canonical = canonical;\n        this._evaluator.availableImages = availableImages || null;\n        this._evaluator.formattedSection = formattedSection;\n        return this.expression.evaluate(this._evaluator);\n    }\n    evaluate(globals, feature, featureState, canonical, availableImages, formattedSection) {\n        this._evaluator.globals = globals;\n        this._evaluator.feature = feature || null;\n        this._evaluator.featureState = featureState || null;\n        this._evaluator.canonical = canonical;\n        this._evaluator.availableImages = availableImages || null;\n        this._evaluator.formattedSection = formattedSection || null;\n        try {\n            const val = this.expression.evaluate(this._evaluator);\n            if (val === null || val === undefined || (typeof val === 'number' && val !== val)) {\n                return this._defaultValue;\n            }\n            if (this._enumValues && !(val in this._enumValues)) {\n                throw new RuntimeError(`Expected value to be one of ${Object.keys(this._enumValues).map(v => JSON.stringify(v)).join(', ')}, but found ${JSON.stringify(val)} instead.`);\n            }\n            return val;\n        }\n        catch (e) {\n            if (!this._warningHistory[e.message]) {\n                this._warningHistory[e.message] = true;\n                if (typeof console !== 'undefined') {\n                    console.warn(e.message);\n                }\n            }\n            return this._defaultValue;\n        }\n    }\n}\nfunction isExpression(expression) {\n    return Array.isArray(expression) && expression.length > 0 &&\n        typeof expression[0] === 'string' && expression[0] in expressions$1;\n}\n/**\n * Parse and typecheck the given style spec JSON expression.  If\n * options.defaultValue is provided, then the resulting StyleExpression's\n * `evaluate()` method will handle errors by logging a warning (once per\n * message) and returning the default value.  Otherwise, it will throw\n * evaluation errors.\n *\n * @private\n */\nfunction createExpression(expression, propertySpec) {\n    const parser = new ParsingContext(expressions$1, isExpressionConstant, [], propertySpec ? getExpectedType(propertySpec) : undefined);\n    // For string-valued properties, coerce to string at the top level rather than asserting.\n    const parsed = parser.parse(expression, undefined, undefined, undefined, propertySpec && propertySpec.type === 'string' ? { typeAnnotation: 'coerce' } : undefined);\n    if (!parsed) {\n        return error(parser.errors);\n    }\n    return success(new StyleExpression(parsed, propertySpec));\n}\nclass ZoomConstantExpression {\n    constructor(kind, expression) {\n        this.kind = kind;\n        this._styleExpression = expression;\n        this.isStateDependent = kind !== 'constant' && !isStateConstant(expression.expression);\n    }\n    evaluateWithoutErrorHandling(globals, feature, featureState, canonical, availableImages, formattedSection) {\n        return this._styleExpression.evaluateWithoutErrorHandling(globals, feature, featureState, canonical, availableImages, formattedSection);\n    }\n    evaluate(globals, feature, featureState, canonical, availableImages, formattedSection) {\n        return this._styleExpression.evaluate(globals, feature, featureState, canonical, availableImages, formattedSection);\n    }\n}\nclass ZoomDependentExpression {\n    constructor(kind, expression, zoomStops, interpolationType) {\n        this.kind = kind;\n        this.zoomStops = zoomStops;\n        this._styleExpression = expression;\n        this.isStateDependent = kind !== 'camera' && !isStateConstant(expression.expression);\n        this.interpolationType = interpolationType;\n    }\n    evaluateWithoutErrorHandling(globals, feature, featureState, canonical, availableImages, formattedSection) {\n        return this._styleExpression.evaluateWithoutErrorHandling(globals, feature, featureState, canonical, availableImages, formattedSection);\n    }\n    evaluate(globals, feature, featureState, canonical, availableImages, formattedSection) {\n        return this._styleExpression.evaluate(globals, feature, featureState, canonical, availableImages, formattedSection);\n    }\n    interpolationFactor(input, lower, upper) {\n        if (this.interpolationType) {\n            return Interpolate.interpolationFactor(this.interpolationType, input, lower, upper);\n        }\n        else {\n            return 0;\n        }\n    }\n}\nfunction isZoomExpression(expression) {\n    return expression._styleExpression !== undefined;\n}\nfunction createPropertyExpression(expressionInput, propertySpec) {\n    const expression = createExpression(expressionInput, propertySpec);\n    if (expression.result === 'error') {\n        return expression;\n    }\n    const parsed = expression.value.expression;\n    const isFeatureConstantResult = isFeatureConstant(parsed);\n    if (!isFeatureConstantResult && !supportsPropertyExpression(propertySpec)) {\n        return error([new ExpressionParsingError('', 'data expressions not supported')]);\n    }\n    const isZoomConstant = isGlobalPropertyConstant(parsed, ['zoom']);\n    if (!isZoomConstant && !supportsZoomExpression(propertySpec)) {\n        return error([new ExpressionParsingError('', 'zoom expressions not supported')]);\n    }\n    const zoomCurve = findZoomCurve(parsed);\n    if (!zoomCurve && !isZoomConstant) {\n        return error([new ExpressionParsingError('', '\"zoom\" expression may only be used as input to a top-level \"step\" or \"interpolate\" expression.')]);\n    }\n    else if (zoomCurve instanceof ExpressionParsingError) {\n        return error([zoomCurve]);\n    }\n    else if (zoomCurve instanceof Interpolate && !supportsInterpolation(propertySpec)) {\n        return error([new ExpressionParsingError('', '\"interpolate\" expressions cannot be used with this property')]);\n    }\n    if (!zoomCurve) {\n        return success(isFeatureConstantResult ?\n            new ZoomConstantExpression('constant', expression.value) :\n            new ZoomConstantExpression('source', expression.value));\n    }\n    const interpolationType = zoomCurve instanceof Interpolate ? zoomCurve.interpolation : undefined;\n    return success(isFeatureConstantResult ?\n        new ZoomDependentExpression('camera', expression.value, zoomCurve.labels, interpolationType) :\n        new ZoomDependentExpression('composite', expression.value, zoomCurve.labels, interpolationType));\n}\n// serialization wrapper for old-style stop functions normalized to the\n// expression interface\nclass StylePropertyFunction {\n    constructor(parameters, specification) {\n        this._parameters = parameters;\n        this._specification = specification;\n        extendBy(this, createFunction(this._parameters, this._specification));\n    }\n    static deserialize(serialized) {\n        return new StylePropertyFunction(serialized._parameters, serialized._specification);\n    }\n    static serialize(input) {\n        return {\n            _parameters: input._parameters,\n            _specification: input._specification\n        };\n    }\n}\nfunction normalizePropertyExpression(value, specification) {\n    if (isFunction$1(value)) {\n        return new StylePropertyFunction(value, specification);\n    }\n    else if (isExpression(value)) {\n        const expression = createPropertyExpression(value, specification);\n        if (expression.result === 'error') {\n            // this should have been caught in validation\n            throw new Error(expression.value.map(err => `${err.key}: ${err.message}`).join(', '));\n        }\n        return expression.value;\n    }\n    else {\n        let constant = value;\n        if (specification.type === 'color' && typeof value === 'string') {\n            constant = Color.parse(value);\n        }\n        else if (specification.type === 'padding' && (typeof value === 'number' || Array.isArray(value))) {\n            constant = Padding.parse(value);\n        }\n        else if (specification.type === 'variableAnchorOffsetCollection' && Array.isArray(value)) {\n            constant = VariableAnchorOffsetCollection.parse(value);\n        }\n        else if (specification.type === 'projectionDefinition' && typeof value === 'string') {\n            constant = ProjectionDefinition.parse(value);\n        }\n        return {\n            kind: 'constant',\n            evaluate: () => constant\n        };\n    }\n}\n// Zoom-dependent expressions may only use [\"zoom\"] as the input to a top-level \"step\" or \"interpolate\"\n// expression (collectively referred to as a \"curve\"). The curve may be wrapped in one or more \"let\" or\n// \"coalesce\" expressions.\nfunction findZoomCurve(expression) {\n    let result = null;\n    if (expression instanceof Let) {\n        result = findZoomCurve(expression.result);\n    }\n    else if (expression instanceof Coalesce) {\n        for (const arg of expression.args) {\n            result = findZoomCurve(arg);\n            if (result) {\n                break;\n            }\n        }\n    }\n    else if ((expression instanceof Step || expression instanceof Interpolate) &&\n        expression.input instanceof CompoundExpression &&\n        expression.input.name === 'zoom') {\n        result = expression;\n    }\n    if (result instanceof ExpressionParsingError) {\n        return result;\n    }\n    expression.eachChild((child) => {\n        const childResult = findZoomCurve(child);\n        if (childResult instanceof ExpressionParsingError) {\n            result = childResult;\n        }\n        else if (!result && childResult) {\n            result = new ExpressionParsingError('', '\"zoom\" expression may only be used as input to a top-level \"step\" or \"interpolate\" expression.');\n        }\n        else if (result && childResult && result !== childResult) {\n            result = new ExpressionParsingError('', 'Only one zoom-based \"step\" or \"interpolate\" subexpression may be used in an expression.');\n        }\n    });\n    return result;\n}\nfunction getExpectedType(spec) {\n    const types = {\n        color: ColorType,\n        string: StringType,\n        number: NumberType,\n        enum: StringType,\n        boolean: BooleanType,\n        formatted: FormattedType,\n        padding: PaddingType,\n        projectionDefinition: ProjectionDefinitionType,\n        resolvedImage: ResolvedImageType,\n        variableAnchorOffsetCollection: VariableAnchorOffsetCollectionType\n    };\n    if (spec.type === 'array') {\n        return array(types[spec.value] || ValueType, spec.length);\n    }\n    return types[spec.type];\n}\nfunction getDefaultValue(spec) {\n    if (spec.type === 'color' && isFunction$1(spec.default)) {\n        // Special case for heatmap-color: it uses the 'default:' to define a\n        // default color ramp, but createExpression expects a simple value to fall\n        // back to in case of runtime errors\n        return new Color(0, 0, 0, 0);\n    }\n    else if (spec.type === 'color') {\n        return Color.parse(spec.default) || null;\n    }\n    else if (spec.type === 'padding') {\n        return Padding.parse(spec.default) || null;\n    }\n    else if (spec.type === 'variableAnchorOffsetCollection') {\n        return VariableAnchorOffsetCollection.parse(spec.default) || null;\n    }\n    else if (spec.type === 'projectionDefinition') {\n        return ProjectionDefinition.parse(spec.default) || null;\n    }\n    else if (spec.default === undefined) {\n        return null;\n    }\n    else {\n        return spec.default;\n    }\n}\n\nfunction isExpressionFilter(filter) {\n    if (filter === true || filter === false) {\n        return true;\n    }\n    if (!Array.isArray(filter) || filter.length === 0) {\n        return false;\n    }\n    switch (filter[0]) {\n        case 'has':\n            return filter.length >= 2 && filter[1] !== '$id' && filter[1] !== '$type';\n        case 'in':\n            return filter.length >= 3 && (typeof filter[1] !== 'string' || Array.isArray(filter[2]));\n        case '!in':\n        case '!has':\n        case 'none':\n            return false;\n        case '==':\n        case '!=':\n        case '>':\n        case '>=':\n        case '<':\n        case '<=':\n            return filter.length !== 3 || (Array.isArray(filter[1]) || Array.isArray(filter[2]));\n        case 'any':\n        case 'all':\n            for (const f of filter.slice(1)) {\n                if (!isExpressionFilter(f) && typeof f !== 'boolean') {\n                    return false;\n                }\n            }\n            return true;\n        default:\n            return true;\n    }\n}\nconst filterSpec = {\n    'type': 'boolean',\n    'default': false,\n    'transition': false,\n    'property-type': 'data-driven',\n    'expression': {\n        'interpolated': false,\n        'parameters': ['zoom', 'feature']\n    }\n};\n/**\n * Given a filter expressed as nested arrays, return a new function\n * that evaluates whether a given feature (with a .properties or .tags property)\n * passes its test.\n *\n * @private\n * @param {Array} filter MapLibre filter\n * @returns {Function} filter-evaluating function\n */\nfunction featureFilter(filter) {\n    if (filter === null || filter === undefined) {\n        return { filter: () => true, needGeometry: false };\n    }\n    if (!isExpressionFilter(filter)) {\n        filter = convertFilter$1(filter);\n    }\n    const compiled = createExpression(filter, filterSpec);\n    if (compiled.result === 'error') {\n        throw new Error(compiled.value.map(err => `${err.key}: ${err.message}`).join(', '));\n    }\n    else {\n        const needGeometry = geometryNeeded(filter);\n        return { filter: (globalProperties, feature, canonical) => compiled.value.evaluate(globalProperties, feature, {}, canonical),\n            needGeometry };\n    }\n}\n// Comparison function to sort numbers and strings\nfunction compare(a, b) {\n    return a < b ? -1 : a > b ? 1 : 0;\n}\nfunction geometryNeeded(filter) {\n    if (!Array.isArray(filter))\n        return false;\n    if (filter[0] === 'within' || filter[0] === 'distance' || filter[0] === 'geometry-type')\n        return true;\n    for (let index = 1; index < filter.length; index++) {\n        if (geometryNeeded(filter[index]))\n            return true;\n    }\n    return false;\n}\nfunction convertFilter$1(filter) {\n    if (!filter)\n        return true;\n    const op = filter[0];\n    if (filter.length <= 1)\n        return (op !== 'any');\n    const converted = op === '==' ? convertComparisonOp$1(filter[1], filter[2], '==') :\n        op === '!=' ? convertNegation(convertComparisonOp$1(filter[1], filter[2], '==')) :\n            op === '<' ||\n                op === '>' ||\n                op === '<=' ||\n                op === '>=' ? convertComparisonOp$1(filter[1], filter[2], op) :\n                op === 'any' ? convertDisjunctionOp(filter.slice(1)) :\n                    op === 'all' ? ['all'].concat(filter.slice(1).map(convertFilter$1)) :\n                        op === 'none' ? ['all'].concat(filter.slice(1).map(convertFilter$1).map(convertNegation)) :\n                            op === 'in' ? convertInOp$1(filter[1], filter.slice(2)) :\n                                op === '!in' ? convertNegation(convertInOp$1(filter[1], filter.slice(2))) :\n                                    op === 'has' ? convertHasOp$1(filter[1]) :\n                                        op === '!has' ? convertNegation(convertHasOp$1(filter[1])) :\n                                            true;\n    return converted;\n}\nfunction convertComparisonOp$1(property, value, op) {\n    switch (property) {\n        case '$type':\n            return [`filter-type-${op}`, value];\n        case '$id':\n            return [`filter-id-${op}`, value];\n        default:\n            return [`filter-${op}`, property, value];\n    }\n}\nfunction convertDisjunctionOp(filters) {\n    return ['any'].concat(filters.map(convertFilter$1));\n}\nfunction convertInOp$1(property, values) {\n    if (values.length === 0) {\n        return false;\n    }\n    switch (property) {\n        case '$type':\n            return ['filter-type-in', ['literal', values]];\n        case '$id':\n            return ['filter-id-in', ['literal', values]];\n        default:\n            if (values.length > 200 && !values.some(v => typeof v !== typeof values[0])) {\n                return ['filter-in-large', property, ['literal', values.sort(compare)]];\n            }\n            else {\n                return ['filter-in-small', property, ['literal', values]];\n            }\n    }\n}\nfunction convertHasOp$1(property) {\n    switch (property) {\n        case '$type':\n            return true;\n        case '$id':\n            return ['filter-has-id'];\n        default:\n            return ['filter-has', property];\n    }\n}\nfunction convertNegation(filter) {\n    return ['!', filter];\n}\n\n/*\n * Convert the given filter to an expression, storing the expected types for\n * any feature properties referenced in expectedTypes.\n *\n * These expected types are needed in order to construct preflight type checks\n * needed for handling 'any' filters. A preflight type check is necessary in\n * order to mimic legacy filters' semantics around expected type mismatches.\n * For example, consider the legacy filter:\n *\n *     [\"any\", [\"all\", [\">\", \"y\", 0], [\">\", \"y\", 0]], [\">\", \"x\", 0]]\n *\n * Naively, we might convert this to the expression:\n *\n *     [\"any\", [\"all\", [\">\", [\"get\", \"y\"], 0], [\">\", [\"get\", \"z\"], 0]], [\">\", [\"get\", \"x\"], 0]]\n *\n * But if we tried to evaluate this against, say `{x: 1, y: null, z: 0}`, the\n * [\">\", [\"get\", \"y\"], 0] would cause an evaluation error, leading to the\n * entire filter returning false. Legacy filter semantics, though, ask for\n * [\">\", \"y\", 0] to simply return `false` when `y` is of the wrong type,\n * allowing the subsequent terms of the outer \"any\" expression to be evaluated\n * (resulting, in this case, in a `true` value, because x > 0).\n *\n * We account for this by inserting a preflight type-checking expression before\n * each \"any\" term, allowing us to avoid evaluating the actual converted filter\n * if any type mismatches would cause it to produce an evaluation error:\n *\n *     [\"any\",\n *       [\"case\",\n *         [\"all\", [\"==\", [\"typeof\", [\"get\", \"y\"]], \"number\"], [\"==\", [\"typeof\", [\"get\", \"z\"], \"number]],\n *         [\"all\", [\">\", [\"get\", \"y\"], 0], [\">\", [\"get\", \"z\"], 0]],\n *         false\n *       ],\n *       [\"case\",\n *         [\"==\", [\"typeof\", [\"get\", \"x\"], \"number\"]],\n *         [\">\", [\"get\", \"x\"], 0],\n *         false\n *       ]\n *     ]\n *\n * An alternative, possibly more direct approach would be to use type checks\n * in the conversion of each comparison operator, so that the converted version\n * of each individual ==, >=, etc. would mimic the legacy filter semantics. The\n * downside of this approach is that it can lead to many more type checks than\n * would otherwise be necessary: outside the context of an \"any\" expression,\n * bailing out due to a runtime type error (expression semantics) and returning\n * false (legacy filter semantics) are equivalent: they cause the filter to\n * produce a `false` result.\n */\nfunction convertFilter(filter, expectedTypes = {}) {\n    if (isExpressionFilter(filter))\n        return filter;\n    if (!filter)\n        return true;\n    const legacyFilter = filter;\n    const legacyOp = legacyFilter[0];\n    if (filter.length <= 1)\n        return (legacyOp !== 'any');\n    switch (legacyOp) {\n        case '==':\n        case '!=':\n        case '<':\n        case '>':\n        case '<=':\n        case '>=': {\n            const [, property, value] = filter;\n            return convertComparisonOp(property, value, legacyOp, expectedTypes);\n        }\n        case 'any': {\n            const [, ...conditions] = legacyFilter;\n            const children = conditions.map((f) => {\n                const types = {};\n                const child = convertFilter(f, types);\n                const typechecks = runtimeTypeChecks(types);\n                return typechecks === true ? child : ['case', typechecks, child, false];\n            });\n            return ['any', ...children];\n        }\n        case 'all': {\n            const [, ...conditions] = legacyFilter;\n            const children = conditions.map(f => convertFilter(f, expectedTypes));\n            return children.length > 1 ? ['all', ...children] : children[0];\n        }\n        case 'none': {\n            const [, ...conditions] = legacyFilter;\n            return ['!', convertFilter(['any', ...conditions], {})];\n        }\n        case 'in': {\n            const [, property, ...values] = legacyFilter;\n            return convertInOp(property, values);\n        }\n        case '!in': {\n            const [, property, ...values] = legacyFilter;\n            return convertInOp(property, values, true);\n        }\n        case 'has':\n            return convertHasOp(legacyFilter[1]);\n        case '!has':\n            return ['!', convertHasOp(legacyFilter[1])];\n        default:\n            return true;\n    }\n}\n// Given a set of feature properties and an expected type for each one,\n// construct an boolean expression that tests whether each property has the\n// right type.\n// E.g.: for {name: 'string', population: 'number'}, return\n// [ 'all',\n//   ['==', ['typeof', ['get', 'name'], 'string']],\n//   ['==', ['typeof', ['get', 'population'], 'number]]\n// ]\nfunction runtimeTypeChecks(expectedTypes) {\n    const conditions = [];\n    for (const property in expectedTypes) {\n        const get = property === '$id' ? ['id'] : ['get', property];\n        conditions.push(['==', ['typeof', get], expectedTypes[property]]);\n    }\n    if (conditions.length === 0)\n        return true;\n    if (conditions.length === 1)\n        return conditions[0];\n    return ['all', ...conditions];\n}\nfunction convertComparisonOp(property, value, op, expectedTypes) {\n    let get;\n    if (property === '$type') {\n        return convertInOp('$type', [value], op === '!=');\n    }\n    else if (property === '$id') {\n        get = ['id'];\n    }\n    else {\n        get = ['get', property];\n    }\n    if (expectedTypes && value !== null) {\n        const type = typeof value;\n        expectedTypes[property] = type;\n    }\n    if (op === '==' && property !== '$id' && value === null) {\n        return [\n            'all',\n            ['has', property], // missing property != null for legacy filters\n            ['==', get, null]\n        ];\n    }\n    else if (op === '!=' && property !== '$id' && value === null) {\n        return [\n            'any',\n            ['!', ['has', property]], // missing property != null for legacy filters\n            ['!=', get, null]\n        ];\n    }\n    return [op, get, value];\n}\nfunction convertInOp(property, values, negate = false) {\n    if (values.length === 0)\n        return negate;\n    let get;\n    if (property === '$type') {\n        const len = values.length;\n        for (let i = 0; i < len; i++) {\n            values.push(`Multi${values[i]}`);\n        }\n        get = ['geometry-type'];\n    }\n    else if (property === '$id') {\n        get = ['id'];\n    }\n    else {\n        get = ['get', property];\n    }\n    // Determine if the list of values to be searched is homogenously typed.\n    // If so (and if the type is string or number), then we can use a\n    // [match, input, [...values], true, false] construction rather than a\n    // bunch of `==` tests.\n    let uniformTypes = true;\n    const type = typeof values[0];\n    for (const value of values) {\n        if (typeof value !== type) {\n            uniformTypes = false;\n            break;\n        }\n    }\n    if (uniformTypes && (type === 'string' || type === 'number')) {\n        // Match expressions must have unique values.\n        const uniqueValues = values.sort().filter((v, i) => i === 0 || values[i - 1] !== v);\n        return ['match', get, uniqueValues, !negate, negate];\n    }\n    if (negate) {\n        return ['all', ...values.map(v => ['!=', get, v])];\n    }\n    else {\n        return ['any', ...values.map(v => ['==', get, v])];\n    }\n}\nfunction convertHasOp(property) {\n    if (property === '$type') {\n        return true;\n    }\n    else if (property === '$id') {\n        return ['!=', ['id'], null];\n    }\n    else {\n        return ['has', property];\n    }\n}\n\nfunction convertLiteral(value) {\n    return typeof value === 'object' ? ['literal', value] : value;\n}\nfunction convertFunction(parameters, propertySpec) {\n    let stops = parameters.stops;\n    if (!stops) {\n        // identity function\n        return convertIdentityFunction(parameters, propertySpec);\n    }\n    const zoomAndFeatureDependent = stops && typeof stops[0][0] === 'object';\n    const featureDependent = zoomAndFeatureDependent || parameters.property !== undefined;\n    const zoomDependent = zoomAndFeatureDependent || !featureDependent;\n    stops = stops.map((stop) => {\n        if (!featureDependent && propertySpec.tokens && typeof stop[1] === 'string') {\n            return [stop[0], convertTokenString(stop[1])];\n        }\n        return [stop[0], convertLiteral(stop[1])];\n    });\n    if (zoomAndFeatureDependent) {\n        return convertZoomAndPropertyFunction(parameters, propertySpec, stops);\n    }\n    else if (zoomDependent) {\n        return convertZoomFunction(parameters, propertySpec, stops);\n    }\n    else {\n        return convertPropertyFunction(parameters, propertySpec, stops);\n    }\n}\nfunction convertIdentityFunction(parameters, propertySpec) {\n    const get = ['get', parameters.property];\n    if (parameters.default === undefined) {\n        // By default, expressions for string-valued properties get coerced. To preserve\n        // legacy function semantics, insert an explicit assertion instead.\n        return propertySpec.type === 'string' ? ['string', get] : get;\n    }\n    else if (propertySpec.type === 'enum') {\n        return [\n            'match',\n            get,\n            Object.keys(propertySpec.values),\n            get,\n            parameters.default\n        ];\n    }\n    else {\n        const expression = [propertySpec.type === 'color' ? 'to-color' : propertySpec.type, get, convertLiteral(parameters.default)];\n        if (propertySpec.type === 'array') {\n            expression.splice(1, 0, propertySpec.value, propertySpec.length || null);\n        }\n        return expression;\n    }\n}\nfunction getInterpolateOperator(parameters) {\n    switch (parameters.colorSpace) {\n        case 'hcl': return 'interpolate-hcl';\n        case 'lab': return 'interpolate-lab';\n        default: return 'interpolate';\n    }\n}\nfunction convertZoomAndPropertyFunction(parameters, propertySpec, stops) {\n    const featureFunctionParameters = {};\n    const featureFunctionStops = {};\n    const zoomStops = [];\n    for (let s = 0; s < stops.length; s++) {\n        const stop = stops[s];\n        const zoom = stop[0].zoom;\n        if (featureFunctionParameters[zoom] === undefined) {\n            featureFunctionParameters[zoom] = {\n                zoom,\n                type: parameters.type,\n                property: parameters.property,\n                default: parameters.default,\n            };\n            featureFunctionStops[zoom] = [];\n            zoomStops.push(zoom);\n        }\n        featureFunctionStops[zoom].push([stop[0].value, stop[1]]);\n    }\n    // the interpolation type for the zoom dimension of a zoom-and-property\n    // function is determined directly from the style property specification\n    // for which it's being used: linear for interpolatable properties, step\n    // otherwise.\n    const functionType = getFunctionType({}, propertySpec);\n    if (functionType === 'exponential') {\n        const expression = [getInterpolateOperator(parameters), ['linear'], ['zoom']];\n        for (const z of zoomStops) {\n            const output = convertPropertyFunction(featureFunctionParameters[z], propertySpec, featureFunctionStops[z]);\n            appendStopPair(expression, z, output, false);\n        }\n        return expression;\n    }\n    else {\n        const expression = ['step', ['zoom']];\n        for (const z of zoomStops) {\n            const output = convertPropertyFunction(featureFunctionParameters[z], propertySpec, featureFunctionStops[z]);\n            appendStopPair(expression, z, output, true);\n        }\n        fixupDegenerateStepCurve(expression);\n        return expression;\n    }\n}\nfunction coalesce(a, b) {\n    if (a !== undefined)\n        return a;\n    if (b !== undefined)\n        return b;\n}\nfunction getFallback(parameters, propertySpec) {\n    const defaultValue = convertLiteral(coalesce(parameters.default, propertySpec.default));\n    /*\n     * Some fields with type: resolvedImage have an undefined default.\n     * Because undefined is an invalid value for resolvedImage, set fallback to\n     * an empty string instead of undefined to ensure output\n     * passes validation.\n     */\n    if (defaultValue === undefined && propertySpec.type === 'resolvedImage') {\n        return '';\n    }\n    return defaultValue;\n}\nfunction convertPropertyFunction(parameters, propertySpec, stops) {\n    const type = getFunctionType(parameters, propertySpec);\n    const get = ['get', parameters.property];\n    if (type === 'categorical' && typeof stops[0][0] === 'boolean') {\n        const expression = ['case'];\n        for (const stop of stops) {\n            expression.push(['==', get, stop[0]], stop[1]);\n        }\n        expression.push(getFallback(parameters, propertySpec));\n        return expression;\n    }\n    else if (type === 'categorical') {\n        const expression = ['match', get];\n        for (const stop of stops) {\n            appendStopPair(expression, stop[0], stop[1], false);\n        }\n        expression.push(getFallback(parameters, propertySpec));\n        return expression;\n    }\n    else if (type === 'interval') {\n        const expression = ['step', ['number', get]];\n        for (const stop of stops) {\n            appendStopPair(expression, stop[0], stop[1], true);\n        }\n        fixupDegenerateStepCurve(expression);\n        return parameters.default === undefined ? expression : [\n            'case',\n            ['==', ['typeof', get], 'number'],\n            expression,\n            convertLiteral(parameters.default)\n        ];\n    }\n    else if (type === 'exponential') {\n        const base = parameters.base !== undefined ? parameters.base : 1;\n        const expression = [\n            getInterpolateOperator(parameters),\n            base === 1 ? ['linear'] : ['exponential', base],\n            ['number', get]\n        ];\n        for (const stop of stops) {\n            appendStopPair(expression, stop[0], stop[1], false);\n        }\n        return parameters.default === undefined ? expression : [\n            'case',\n            ['==', ['typeof', get], 'number'],\n            expression,\n            convertLiteral(parameters.default)\n        ];\n    }\n    else {\n        throw new Error(`Unknown property function type ${type}`);\n    }\n}\nfunction convertZoomFunction(parameters, propertySpec, stops, input = ['zoom']) {\n    const type = getFunctionType(parameters, propertySpec);\n    let expression;\n    let isStep = false;\n    if (type === 'interval') {\n        expression = ['step', input];\n        isStep = true;\n    }\n    else if (type === 'exponential') {\n        const base = parameters.base !== undefined ? parameters.base : 1;\n        expression = [getInterpolateOperator(parameters), base === 1 ? ['linear'] : ['exponential', base], input];\n    }\n    else {\n        throw new Error(`Unknown zoom function type \"${type}\"`);\n    }\n    for (const stop of stops) {\n        appendStopPair(expression, stop[0], stop[1], isStep);\n    }\n    fixupDegenerateStepCurve(expression);\n    return expression;\n}\nfunction fixupDegenerateStepCurve(expression) {\n    // degenerate step curve (i.e. a constant function): add a noop stop\n    if (expression[0] === 'step' && expression.length === 3) {\n        expression.push(0);\n        expression.push(expression[3]);\n    }\n}\nfunction appendStopPair(curve, input, output, isStep) {\n    // Skip duplicate stop values. They were not validated for functions, but they are for expressions.\n    // https://github.com/mapbox/mapbox-gl-js/issues/4107\n    if (curve.length > 3 && input === curve[curve.length - 2]) {\n        return;\n    }\n    // step curves don't get the first input value, as it is redundant.\n    if (!(isStep && curve.length === 2)) {\n        curve.push(input);\n    }\n    curve.push(output);\n}\nfunction getFunctionType(parameters, propertySpec) {\n    if (parameters.type) {\n        return parameters.type;\n    }\n    else {\n        return propertySpec.expression.interpolated ? 'exponential' : 'interval';\n    }\n}\n// \"String with {name} token\" => [\"concat\", \"String with \", [\"get\", \"name\"], \" token\"]\nfunction convertTokenString(s) {\n    const result = ['concat'];\n    const re = /{([^{}]+)}/g;\n    let pos = 0;\n    for (let match = re.exec(s); match !== null; match = re.exec(s)) {\n        const literal = s.slice(pos, re.lastIndex - match[0].length);\n        pos = re.lastIndex;\n        if (literal.length > 0)\n            result.push(literal);\n        result.push(['get', match[1]]);\n    }\n    if (result.length === 1) {\n        return s;\n    }\n    if (pos < s.length) {\n        result.push(s.slice(pos));\n    }\n    else if (result.length === 2) {\n        return ['to-string', result[1]];\n    }\n    return result;\n}\n\nfunction getPropertyReference(propertyName) {\n    for (let i = 0; i < v8Spec.layout.length; i++) {\n        for (const key in v8Spec[v8Spec.layout[i]]) {\n            if (key === propertyName)\n                return v8Spec[v8Spec.layout[i]][key];\n        }\n    }\n    for (let i = 0; i < v8Spec.paint.length; i++) {\n        for (const key in v8Spec[v8Spec.paint[i]]) {\n            if (key === propertyName)\n                return v8Spec[v8Spec.paint[i]][key];\n        }\n    }\n    return null;\n}\nfunction eachSource(style, callback) {\n    for (const k in style.sources) {\n        callback(style.sources[k]);\n    }\n}\nfunction eachLayer(style, callback) {\n    for (const layer of style.layers) {\n        callback(layer);\n    }\n}\nfunction eachProperty(style, options, callback) {\n    function inner(layer, propertyType) {\n        const properties = layer[propertyType];\n        if (!properties)\n            return;\n        Object.keys(properties).forEach((key) => {\n            callback({\n                path: [layer.id, propertyType, key],\n                key,\n                value: properties[key],\n                reference: getPropertyReference(key),\n                set(x) {\n                    properties[key] = x;\n                }\n            });\n        });\n    }\n    eachLayer(style, (layer) => {\n        if (options.paint) {\n            inner(layer, 'paint');\n        }\n        if (options.layout) {\n            inner(layer, 'layout');\n        }\n    });\n}\n\nfunction stringify$1(obj) {\n    const type = typeof obj;\n    if (type === 'number' || type === 'boolean' || type === 'string' || obj === undefined || obj === null)\n        return JSON.stringify(obj);\n    if (Array.isArray(obj)) {\n        let str = '[';\n        for (const val of obj) {\n            str += `${stringify$1(val)},`;\n        }\n        return `${str}]`;\n    }\n    const keys = Object.keys(obj).sort();\n    let str = '{';\n    for (let i = 0; i < keys.length; i++) {\n        str += `${JSON.stringify(keys[i])}:${stringify$1(obj[keys[i]])},`;\n    }\n    return `${str}}`;\n}\nfunction getKey(layer) {\n    let key = '';\n    for (const k of refProperties) {\n        key += `/${stringify$1(layer[k])}`;\n    }\n    return key;\n}\n/**\n * Given an array of layers, return an array of arrays of layers where all\n * layers in each group have identical layout-affecting properties. These\n * are the properties that were formerly used by explicit `ref` mechanism\n * for layers: 'type', 'source', 'source-layer', 'minzoom', 'maxzoom',\n * 'filter', and 'layout'.\n *\n * The input is not modified. The output layers are references to the\n * input layers.\n *\n * @private\n * @param {Array<Layer>} layers\n * @param {Object} [cachedKeys] - an object to keep already calculated keys.\n * @returns {Array<Array<Layer>>}\n */\nfunction groupByLayout(layers, cachedKeys) {\n    const groups = {};\n    for (let i = 0; i < layers.length; i++) {\n        const k = (cachedKeys && cachedKeys[layers[i].id]) || getKey(layers[i]);\n        // update the cache if there is one\n        if (cachedKeys)\n            cachedKeys[layers[i].id] = k;\n        let group = groups[k];\n        if (!group) {\n            group = groups[k] = [];\n        }\n        group.push(layers[i]);\n    }\n    const result = [];\n    for (const k in groups) {\n        result.push(groups[k]);\n    }\n    return result;\n}\n\nfunction emptyStyle() {\n    const style = {};\n    const version = v8Spec['$version'];\n    for (const styleKey in v8Spec['$root']) {\n        const specification = v8Spec['$root'][styleKey];\n        if (specification.required) {\n            let value = null;\n            if (styleKey === 'version') {\n                value = version;\n            }\n            else {\n                if (specification.type === 'array') {\n                    value = [];\n                }\n                else {\n                    value = {};\n                }\n            }\n            if (value != null) {\n                style[styleKey] = value;\n            }\n        }\n    }\n    return style;\n}\n\nfunction validateConstants(options) {\n    const key = options.key;\n    const constants = options.value;\n    if (constants) {\n        return [new ValidationError(key, constants, 'constants have been deprecated as of v8')];\n    }\n    else {\n        return [];\n    }\n}\n\n// Turn jsonlint-lines-primitives objects into primitive objects\nfunction unbundle(value) {\n    if (value instanceof Number || value instanceof String || value instanceof Boolean) {\n        return value.valueOf();\n    }\n    else {\n        return value;\n    }\n}\nfunction deepUnbundle(value) {\n    if (Array.isArray(value)) {\n        return value.map(deepUnbundle);\n    }\n    else if (value instanceof Object && !(value instanceof Number || value instanceof String || value instanceof Boolean)) {\n        const unbundledValue = {};\n        for (const key in value) {\n            unbundledValue[key] = deepUnbundle(value[key]);\n        }\n        return unbundledValue;\n    }\n    return unbundle(value);\n}\n\nfunction validateObject(options) {\n    const key = options.key;\n    const object = options.value;\n    const elementSpecs = options.valueSpec || {};\n    const elementValidators = options.objectElementValidators || {};\n    const style = options.style;\n    const styleSpec = options.styleSpec;\n    const validateSpec = options.validateSpec;\n    let errors = [];\n    const type = getType(object);\n    if (type !== 'object') {\n        return [new ValidationError(key, object, `object expected, ${type} found`)];\n    }\n    for (const objectKey in object) {\n        const elementSpecKey = objectKey.split('.')[0]; // treat 'paint.*' as 'paint'\n        const elementSpec = elementSpecs[elementSpecKey] || elementSpecs['*'];\n        let validateElement;\n        if (elementValidators[elementSpecKey]) {\n            validateElement = elementValidators[elementSpecKey];\n        }\n        else if (elementSpecs[elementSpecKey]) {\n            validateElement = validateSpec;\n        }\n        else if (elementValidators['*']) {\n            validateElement = elementValidators['*'];\n        }\n        else if (elementSpecs['*']) {\n            validateElement = validateSpec;\n        }\n        else {\n            errors.push(new ValidationError(key, object[objectKey], `unknown property \"${objectKey}\"`));\n            continue;\n        }\n        errors = errors.concat(validateElement({\n            key: (key ? `${key}.` : key) + objectKey,\n            value: object[objectKey],\n            valueSpec: elementSpec,\n            style,\n            styleSpec,\n            object,\n            objectKey,\n            validateSpec,\n        }, object));\n    }\n    for (const elementSpecKey in elementSpecs) {\n        // Don't check `required` when there's a custom validator for that property.\n        if (elementValidators[elementSpecKey]) {\n            continue;\n        }\n        if (elementSpecs[elementSpecKey].required && elementSpecs[elementSpecKey]['default'] === undefined && object[elementSpecKey] === undefined) {\n            errors.push(new ValidationError(key, object, `missing required property \"${elementSpecKey}\"`));\n        }\n    }\n    return errors;\n}\n\nfunction validateArray(options) {\n    const array = options.value;\n    const arraySpec = options.valueSpec;\n    const validateSpec = options.validateSpec;\n    const style = options.style;\n    const styleSpec = options.styleSpec;\n    const key = options.key;\n    const validateArrayElement = options.arrayElementValidator || validateSpec;\n    if (getType(array) !== 'array') {\n        return [new ValidationError(key, array, `array expected, ${getType(array)} found`)];\n    }\n    if (arraySpec.length && array.length !== arraySpec.length) {\n        return [new ValidationError(key, array, `array length ${arraySpec.length} expected, length ${array.length} found`)];\n    }\n    if (arraySpec['min-length'] && array.length < arraySpec['min-length']) {\n        return [new ValidationError(key, array, `array length at least ${arraySpec['min-length']} expected, length ${array.length} found`)];\n    }\n    let arrayElementSpec = {\n        'type': arraySpec.value,\n        'values': arraySpec.values\n    };\n    if (styleSpec.$version < 7) {\n        arrayElementSpec['function'] = arraySpec.function;\n    }\n    if (getType(arraySpec.value) === 'object') {\n        arrayElementSpec = arraySpec.value;\n    }\n    let errors = [];\n    for (let i = 0; i < array.length; i++) {\n        errors = errors.concat(validateArrayElement({\n            array,\n            arrayIndex: i,\n            value: array[i],\n            valueSpec: arrayElementSpec,\n            validateSpec: options.validateSpec,\n            style,\n            styleSpec,\n            key: `${key}[${i}]`\n        }));\n    }\n    return errors;\n}\n\nfunction validateNumber(options) {\n    const key = options.key;\n    const value = options.value;\n    const valueSpec = options.valueSpec;\n    let type = getType(value);\n    if (type === 'number' && value !== value) {\n        type = 'NaN';\n    }\n    if (type !== 'number') {\n        return [new ValidationError(key, value, `number expected, ${type} found`)];\n    }\n    if ('minimum' in valueSpec && value < valueSpec.minimum) {\n        return [new ValidationError(key, value, `${value} is less than the minimum value ${valueSpec.minimum}`)];\n    }\n    if ('maximum' in valueSpec && value > valueSpec.maximum) {\n        return [new ValidationError(key, value, `${value} is greater than the maximum value ${valueSpec.maximum}`)];\n    }\n    return [];\n}\n\nfunction validateFunction(options) {\n    const functionValueSpec = options.valueSpec;\n    const functionType = unbundle(options.value.type);\n    let stopKeyType;\n    let stopDomainValues = {};\n    let previousStopDomainValue;\n    let previousStopDomainZoom;\n    const isZoomFunction = functionType !== 'categorical' && options.value.property === undefined;\n    const isPropertyFunction = !isZoomFunction;\n    const isZoomAndPropertyFunction = getType(options.value.stops) === 'array' &&\n        getType(options.value.stops[0]) === 'array' &&\n        getType(options.value.stops[0][0]) === 'object';\n    const errors = validateObject({\n        key: options.key,\n        value: options.value,\n        valueSpec: options.styleSpec.function,\n        validateSpec: options.validateSpec,\n        style: options.style,\n        styleSpec: options.styleSpec,\n        objectElementValidators: {\n            stops: validateFunctionStops,\n            default: validateFunctionDefault\n        }\n    });\n    if (functionType === 'identity' && isZoomFunction) {\n        errors.push(new ValidationError(options.key, options.value, 'missing required property \"property\"'));\n    }\n    if (functionType !== 'identity' && !options.value.stops) {\n        errors.push(new ValidationError(options.key, options.value, 'missing required property \"stops\"'));\n    }\n    if (functionType === 'exponential' && options.valueSpec.expression && !supportsInterpolation(options.valueSpec)) {\n        errors.push(new ValidationError(options.key, options.value, 'exponential functions not supported'));\n    }\n    if (options.styleSpec.$version >= 8) {\n        if (isPropertyFunction && !supportsPropertyExpression(options.valueSpec)) {\n            errors.push(new ValidationError(options.key, options.value, 'property functions not supported'));\n        }\n        else if (isZoomFunction && !supportsZoomExpression(options.valueSpec)) {\n            errors.push(new ValidationError(options.key, options.value, 'zoom functions not supported'));\n        }\n    }\n    if ((functionType === 'categorical' || isZoomAndPropertyFunction) && options.value.property === undefined) {\n        errors.push(new ValidationError(options.key, options.value, '\"property\" property is required'));\n    }\n    return errors;\n    function validateFunctionStops(options) {\n        if (functionType === 'identity') {\n            return [new ValidationError(options.key, options.value, 'identity function may not have a \"stops\" property')];\n        }\n        let errors = [];\n        const value = options.value;\n        errors = errors.concat(validateArray({\n            key: options.key,\n            value,\n            valueSpec: options.valueSpec,\n            validateSpec: options.validateSpec,\n            style: options.style,\n            styleSpec: options.styleSpec,\n            arrayElementValidator: validateFunctionStop\n        }));\n        if (getType(value) === 'array' && value.length === 0) {\n            errors.push(new ValidationError(options.key, value, 'array must have at least one stop'));\n        }\n        return errors;\n    }\n    function validateFunctionStop(options) {\n        let errors = [];\n        const value = options.value;\n        const key = options.key;\n        if (getType(value) !== 'array') {\n            return [new ValidationError(key, value, `array expected, ${getType(value)} found`)];\n        }\n        if (value.length !== 2) {\n            return [new ValidationError(key, value, `array length 2 expected, length ${value.length} found`)];\n        }\n        if (isZoomAndPropertyFunction) {\n            if (getType(value[0]) !== 'object') {\n                return [new ValidationError(key, value, `object expected, ${getType(value[0])} found`)];\n            }\n            if (value[0].zoom === undefined) {\n                return [new ValidationError(key, value, 'object stop key must have zoom')];\n            }\n            if (value[0].value === undefined) {\n                return [new ValidationError(key, value, 'object stop key must have value')];\n            }\n            if (previousStopDomainZoom && previousStopDomainZoom > unbundle(value[0].zoom)) {\n                return [new ValidationError(key, value[0].zoom, 'stop zoom values must appear in ascending order')];\n            }\n            if (unbundle(value[0].zoom) !== previousStopDomainZoom) {\n                previousStopDomainZoom = unbundle(value[0].zoom);\n                previousStopDomainValue = undefined;\n                stopDomainValues = {};\n            }\n            errors = errors.concat(validateObject({\n                key: `${key}[0]`,\n                value: value[0],\n                valueSpec: { zoom: {} },\n                validateSpec: options.validateSpec,\n                style: options.style,\n                styleSpec: options.styleSpec,\n                objectElementValidators: { zoom: validateNumber, value: validateStopDomainValue }\n            }));\n        }\n        else {\n            errors = errors.concat(validateStopDomainValue({\n                key: `${key}[0]`,\n                value: value[0],\n                valueSpec: {},\n                validateSpec: options.validateSpec,\n                style: options.style,\n                styleSpec: options.styleSpec\n            }, value));\n        }\n        if (isExpression(deepUnbundle(value[1]))) {\n            return errors.concat([new ValidationError(`${key}[1]`, value[1], 'expressions are not allowed in function stops.')]);\n        }\n        return errors.concat(options.validateSpec({\n            key: `${key}[1]`,\n            value: value[1],\n            valueSpec: functionValueSpec,\n            validateSpec: options.validateSpec,\n            style: options.style,\n            styleSpec: options.styleSpec\n        }));\n    }\n    function validateStopDomainValue(options, stop) {\n        const type = getType(options.value);\n        const value = unbundle(options.value);\n        const reportValue = options.value !== null ? options.value : stop;\n        if (!stopKeyType) {\n            stopKeyType = type;\n        }\n        else if (type !== stopKeyType) {\n            return [new ValidationError(options.key, reportValue, `${type} stop domain type must match previous stop domain type ${stopKeyType}`)];\n        }\n        if (type !== 'number' && type !== 'string' && type !== 'boolean') {\n            return [new ValidationError(options.key, reportValue, 'stop domain value must be a number, string, or boolean')];\n        }\n        if (type !== 'number' && functionType !== 'categorical') {\n            let message = `number expected, ${type} found`;\n            if (supportsPropertyExpression(functionValueSpec) && functionType === undefined) {\n                message += '\\nIf you intended to use a categorical function, specify `\"type\": \"categorical\"`.';\n            }\n            return [new ValidationError(options.key, reportValue, message)];\n        }\n        if (functionType === 'categorical' && type === 'number' && (!isFinite(value) || Math.floor(value) !== value)) {\n            return [new ValidationError(options.key, reportValue, `integer expected, found ${value}`)];\n        }\n        if (functionType !== 'categorical' && type === 'number' && previousStopDomainValue !== undefined && value < previousStopDomainValue) {\n            return [new ValidationError(options.key, reportValue, 'stop domain values must appear in ascending order')];\n        }\n        else {\n            previousStopDomainValue = value;\n        }\n        if (functionType === 'categorical' && value in stopDomainValues) {\n            return [new ValidationError(options.key, reportValue, 'stop domain values must be unique')];\n        }\n        else {\n            stopDomainValues[value] = true;\n        }\n        return [];\n    }\n    function validateFunctionDefault(options) {\n        return options.validateSpec({\n            key: options.key,\n            value: options.value,\n            valueSpec: functionValueSpec,\n            validateSpec: options.validateSpec,\n            style: options.style,\n            styleSpec: options.styleSpec\n        });\n    }\n}\n\nfunction validateExpression(options) {\n    const expression = (options.expressionContext === 'property' ? createPropertyExpression : createExpression)(deepUnbundle(options.value), options.valueSpec);\n    if (expression.result === 'error') {\n        return expression.value.map((error) => {\n            return new ValidationError(`${options.key}${error.key}`, options.value, error.message);\n        });\n    }\n    const expressionObj = expression.value.expression || expression.value._styleExpression.expression;\n    if (options.expressionContext === 'property' && (options.propertyKey === 'text-font') &&\n        !expressionObj.outputDefined()) {\n        return [new ValidationError(options.key, options.value, `Invalid data expression for \"${options.propertyKey}\". Output values must be contained as literals within the expression.`)];\n    }\n    if (options.expressionContext === 'property' && options.propertyType === 'layout' &&\n        (!isStateConstant(expressionObj))) {\n        return [new ValidationError(options.key, options.value, '\"feature-state\" data expressions are not supported with layout properties.')];\n    }\n    if (options.expressionContext === 'filter' && !isStateConstant(expressionObj)) {\n        return [new ValidationError(options.key, options.value, '\"feature-state\" data expressions are not supported with filters.')];\n    }\n    if (options.expressionContext && options.expressionContext.indexOf('cluster') === 0) {\n        if (!isGlobalPropertyConstant(expressionObj, ['zoom', 'feature-state'])) {\n            return [new ValidationError(options.key, options.value, '\"zoom\" and \"feature-state\" expressions are not supported with cluster properties.')];\n        }\n        if (options.expressionContext === 'cluster-initial' && !isFeatureConstant(expressionObj)) {\n            return [new ValidationError(options.key, options.value, 'Feature data expressions are not supported with initial expression part of cluster properties.')];\n        }\n    }\n    return [];\n}\n\nfunction validateBoolean(options) {\n    const value = options.value;\n    const key = options.key;\n    const type = getType(value);\n    if (type !== 'boolean') {\n        return [new ValidationError(key, value, `boolean expected, ${type} found`)];\n    }\n    return [];\n}\n\nfunction validateColor(options) {\n    const key = options.key;\n    const value = options.value;\n    const type = getType(value);\n    if (type !== 'string') {\n        return [new ValidationError(key, value, `color expected, ${type} found`)];\n    }\n    if (!Color.parse(String(value))) { // cast String object to string primitive\n        return [new ValidationError(key, value, `color expected, \"${value}\" found`)];\n    }\n    return [];\n}\n\nfunction validateEnum(options) {\n    const key = options.key;\n    const value = options.value;\n    const valueSpec = options.valueSpec;\n    const errors = [];\n    if (Array.isArray(valueSpec.values)) { // <=v7\n        if (valueSpec.values.indexOf(unbundle(value)) === -1) {\n            errors.push(new ValidationError(key, value, `expected one of [${valueSpec.values.join(', ')}], ${JSON.stringify(value)} found`));\n        }\n    }\n    else { // >=v8\n        if (Object.keys(valueSpec.values).indexOf(unbundle(value)) === -1) {\n            errors.push(new ValidationError(key, value, `expected one of [${Object.keys(valueSpec.values).join(', ')}], ${JSON.stringify(value)} found`));\n        }\n    }\n    return errors;\n}\n\nfunction validateFilter(options) {\n    if (isExpressionFilter(deepUnbundle(options.value))) {\n        return validateExpression(extendBy({}, options, {\n            expressionContext: 'filter',\n            valueSpec: { value: 'boolean' }\n        }));\n    }\n    else {\n        return validateNonExpressionFilter(options);\n    }\n}\nfunction validateNonExpressionFilter(options) {\n    const value = options.value;\n    const key = options.key;\n    if (getType(value) !== 'array') {\n        return [new ValidationError(key, value, `array expected, ${getType(value)} found`)];\n    }\n    const styleSpec = options.styleSpec;\n    let type;\n    let errors = [];\n    if (value.length < 1) {\n        return [new ValidationError(key, value, 'filter array must have at least 1 element')];\n    }\n    errors = errors.concat(validateEnum({\n        key: `${key}[0]`,\n        value: value[0],\n        valueSpec: styleSpec.filter_operator,\n        style: options.style,\n        styleSpec: options.styleSpec\n    }));\n    switch (unbundle(value[0])) {\n        case '<':\n        case '<=':\n        case '>':\n        case '>=':\n            if (value.length >= 2 && unbundle(value[1]) === '$type') {\n                errors.push(new ValidationError(key, value, `\"$type\" cannot be use with operator \"${value[0]}\"`));\n            }\n        /* falls through */\n        case '==':\n        case '!=':\n            if (value.length !== 3) {\n                errors.push(new ValidationError(key, value, `filter array for operator \"${value[0]}\" must have 3 elements`));\n            }\n        /* falls through */\n        case 'in':\n        case '!in':\n            if (value.length >= 2) {\n                type = getType(value[1]);\n                if (type !== 'string') {\n                    errors.push(new ValidationError(`${key}[1]`, value[1], `string expected, ${type} found`));\n                }\n            }\n            for (let i = 2; i < value.length; i++) {\n                type = getType(value[i]);\n                if (unbundle(value[1]) === '$type') {\n                    errors = errors.concat(validateEnum({\n                        key: `${key}[${i}]`,\n                        value: value[i],\n                        valueSpec: styleSpec.geometry_type,\n                        style: options.style,\n                        styleSpec: options.styleSpec\n                    }));\n                }\n                else if (type !== 'string' && type !== 'number' && type !== 'boolean') {\n                    errors.push(new ValidationError(`${key}[${i}]`, value[i], `string, number, or boolean expected, ${type} found`));\n                }\n            }\n            break;\n        case 'any':\n        case 'all':\n        case 'none':\n            for (let i = 1; i < value.length; i++) {\n                errors = errors.concat(validateNonExpressionFilter({\n                    key: `${key}[${i}]`,\n                    value: value[i],\n                    style: options.style,\n                    styleSpec: options.styleSpec\n                }));\n            }\n            break;\n        case 'has':\n        case '!has':\n            type = getType(value[1]);\n            if (value.length !== 2) {\n                errors.push(new ValidationError(key, value, `filter array for \"${value[0]}\" operator must have 2 elements`));\n            }\n            else if (type !== 'string') {\n                errors.push(new ValidationError(`${key}[1]`, value[1], `string expected, ${type} found`));\n            }\n            break;\n    }\n    return errors;\n}\n\nfunction validateProperty(options, propertyType) {\n    const key = options.key;\n    const validateSpec = options.validateSpec;\n    const style = options.style;\n    const styleSpec = options.styleSpec;\n    const value = options.value;\n    const propertyKey = options.objectKey;\n    const layerSpec = styleSpec[`${propertyType}_${options.layerType}`];\n    if (!layerSpec)\n        return [];\n    const transitionMatch = propertyKey.match(/^(.*)-transition$/);\n    if (propertyType === 'paint' && transitionMatch && layerSpec[transitionMatch[1]] && layerSpec[transitionMatch[1]].transition) {\n        return validateSpec({\n            key,\n            value,\n            valueSpec: styleSpec.transition,\n            style,\n            styleSpec\n        });\n    }\n    const valueSpec = options.valueSpec || layerSpec[propertyKey];\n    if (!valueSpec) {\n        return [new ValidationError(key, value, `unknown property \"${propertyKey}\"`)];\n    }\n    let tokenMatch;\n    if (getType(value) === 'string' && supportsPropertyExpression(valueSpec) && !valueSpec.tokens && (tokenMatch = /^{([^}]+)}$/.exec(value))) {\n        return [new ValidationError(key, value, `\"${propertyKey}\" does not support interpolation syntax\\n` +\n                `Use an identity property function instead: \\`{ \"type\": \"identity\", \"property\": ${JSON.stringify(tokenMatch[1])} }\\`.`)];\n    }\n    const errors = [];\n    if (options.layerType === 'symbol') {\n        if (propertyKey === 'text-field' && style && !style.glyphs) {\n            errors.push(new ValidationError(key, value, 'use of \"text-field\" requires a style \"glyphs\" property'));\n        }\n        if (propertyKey === 'text-font' && isFunction$1(deepUnbundle(value)) && unbundle(value.type) === 'identity') {\n            errors.push(new ValidationError(key, value, '\"text-font\" does not support identity functions'));\n        }\n    }\n    return errors.concat(validateSpec({\n        key: options.key,\n        value,\n        valueSpec,\n        style,\n        styleSpec,\n        expressionContext: 'property',\n        propertyType,\n        propertyKey\n    }));\n}\n\nfunction validatePaintProperty(options) {\n    return validateProperty(options, 'paint');\n}\n\nfunction validateLayoutProperty(options) {\n    return validateProperty(options, 'layout');\n}\n\nfunction validateLayer(options) {\n    let errors = [];\n    const layer = options.value;\n    const key = options.key;\n    const style = options.style;\n    const styleSpec = options.styleSpec;\n    if (!layer.type && !layer.ref) {\n        errors.push(new ValidationError(key, layer, 'either \"type\" or \"ref\" is required'));\n    }\n    let type = unbundle(layer.type);\n    const ref = unbundle(layer.ref);\n    if (layer.id) {\n        const layerId = unbundle(layer.id);\n        for (let i = 0; i < options.arrayIndex; i++) {\n            const otherLayer = style.layers[i];\n            if (unbundle(otherLayer.id) === layerId) {\n                errors.push(new ValidationError(key, layer.id, `duplicate layer id \"${layer.id}\", previously used at line ${otherLayer.id.__line__}`));\n            }\n        }\n    }\n    if ('ref' in layer) {\n        ['type', 'source', 'source-layer', 'filter', 'layout'].forEach((p) => {\n            if (p in layer) {\n                errors.push(new ValidationError(key, layer[p], `\"${p}\" is prohibited for ref layers`));\n            }\n        });\n        let parent;\n        style.layers.forEach((layer) => {\n            if (unbundle(layer.id) === ref)\n                parent = layer;\n        });\n        if (!parent) {\n            errors.push(new ValidationError(key, layer.ref, `ref layer \"${ref}\" not found`));\n        }\n        else if (parent.ref) {\n            errors.push(new ValidationError(key, layer.ref, 'ref cannot reference another ref layer'));\n        }\n        else {\n            type = unbundle(parent.type);\n        }\n    }\n    else if (type !== 'background') {\n        if (!layer.source) {\n            errors.push(new ValidationError(key, layer, 'missing required property \"source\"'));\n        }\n        else {\n            const source = style.sources && style.sources[layer.source];\n            const sourceType = source && unbundle(source.type);\n            if (!source) {\n                errors.push(new ValidationError(key, layer.source, `source \"${layer.source}\" not found`));\n            }\n            else if (sourceType === 'vector' && type === 'raster') {\n                errors.push(new ValidationError(key, layer.source, `layer \"${layer.id}\" requires a raster source`));\n            }\n            else if (sourceType !== 'raster-dem' && type === 'hillshade') {\n                errors.push(new ValidationError(key, layer.source, `layer \"${layer.id}\" requires a raster-dem source`));\n            }\n            else if (sourceType === 'raster' && type !== 'raster') {\n                errors.push(new ValidationError(key, layer.source, `layer \"${layer.id}\" requires a vector source`));\n            }\n            else if (sourceType === 'vector' && !layer['source-layer']) {\n                errors.push(new ValidationError(key, layer, `layer \"${layer.id}\" must specify a \"source-layer\"`));\n            }\n            else if (sourceType === 'raster-dem' && type !== 'hillshade') {\n                errors.push(new ValidationError(key, layer.source, 'raster-dem source can only be used with layer type \\'hillshade\\'.'));\n            }\n            else if (type === 'line' && layer.paint && layer.paint['line-gradient'] &&\n                (sourceType !== 'geojson' || !source.lineMetrics)) {\n                errors.push(new ValidationError(key, layer, `layer \"${layer.id}\" specifies a line-gradient, which requires a GeoJSON source with \\`lineMetrics\\` enabled.`));\n            }\n        }\n    }\n    errors = errors.concat(validateObject({\n        key,\n        value: layer,\n        valueSpec: styleSpec.layer,\n        style: options.style,\n        styleSpec: options.styleSpec,\n        validateSpec: options.validateSpec,\n        objectElementValidators: {\n            '*'() {\n                return [];\n            },\n            // We don't want to enforce the spec's `\"requires\": true` for backward compatibility with refs;\n            // the actual requirement is validated above. See https://github.com/mapbox/mapbox-gl-js/issues/5772.\n            type() {\n                return options.validateSpec({\n                    key: `${key}.type`,\n                    value: layer.type,\n                    valueSpec: styleSpec.layer.type,\n                    style: options.style,\n                    styleSpec: options.styleSpec,\n                    validateSpec: options.validateSpec,\n                    object: layer,\n                    objectKey: 'type'\n                });\n            },\n            filter: validateFilter,\n            layout(options) {\n                return validateObject({\n                    layer,\n                    key: options.key,\n                    value: options.value,\n                    style: options.style,\n                    styleSpec: options.styleSpec,\n                    validateSpec: options.validateSpec,\n                    objectElementValidators: {\n                        '*'(options) {\n                            return validateLayoutProperty(extendBy({ layerType: type }, options));\n                        }\n                    }\n                });\n            },\n            paint(options) {\n                return validateObject({\n                    layer,\n                    key: options.key,\n                    value: options.value,\n                    style: options.style,\n                    styleSpec: options.styleSpec,\n                    validateSpec: options.validateSpec,\n                    objectElementValidators: {\n                        '*'(options) {\n                            return validatePaintProperty(extendBy({ layerType: type }, options));\n                        }\n                    }\n                });\n            }\n        }\n    }));\n    return errors;\n}\n\nfunction validateString(options) {\n    const value = options.value;\n    const key = options.key;\n    const type = getType(value);\n    if (type !== 'string') {\n        return [new ValidationError(key, value, `string expected, ${type} found`)];\n    }\n    return [];\n}\n\nfunction validateRasterDEMSource(options) {\n    var _a;\n    const sourceName = (_a = options.sourceName) !== null && _a !== void 0 ? _a : '';\n    const rasterDEM = options.value;\n    const styleSpec = options.styleSpec;\n    const rasterDEMSpec = styleSpec.source_raster_dem;\n    const style = options.style;\n    let errors = [];\n    const rootType = getType(rasterDEM);\n    if (rasterDEM === undefined) {\n        return errors;\n    }\n    else if (rootType !== 'object') {\n        errors.push(new ValidationError('source_raster_dem', rasterDEM, `object expected, ${rootType} found`));\n        return errors;\n    }\n    const encoding = unbundle(rasterDEM.encoding);\n    const isCustomEncoding = encoding === 'custom';\n    const customEncodingKeys = ['redFactor', 'greenFactor', 'blueFactor', 'baseShift'];\n    const encodingName = options.value.encoding ? `\"${options.value.encoding}\"` : 'Default';\n    for (const key in rasterDEM) {\n        if (!isCustomEncoding && customEncodingKeys.includes(key)) {\n            errors.push(new ValidationError(key, rasterDEM[key], `In \"${sourceName}\": \"${key}\" is only valid when \"encoding\" is set to \"custom\". ${encodingName} encoding found`));\n        }\n        else if (rasterDEMSpec[key]) {\n            errors = errors.concat(options.validateSpec({\n                key,\n                value: rasterDEM[key],\n                valueSpec: rasterDEMSpec[key],\n                validateSpec: options.validateSpec,\n                style,\n                styleSpec\n            }));\n        }\n        else {\n            errors.push(new ValidationError(key, rasterDEM[key], `unknown property \"${key}\"`));\n        }\n    }\n    return errors;\n}\n\nconst objectElementValidators = {\n    promoteId: validatePromoteId\n};\nfunction validateSource(options) {\n    const value = options.value;\n    const key = options.key;\n    const styleSpec = options.styleSpec;\n    const style = options.style;\n    const validateSpec = options.validateSpec;\n    if (!value.type) {\n        return [new ValidationError(key, value, '\"type\" is required')];\n    }\n    const type = unbundle(value.type);\n    let errors;\n    switch (type) {\n        case 'vector':\n        case 'raster':\n            errors = validateObject({\n                key,\n                value,\n                valueSpec: styleSpec[`source_${type.replace('-', '_')}`],\n                style: options.style,\n                styleSpec,\n                objectElementValidators,\n                validateSpec,\n            });\n            return errors;\n        case 'raster-dem':\n            errors = validateRasterDEMSource({\n                sourceName: key,\n                value,\n                style: options.style,\n                styleSpec,\n                validateSpec,\n            });\n            return errors;\n        case 'geojson':\n            errors = validateObject({\n                key,\n                value,\n                valueSpec: styleSpec.source_geojson,\n                style,\n                styleSpec,\n                validateSpec,\n                objectElementValidators\n            });\n            if (value.cluster) {\n                for (const prop in value.clusterProperties) {\n                    const [operator, mapExpr] = value.clusterProperties[prop];\n                    const reduceExpr = typeof operator === 'string' ? [operator, ['accumulated'], ['get', prop]] : operator;\n                    errors.push(...validateExpression({\n                        key: `${key}.${prop}.map`,\n                        value: mapExpr,\n                        validateSpec,\n                        expressionContext: 'cluster-map'\n                    }));\n                    errors.push(...validateExpression({\n                        key: `${key}.${prop}.reduce`,\n                        value: reduceExpr,\n                        validateSpec,\n                        expressionContext: 'cluster-reduce'\n                    }));\n                }\n            }\n            return errors;\n        case 'video':\n            return validateObject({\n                key,\n                value,\n                valueSpec: styleSpec.source_video,\n                style,\n                validateSpec,\n                styleSpec\n            });\n        case 'image':\n            return validateObject({\n                key,\n                value,\n                valueSpec: styleSpec.source_image,\n                style,\n                validateSpec,\n                styleSpec\n            });\n        case 'canvas':\n            return [new ValidationError(key, null, 'Please use runtime APIs to add canvas sources, rather than including them in stylesheets.', 'source.canvas')];\n        default:\n            return validateEnum({\n                key: `${key}.type`,\n                value: value.type,\n                valueSpec: { values: ['vector', 'raster', 'raster-dem', 'geojson', 'video', 'image'] },\n                style,\n                validateSpec,\n                styleSpec\n            });\n    }\n}\nfunction validatePromoteId({ key, value }) {\n    if (getType(value) === 'string') {\n        return validateString({ key, value });\n    }\n    else {\n        const errors = [];\n        for (const prop in value) {\n            errors.push(...validateString({ key: `${key}.${prop}`, value: value[prop] }));\n        }\n        return errors;\n    }\n}\n\nfunction validateLight(options) {\n    const light = options.value;\n    const styleSpec = options.styleSpec;\n    const lightSpec = styleSpec.light;\n    const style = options.style;\n    let errors = [];\n    const rootType = getType(light);\n    if (light === undefined) {\n        return errors;\n    }\n    else if (rootType !== 'object') {\n        errors = errors.concat([new ValidationError('light', light, `object expected, ${rootType} found`)]);\n        return errors;\n    }\n    for (const key in light) {\n        const transitionMatch = key.match(/^(.*)-transition$/);\n        if (transitionMatch && lightSpec[transitionMatch[1]] && lightSpec[transitionMatch[1]].transition) {\n            errors = errors.concat(options.validateSpec({\n                key,\n                value: light[key],\n                valueSpec: styleSpec.transition,\n                validateSpec: options.validateSpec,\n                style,\n                styleSpec\n            }));\n        }\n        else if (lightSpec[key]) {\n            errors = errors.concat(options.validateSpec({\n                key,\n                value: light[key],\n                valueSpec: lightSpec[key],\n                validateSpec: options.validateSpec,\n                style,\n                styleSpec\n            }));\n        }\n        else {\n            errors = errors.concat([new ValidationError(key, light[key], `unknown property \"${key}\"`)]);\n        }\n    }\n    return errors;\n}\n\nfunction validateSky(options) {\n    const sky = options.value;\n    const styleSpec = options.styleSpec;\n    const skySpec = styleSpec.sky;\n    const style = options.style;\n    const rootType = getType(sky);\n    if (sky === undefined) {\n        return [];\n    }\n    else if (rootType !== 'object') {\n        return [new ValidationError('sky', sky, `object expected, ${rootType} found`)];\n    }\n    let errors = [];\n    for (const key in sky) {\n        if (skySpec[key]) {\n            errors = errors.concat(options.validateSpec({\n                key,\n                value: sky[key],\n                valueSpec: skySpec[key],\n                style,\n                styleSpec\n            }));\n        }\n        else {\n            errors = errors.concat([new ValidationError(key, sky[key], `unknown property \"${key}\"`)]);\n        }\n    }\n    return errors;\n}\n\nfunction validateTerrain(options) {\n    const terrain = options.value;\n    const styleSpec = options.styleSpec;\n    const terrainSpec = styleSpec.terrain;\n    const style = options.style;\n    let errors = [];\n    const rootType = getType(terrain);\n    if (terrain === undefined) {\n        return errors;\n    }\n    else if (rootType !== 'object') {\n        errors = errors.concat([new ValidationError('terrain', terrain, `object expected, ${rootType} found`)]);\n        return errors;\n    }\n    for (const key in terrain) {\n        if (terrainSpec[key]) {\n            errors = errors.concat(options.validateSpec({\n                key,\n                value: terrain[key],\n                valueSpec: terrainSpec[key],\n                validateSpec: options.validateSpec,\n                style,\n                styleSpec\n            }));\n        }\n        else {\n            errors = errors.concat([new ValidationError(key, terrain[key], `unknown property \"${key}\"`)]);\n        }\n    }\n    return errors;\n}\n\nfunction validateFormatted(options) {\n    if (validateString(options).length === 0) {\n        return [];\n    }\n    return validateExpression(options);\n}\n\nfunction validateImage(options) {\n    if (validateString(options).length === 0) {\n        return [];\n    }\n    return validateExpression(options);\n}\n\nfunction validatePadding(options) {\n    const key = options.key;\n    const value = options.value;\n    const type = getType(value);\n    if (type === 'array') {\n        if (value.length < 1 || value.length > 4) {\n            return [new ValidationError(key, value, `padding requires 1 to 4 values; ${value.length} values found`)];\n        }\n        const arrayElementSpec = {\n            type: 'number'\n        };\n        let errors = [];\n        for (let i = 0; i < value.length; i++) {\n            errors = errors.concat(options.validateSpec({\n                key: `${key}[${i}]`,\n                value: value[i],\n                validateSpec: options.validateSpec,\n                valueSpec: arrayElementSpec\n            }));\n        }\n        return errors;\n    }\n    else {\n        return validateNumber({\n            key,\n            value,\n            valueSpec: {}\n        });\n    }\n}\n\nfunction validateVariableAnchorOffsetCollection(options) {\n    const key = options.key;\n    const value = options.value;\n    const type = getType(value);\n    const styleSpec = options.styleSpec;\n    if (type !== 'array' || value.length < 1 || value.length % 2 !== 0) {\n        return [new ValidationError(key, value, 'variableAnchorOffsetCollection requires a non-empty array of even length')];\n    }\n    let errors = [];\n    for (let i = 0; i < value.length; i += 2) {\n        // Elements in even positions should be values from text-anchor enum\n        errors = errors.concat(validateEnum({\n            key: `${key}[${i}]`,\n            value: value[i],\n            valueSpec: styleSpec['layout_symbol']['text-anchor']\n        }));\n        // Elements in odd positions should be points (2-element numeric arrays)\n        errors = errors.concat(validateArray({\n            key: `${key}[${i + 1}]`,\n            value: value[i + 1],\n            valueSpec: {\n                length: 2,\n                value: 'number'\n            },\n            validateSpec: options.validateSpec,\n            style: options.style,\n            styleSpec\n        }));\n    }\n    return errors;\n}\n\nfunction validateSprite(options) {\n    let errors = [];\n    const sprite = options.value;\n    const key = options.key;\n    if (!Array.isArray(sprite)) {\n        return validateString({\n            key,\n            value: sprite\n        });\n    }\n    else {\n        const allSpriteIds = [];\n        const allSpriteURLs = [];\n        for (const i in sprite) {\n            if (sprite[i].id && allSpriteIds.includes(sprite[i].id))\n                errors.push(new ValidationError(key, sprite, `all the sprites' ids must be unique, but ${sprite[i].id} is duplicated`));\n            allSpriteIds.push(sprite[i].id);\n            if (sprite[i].url && allSpriteURLs.includes(sprite[i].url))\n                errors.push(new ValidationError(key, sprite, `all the sprites' URLs must be unique, but ${sprite[i].url} is duplicated`));\n            allSpriteURLs.push(sprite[i].url);\n            const pairSpec = {\n                id: {\n                    type: 'string',\n                    required: true,\n                },\n                url: {\n                    type: 'string',\n                    required: true,\n                }\n            };\n            errors = errors.concat(validateObject({\n                key: `${key}[${i}]`,\n                value: sprite[i],\n                valueSpec: pairSpec,\n                validateSpec: options.validateSpec,\n            }));\n        }\n        return errors;\n    }\n}\n\nfunction validateProjection(options) {\n    const projection = options.value;\n    const styleSpec = options.styleSpec;\n    const projectionSpec = styleSpec.projection;\n    const style = options.style;\n    const rootType = getType(projection);\n    if (projection === undefined) {\n        return [];\n    }\n    else if (rootType !== 'object') {\n        return [new ValidationError('projection', projection, `object expected, ${rootType} found`)];\n    }\n    let errors = [];\n    for (const key in projection) {\n        if (projectionSpec[key]) {\n            errors = errors.concat(options.validateSpec({\n                key,\n                value: projection[key],\n                valueSpec: projectionSpec[key],\n                style,\n                styleSpec\n            }));\n        }\n        else {\n            errors = errors.concat([new ValidationError(key, projection[key], `unknown property \"${key}\"`)]);\n        }\n    }\n    return errors;\n}\n\nfunction validateProjectionDefinition(options) {\n    const key = options.key;\n    let value = options.value;\n    value = value instanceof String ? value.valueOf() : value;\n    const type = getType(value);\n    if (type === 'array' && !isProjectionDefinitionValue(value) && !isPropertyValueSpecification(value)) {\n        return [new ValidationError(key, value, `projection expected, invalid array ${JSON.stringify(value)} found`)];\n    }\n    else if (!['array', 'string'].includes(type)) {\n        return [new ValidationError(key, value, `projection expected, invalid type \"${type}\" found`)];\n    }\n    return [];\n}\nfunction isPropertyValueSpecification(value) {\n    if (['interpolate', 'step', 'literal'].includes(value[0])) {\n        return true;\n    }\n    return false;\n}\nfunction isProjectionDefinitionValue(value) {\n    return Array.isArray(value) &&\n        value.length === 3 &&\n        typeof value[0] === 'string' &&\n        typeof value[1] === 'string' &&\n        typeof value[2] === 'number';\n}\n\nconst VALIDATORS = {\n    '*'() {\n        return [];\n    },\n    'array': validateArray,\n    'boolean': validateBoolean,\n    'number': validateNumber,\n    'color': validateColor,\n    'constants': validateConstants,\n    'enum': validateEnum,\n    'filter': validateFilter,\n    'function': validateFunction,\n    'layer': validateLayer,\n    'object': validateObject,\n    'source': validateSource,\n    'light': validateLight,\n    'sky': validateSky,\n    'terrain': validateTerrain,\n    'projection': validateProjection,\n    'projectionDefinition': validateProjectionDefinition,\n    'string': validateString,\n    'formatted': validateFormatted,\n    'resolvedImage': validateImage,\n    'padding': validatePadding,\n    'variableAnchorOffsetCollection': validateVariableAnchorOffsetCollection,\n    'sprite': validateSprite,\n};\n/**\n * Main recursive validation function used internally.\n * You should use `validateStyleMin` in the browser or `validateStyle` in node env.\n * @param options - the options object\n * @param options.key - string representing location of validation in style tree. Used only\n * for more informative error reporting.\n * @param options.value - current value from style being evaluated. May be anything from a\n * high level object that needs to be descended into deeper or a simple\n * scalar value.\n * @param options.valueSpec - current spec being evaluated. Tracks value.\n * @param options.styleSpec - current full spec being evaluated.\n * @param options.validateSpec - the validate function itself\n * @param options.style - the style object\n * @param options.objectElementValidators - optional object of functions that will be called\n * @returns an array of errors, or an empty array if no errors are found.\n */\nfunction validate(options) {\n    const value = options.value;\n    const valueSpec = options.valueSpec;\n    const styleSpec = options.styleSpec;\n    options.validateSpec = validate;\n    if (valueSpec.expression && isFunction$1(unbundle(value))) {\n        return validateFunction(options);\n    }\n    else if (valueSpec.expression && isExpression(deepUnbundle(value))) {\n        return validateExpression(options);\n    }\n    else if (valueSpec.type && VALIDATORS[valueSpec.type]) {\n        return VALIDATORS[valueSpec.type](options);\n    }\n    else {\n        const valid = validateObject(extendBy({}, options, {\n            valueSpec: valueSpec.type ? styleSpec[valueSpec.type] : valueSpec\n        }));\n        return valid;\n    }\n}\n\nfunction validateGlyphsUrl(options) {\n    const value = options.value;\n    const key = options.key;\n    const errors = validateString(options);\n    if (errors.length)\n        return errors;\n    if (value.indexOf('{fontstack}') === -1) {\n        errors.push(new ValidationError(key, value, '\"glyphs\" url must include a \"{fontstack}\" token'));\n    }\n    if (value.indexOf('{range}') === -1) {\n        errors.push(new ValidationError(key, value, '\"glyphs\" url must include a \"{range}\" token'));\n    }\n    return errors;\n}\n\n/**\n * Validate a MapLibre style against the style specification.\n * Use this when running in the browser.\n *\n * @param style - The style to be validated.\n * @param styleSpec - The style specification to validate against.\n * If omitted, the latest style spec is used.\n * @returns an array of errors, or an empty array if no errors are found.\n * @example\n *   const validate = require('@maplibre/maplibre-gl-style-spec/').validateStyleMin;\n *   const errors = validate(style);\n */\nfunction validateStyleMin(style, styleSpec = v8Spec) {\n    let errors = [];\n    errors = errors.concat(validate({\n        key: '',\n        value: style,\n        valueSpec: styleSpec.$root,\n        styleSpec,\n        style,\n        validateSpec: validate,\n        objectElementValidators: {\n            glyphs: validateGlyphsUrl,\n            '*'() {\n                return [];\n            }\n        }\n    }));\n    if (style['constants']) {\n        errors = errors.concat(validateConstants({\n            key: 'constants',\n            value: style['constants'],\n            style,\n            styleSpec,\n            validateSpec: validate,\n        }));\n    }\n    return sortErrors(errors);\n}\nvalidateStyleMin.source = wrapCleanErrors(injectValidateSpec(validateSource));\nvalidateStyleMin.sprite = wrapCleanErrors(injectValidateSpec(validateSprite));\nvalidateStyleMin.glyphs = wrapCleanErrors(injectValidateSpec(validateGlyphsUrl));\nvalidateStyleMin.light = wrapCleanErrors(injectValidateSpec(validateLight));\nvalidateStyleMin.sky = wrapCleanErrors(injectValidateSpec(validateSky));\nvalidateStyleMin.terrain = wrapCleanErrors(injectValidateSpec(validateTerrain));\nvalidateStyleMin.layer = wrapCleanErrors(injectValidateSpec(validateLayer));\nvalidateStyleMin.filter = wrapCleanErrors(injectValidateSpec(validateFilter));\nvalidateStyleMin.paintProperty = wrapCleanErrors(injectValidateSpec(validatePaintProperty));\nvalidateStyleMin.layoutProperty = wrapCleanErrors(injectValidateSpec(validateLayoutProperty));\nfunction injectValidateSpec(validator) {\n    return function (options) {\n        return validator({\n            ...options,\n            validateSpec: validate,\n        });\n    };\n}\nfunction sortErrors(errors) {\n    return [].concat(errors).sort((a, b) => {\n        return a.line - b.line;\n    });\n}\nfunction wrapCleanErrors(inner) {\n    return function (...args) {\n        return sortErrors(inner.apply(this, args));\n    };\n}\n\n// Note: This regex matches even invalid JSON strings, but since we’re\n// working on the output of `JSON.stringify` we know that only valid strings\n// are present (unless the user supplied a weird `options.indent` but in\n// that case we don’t care since the output would be invalid anyway).\nconst stringOrChar = /(\"(?:[^\\\\\"]|\\\\.)*\")|[:,]/g;\n\nfunction stringify(passedObj, options = {}) {\n  const indent = JSON.stringify(\n    [1],\n    undefined,\n    options.indent === undefined ? 2 : options.indent\n  ).slice(2, -3);\n\n  const maxLength =\n    indent === \"\"\n      ? Infinity\n      : options.maxLength === undefined\n      ? 80\n      : options.maxLength;\n\n  let { replacer } = options;\n\n  return (function _stringify(obj, currentIndent, reserved) {\n    if (obj && typeof obj.toJSON === \"function\") {\n      obj = obj.toJSON();\n    }\n\n    const string = JSON.stringify(obj, replacer);\n\n    if (string === undefined) {\n      return string;\n    }\n\n    const length = maxLength - currentIndent.length - reserved;\n\n    if (string.length <= length) {\n      const prettified = string.replace(\n        stringOrChar,\n        (match, stringLiteral) => {\n          return stringLiteral || `${match} `;\n        }\n      );\n      if (prettified.length <= length) {\n        return prettified;\n      }\n    }\n\n    if (replacer != null) {\n      obj = JSON.parse(string);\n      replacer = undefined;\n    }\n\n    if (typeof obj === \"object\" && obj !== null) {\n      const nextIndent = currentIndent + indent;\n      const items = [];\n      let index = 0;\n      let start;\n      let end;\n\n      if (Array.isArray(obj)) {\n        start = \"[\";\n        end = \"]\";\n        const { length } = obj;\n        for (; index < length; index++) {\n          items.push(\n            _stringify(obj[index], nextIndent, index === length - 1 ? 0 : 1) ||\n              \"null\"\n          );\n        }\n      } else {\n        start = \"{\";\n        end = \"}\";\n        const keys = Object.keys(obj);\n        const { length } = keys;\n        for (; index < length; index++) {\n          const key = keys[index];\n          const keyPart = `${JSON.stringify(key)}: `;\n          const value = _stringify(\n            obj[key],\n            nextIndent,\n            keyPart.length + (index === length - 1 ? 0 : 1)\n          );\n          if (value !== undefined) {\n            items.push(keyPart + value);\n          }\n        }\n      }\n\n      if (items.length > 0) {\n        return [start, indent + items.join(`,\\n${nextIndent}`), end].join(\n          `\\n${currentIndent}`\n        );\n      }\n    }\n\n    return string;\n  })(passedObj, \"\", 0);\n}\n\nfunction sortKeysBy(obj, reference) {\n    const result = {};\n    for (const key in reference) {\n        if (obj[key] !== undefined) {\n            result[key] = obj[key];\n        }\n    }\n    for (const key in obj) {\n        if (result[key] === undefined) {\n            result[key] = obj[key];\n        }\n    }\n    return result;\n}\n/**\n * Format a MapLibre Style.  Returns a stringified style with its keys\n * sorted in the same order as the reference style.\n *\n * The optional `space` argument is passed to\n * [`JSON.stringify`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify)\n * to generate formatted output.\n *\n * If `space` is unspecified, a default of `2` spaces will be used.\n *\n * @private\n * @param {Object} style a MapLibre Style\n * @param {number} [space] space argument to pass to `JSON.stringify`\n * @returns {string} stringified formatted JSON\n * @example\n * var fs = require('fs');\n * var format = require('maplibre-gl-style-spec').format;\n * var style = fs.readFileSync('./source.json', 'utf8');\n * fs.writeFileSync('./dest.json', format(style));\n * fs.writeFileSync('./dest.min.json', format(style, 0));\n */\nfunction format(style, space = 2) {\n    style = sortKeysBy(style, v8Spec.$root);\n    if (style.layers) {\n        style.layers = style.layers.map((layer) => sortKeysBy(layer, v8Spec.layer));\n    }\n    return stringify(style, { indent: space });\n}\n\nfunction eachLayout(layer, callback) {\n    for (const k in layer) {\n        if (k.indexOf('layout') === 0) {\n            callback(layer[k], k);\n        }\n    }\n}\nfunction eachPaint(layer, callback) {\n    for (const k in layer) {\n        if (k.indexOf('paint') === 0) {\n            callback(layer[k], k);\n        }\n    }\n}\nfunction resolveConstant(style, value) {\n    if (typeof value === 'string' && value[0] === '@') {\n        return resolveConstant(style, style.constants[value]);\n    }\n    else {\n        return value;\n    }\n}\nfunction isFunction(value) {\n    return Array.isArray(value.stops);\n}\nfunction renameProperty(obj, from, to) {\n    obj[to] = obj[from];\n    delete obj[from];\n}\nfunction migrateV8(style) {\n    style.version = 8;\n    // Rename properties, reverse coordinates in source and layers\n    eachSource(style, (source) => {\n        if (source.type === 'video' && source['url'] !== undefined) {\n            renameProperty(source, 'url', 'urls');\n        }\n        if (source.type === 'video') {\n            source.coordinates.forEach((coord) => {\n                return coord.reverse();\n            });\n        }\n    });\n    eachLayer(style, (layer) => {\n        eachLayout(layer, (layout) => {\n            if (layout['symbol-min-distance'] !== undefined) {\n                renameProperty(layout, 'symbol-min-distance', 'symbol-spacing');\n            }\n        });\n        eachPaint(layer, (paint) => {\n            if (paint['background-image'] !== undefined) {\n                renameProperty(paint, 'background-image', 'background-pattern');\n            }\n            if (paint['line-image'] !== undefined) {\n                renameProperty(paint, 'line-image', 'line-pattern');\n            }\n            if (paint['fill-image'] !== undefined) {\n                renameProperty(paint, 'fill-image', 'fill-pattern');\n            }\n        });\n    });\n    // Inline Constants\n    eachProperty(style, { paint: true, layout: true }, (property) => {\n        const value = resolveConstant(style, property.value);\n        if (isFunction(value)) {\n            value.stops.forEach((stop) => {\n                stop[1] = resolveConstant(style, stop[1]);\n            });\n        }\n        property.set(value);\n    });\n    delete style['constants'];\n    eachLayer(style, (layer) => {\n        // get rid of text-max-size, icon-max-size\n        // turn text-size, icon-size into layout properties\n        // https://github.com/mapbox/mapbox-gl-style-spec/issues/255\n        eachLayout(layer, (layout) => {\n            delete layout['text-max-size'];\n            delete layout['icon-max-size'];\n        });\n        eachPaint(layer, (paint) => {\n            if (paint['text-size']) {\n                if (!layer.layout)\n                    layer.layout = {};\n                layer.layout['text-size'] = paint['text-size'];\n                delete paint['text-size'];\n            }\n            if (paint['icon-size']) {\n                if (!layer.layout)\n                    layer.layout = {};\n                layer.layout['icon-size'] = paint['icon-size'];\n                delete paint['icon-size'];\n            }\n        });\n    });\n    function migrateFontStack(font) {\n        function splitAndTrim(string) {\n            return string.split(',').map((s) => {\n                return s.trim();\n            });\n        }\n        if (Array.isArray(font)) {\n            // Assume it's a previously migrated font-array.\n            return font;\n        }\n        else if (typeof font === 'string') {\n            return splitAndTrim(font);\n        }\n        else if (typeof font === 'object') {\n            font.stops.forEach((stop) => {\n                stop[1] = splitAndTrim(stop[1]);\n            });\n            return font;\n        }\n        else {\n            throw new Error('unexpected font value');\n        }\n    }\n    eachLayer(style, (layer) => {\n        eachLayout(layer, (layout) => {\n            if (layout['text-font']) {\n                layout['text-font'] = migrateFontStack(layout['text-font']);\n            }\n        });\n    });\n    // Reverse order of symbol layers. This is an imperfect migration.\n    //\n    // The order of a symbol layer in the layers list affects two things:\n    // - how it is drawn relative to other layers (like oneway arrows below bridges)\n    // - the placement priority compared to other layers\n    //\n    // It's impossible to reverse the placement priority without breaking the draw order\n    // in some cases. This migration only reverses the order of symbol layers that\n    // are above all other types of layers.\n    //\n    // Symbol layers that are at the top of the map preserve their priority.\n    // Symbol layers that are below another type (line, fill) of layer preserve their draw order.\n    let firstSymbolLayer = 0;\n    for (let i = style.layers.length - 1; i >= 0; i--) {\n        const layer = style.layers[i];\n        if (layer.type !== 'symbol') {\n            firstSymbolLayer = i + 1;\n            break;\n        }\n    }\n    const symbolLayers = style.layers.splice(firstSymbolLayer);\n    symbolLayers.reverse();\n    style.layers = style.layers.concat(symbolLayers);\n    return style;\n}\n\n/**\n * Migrate the given style object in place to use expressions. Specifically,\n * this will convert (a) \"stop\" functions, and (b) legacy filters to their\n * expression equivalents.\n * @param style The style object to migrate.\n * @returns The migrated style object.\n */\nfunction expressions(style) {\n    const converted = [];\n    eachLayer(style, (layer) => {\n        if (layer.filter) {\n            layer.filter = convertFilter(layer.filter);\n        }\n    });\n    eachProperty(style, { paint: true, layout: true }, ({ path, value, reference, set }) => {\n        if (isExpression(value))\n            return;\n        if (typeof value === 'object' && !Array.isArray(value)) {\n            set(convertFunction(value, reference));\n            converted.push(path.join('.'));\n        }\n        else if (reference.tokens && typeof value === 'string') {\n            set(convertTokenString(value));\n        }\n    });\n    return style;\n}\n\n/**\n * Migrate color style values to supported format.\n *\n * @param colorToMigrate Color value to migrate, could be a string or an expression.\n * @returns Color style value in supported format.\n */\nfunction migrateColors(colorToMigrate) {\n    return JSON.parse(migrateHslColors(JSON.stringify(colorToMigrate)));\n}\n/**\n * Created to migrate from colors supported by the former CSS color parsing\n * library `csscolorparser` but not compliant with the CSS Color specification,\n * like `hsl(900, 0.15, 90%)`.\n *\n * @param colorToMigrate Serialized color style value.\n * @returns A serialized color style value in which all non-standard hsl color values\n * have been converted to a format that complies with the CSS Color specification.\n *\n * @example\n * migrateHslColors('\"hsl(900, 0.15, 90%)\"'); // returns '\"hsl(900, 15%, 90%)\"'\n * migrateHslColors('\"hsla(900, .15, .9)\"'); // returns '\"hsl(900, 15%, 90%)\"'\n * migrateHslColors('\"hsl(900, 15%, 90%)\"'); // returns '\"hsl(900, 15%, 90%)\"' - no changes\n */\nfunction migrateHslColors(colorToMigrate) {\n    return colorToMigrate.replace(/\"hsla?\\((.+?)\\)\"/gi, (match, hslArgs) => {\n        const argsMatch = hslArgs.match(/^(.+?)\\s*,\\s*(.+?)\\s*,\\s*(.+?)(?:\\s*,\\s*(.+))?$/i);\n        if (argsMatch) {\n            let [h, s, l, a] = argsMatch.slice(1);\n            [s, l] = [s, l].map(v => v.endsWith('%') ? v : `${parseFloat(v) * 100}%`);\n            return `\"hsl${typeof a === 'string' ? 'a' : ''}(${[h, s, l, a].filter(Boolean).join(',')})\"`;\n        }\n        return match;\n    });\n}\n\n/**\n * Migrate a Mapbox/MapLibre GL Style to the latest version.\n *\n * @param style - a MapLibre Style\n * @returns a migrated style\n * @example\n * const fs = require('fs');\n * const migrate = require('@maplibre/maplibre-gl-style-spec').migrate;\n * const style = fs.readFileSync('./style.json', 'utf8');\n * fs.writeFileSync('./style.json', JSON.stringify(migrate(style)));\n */\nfunction migrate(style) {\n    let migrated = false;\n    if (style.version === 7) {\n        style = migrateV8(style);\n        migrated = true;\n    }\n    if (style.version === 8) {\n        migrated = !!expressions(style);\n        migrated = true;\n    }\n    eachProperty(style, { paint: true, layout: true }, ({ value, reference, set }) => {\n        if (reference.type === 'color') {\n            set(migrateColors(value));\n        }\n    });\n    if (!migrated) {\n        throw new Error(`Cannot migrate from ${style.version}`);\n    }\n    return style;\n}\n\nconst v8 = v8Spec;\nconst expression = {\n    StyleExpression,\n    StylePropertyFunction,\n    ZoomConstantExpression,\n    ZoomDependentExpression,\n    createExpression,\n    createPropertyExpression,\n    isExpression,\n    isExpressionFilter,\n    isZoomExpression,\n    normalizePropertyExpression,\n};\nconst styleFunction = {\n    convertFunction,\n    createFunction,\n    isFunction: isFunction$1\n};\nconst visit = { eachLayer, eachProperty, eachSource };\n\nexport { Color, ColorType, CompoundExpression, EvaluationContext, FormatExpression, Formatted, FormattedSection, FormattedType, Interpolate, Literal, NullType, Padding, ParsingError, ProjectionDefinition, ProjectionDefinitionType, ResolvedImage, Step, StyleExpression, StylePropertyFunction, ValidationError, VariableAnchorOffsetCollection, ZoomConstantExpression, ZoomDependentExpression, classifyRings, convertFilter, convertFunction, createExpression, createFunction, createPropertyExpression, derefLayers, diff, emptyStyle, expression, expressions$1 as expressions, featureFilter, format, styleFunction as function, groupByLayout, interpolateFactory as interpolates, isExpression, isFunction$1 as isFunction, isZoomExpression, v8Spec as latest, migrate, normalizePropertyExpression, supportsPropertyExpression, typeToString as toString, typeOf, v8, validate, validateStyleMin, visit };\n//# sourceMappingURL=index.mjs.map\n","\nimport type {\n\tIControl,\n\tMap,\n\tControlPosition,\n} from 'maplibre-gl';\n\nimport { expression } from \"@maplibre/maplibre-gl-style-spec\";\nimport type { Expression } from \"@maplibre/maplibre-gl-style-spec\";\n\ntype Options = {\n  title: string;    // show title at the top of the color bar\n  unit: string;     // show unit at the bottom of the color bar\n\tposition?: ControlPosition;   // Optional position with a default top-left position\n  width?: string;   // Optional width with a default 56px\n  height?: string;  // Optional width with a default 272px\n  max?: number;     // Optional max with a default 30\n  decimal?: number; // Optional decimal with a default 1\n};\n\ninterface ColorStep {\n  speed: number;\n  color: string;\n}\n\nexport default class ColorBar implements IControl {\n\tprivate map: Map | undefined;\n\tprivate options: Options;\n\n  private colorSteps: ColorStep[];\n  private container: HTMLElement;\n  private outContainer: HTMLElement;\n  private titleDiv: HTMLElement;\n  private unitDiv: HTMLElement;\n  private legendItems: HTMLElement[] = [];\n\n  propertySpec: Record<string, any>;\n\n  constructor(propertySpec: any, options: Options) {\n    if (!propertySpec) {\n      this.propertySpec = {\n        \"fill-color\": {\n          default: [\n            \"step\",\n            [\"get\", \"speed\"],\n            \"#ff3f00\", // Default color for speed < 0.10\n            0.10, \"#ff7e00\",\n            0.15, \"#ffbe00\",\n            0.20, \"#fffd00\",\n            0.25, \"#c0ff00\",\n            0.30, \"#81ff00\",\n            0.35, \"#41ff00\",\n            0.40, \"#02ff00\",\n            0.45, \"#00ff3d\",\n            0.50, \"#00ff7c\",\n            0.55, \"#00ffbc\",\n            0.60, \"#00fffb\",\n            0.65, \"#00c2ff\",\n            0.70, \"#0083ff\",\n            0.75, \"#0043ff\",\n            0.80, \"#0004ff\",\n            0.85, \"#3b00ff\",\n            0.90, \"#7a00ff\",\n            0.95, \"#ba00ff\",\n            0.98, \"#f900ff\",\n            1.00, \"#f900ff\",\n          ],\n          doc: \"The color of each pixel of this layer\",\n          expression: {\n            interpolated: true,\n            parameters: [\"zoom\", \"feature\"]\n          },\n          \"property-type\": \"data-driven\"\n        },\n        \"fill-opacity\": {\n          type: \"number\",\n          default: 0.5,\n          minimum: 0,\n          maximum: 1,\n          transition: true,\n          expression: {\n            interpolated: true,\n            parameters: [\"zoom\"]\n          },\n          \"property-type\": \"data-constant\"\n        }\n      };\n    } else {\n      this.propertySpec = propertySpec;\n    }\n\n\t\tthis.options = {\n\t    position: \"top-left\",\n      width: \"56px\",    // Default width\n      height: \"272px\",  // Default width\n      max: 30,          // Default max\n      decimal: 1,          // Default max\n      ...options,       // Override with user-provided options\n    };\n\n    this.colorSteps = this.getColorSteps();\n\n    const { outContainer, innerContainer } = this.createContainer();\n    this.outContainer = outContainer;\n    this.container = innerContainer;\n    this.titleDiv = this.createTitleDiv(this.options.title);\n    this.unitDiv = this.createUnitDiv(this.options.unit);\n\n    this.container.appendChild(this.titleDiv);\n    this.container.appendChild(this.unitDiv);\n\n  }\n\n\tprivate getWidth(): string {\n\t\treturn this.options.width || \"52px\";\n\t}\n\n\tprivate getHeight(): string {\n\t\treturn this.options.height || \"272px\";\n\t}\n\n  private getHeightInPixels(): number {\n    const heightExpression = this.getHeight();\n    if (heightExpression.endsWith('px')) {\n      return parseFloat(heightExpression);\n    }\n\n    if (heightExpression.endsWith('%')) {\n      const parentHeight = this.outContainer.offsetHeight;\n      const percentage = parseFloat(heightExpression) / 100;\n      return parentHeight * percentage;\n    }\n\n    return 272;\n  }\n\n\tprivate createContainer(): { outContainer: HTMLElement; innerContainer: HTMLElement } {\n\t  // Outer container\n\t  const outContainer = document.createElement(\"div\");\n\t  outContainer.classList.add(\"maplibregl-ctrl\");\n\t\n\t  // Outer container styles\n\t  outContainer.style.height = \"100%\"; // Fixed or dynamically adjustable height\n\t  outContainer.style.display = \"flex\";\n\t  outContainer.style.flexDirection = \"column\";\n\t  outContainer.style.alignItems = \"center\";\n    outContainer.style.backgroundColor = \"transparent\"; \n\n\t  // Inner container\n    const group = this.options.position?.endsWith(\"left\")\n     ? \"map-colorbar-left-group\"\n     : \"map-colorbar-right-group\";\n\t  const innerContainer = document.createElement(\"div\");\n\t  innerContainer.classList.add(group);\n\t\n\t  // Inner container styles\n\t  innerContainer.style.width = this.getWidth();\n\t  innerContainer.style.height = `calc(min((100% - 29px), ${this.getHeight()}))`;\n\t  innerContainer.style.backgroundColor = \"rgba(0, 36, 71, 0.8)\";\n\t  innerContainer.style.display = \"flex\";\n\t  innerContainer.style.flexDirection = \"column\";\n\t\tinnerContainer.style.borderRadius = \"10px\";\n\t\n\t  // Add inner container to outer container\n\t  outContainer.appendChild(innerContainer);\n\t\n\t  // Return the inner container for further manipulation\n\t  return { outContainer, innerContainer };\n\t}\n\n  private createTitleDiv(title: string): HTMLElement {\n    const titleDiv = document.createElement(\"div\");\n    titleDiv.innerHTML = title;\n    titleDiv.style.marginTop = \"6px\";\n    titleDiv.style.marginBottom = \"8px\";\n    titleDiv.style.display = \"flex\";\n\t\ttitleDiv.style.justifyContent = \"center\"; \n\t\ttitleDiv.style.textAlign = \"center\";\n    titleDiv.style.fontSize = \"11px\";\n\t\ttitleDiv.style.lineHeight = \"14px\";\n    titleDiv.style.color = \"white\";\n\t  titleDiv.style.width = this.getWidth();\n    return titleDiv;\n  }\n\n  private createUnitDiv(unit: string): HTMLElement {\n    const unitDiv = document.createElement(\"div\");\n    unitDiv.classList.add(\"map_colorbar_unit\");\n    unitDiv.innerHTML = `(${unit})`;\n    unitDiv.style.marginTop = \"8px\";\n\t  unitDiv.style.width = this.getWidth(); // Fixed or dynamically adjustable width\n    unitDiv.style.display = \"flex\";\n\t\tunitDiv.style.justifyContent = \"center\"; \n    unitDiv.style.color = \"white\";\n    unitDiv.style.fontSize = \"12px\";\n\t\tunitDiv.style.textAlign = \"center\";\n    return unitDiv;\n  }\n\n  private createColorBox(color: string): HTMLElement {\n    const colorBox = document.createElement(\"div\");\n    colorBox.classList.add(\"map_colorbar_color_box\");\n    colorBox.style.width = \"12px\";\n    colorBox.style.backgroundColor = color;\n    return colorBox;\n  }\n\n  private createLabel(_step: ColorStep): HTMLElement {\n    const label = document.createElement(\"div\");\n    label.classList.add(\"map_colorbar_label\");\n    label.style.marginLeft = \"0px\";\n    label.style.marginRight = \"2px\";\n    label.style.color = \"white\";\n    label.style.fontSize = \"10px\";\n    label.textContent = \"\";\n    return label;\n  }\n\n  private initializeLegendItems(): void {\n    this.colorSteps.forEach(({ speed, color }) => {\n      const legendItem = document.createElement(\"div\");\n      legendItem.classList.add(\"map_colorbar_item\");\n      legendItem.style.display = \"flex\";\n      legendItem.style.alignItems = \"center\";\n      legendItem.style.marginBottom = \"0px\";\n      legendItem.style.marginLeft = \"10px\";\n\n      const colorBox = this.createColorBox(color);\n      const label = this.createLabel({speed, color});\n\n      legendItem.appendChild(colorBox);\n      legendItem.appendChild(label);\n      this.legendItems.push(legendItem);\n      this.container.insertBefore(legendItem, this.unitDiv); // 插入 unitDiv 之前\n    });\n  }\n\n  private calculateHeights(): { stepHeight: number; showInterval: number } {\n    const h = this.getHeightInPixels();\n    const containerHeight = (this.container.getBoundingClientRect().height\n                               ? this.container.getBoundingClientRect().height\n                               : h);\n    const totalMargin = 6 + 8 + 8;\n    const stepsHeight = (containerHeight - this.titleDiv.offsetHeight\n                        - this.unitDiv.offsetHeight - totalMargin);\n\n    const stepHeight = Math.max(Math.floor(stepsHeight / this.colorSteps.length), 5);\n    const showInterval = Math.ceil(20 * this.colorSteps.length / stepsHeight);\n\n    return { stepHeight, showInterval };\n  }\n\n  public update(): void {\n    this.updateInnerContainerStyle(this.outContainer, this.container);\n    const { stepHeight, showInterval } = this.calculateHeights();\n\n    [...this.legendItems].reverse().forEach((legendItem, index) => {\n      const colorBox = legendItem.querySelector(\".map_colorbar_color_box\") as HTMLElement;\n      const label = legendItem.querySelector(\".map_colorbar_label\") as HTMLElement;\n\n      legendItem.style.height = `${stepHeight}px`;\n      colorBox.style.height = `${stepHeight}px`;\n      let reverseIndex = this.colorSteps.length - 1 - index;\n\n      if (\n        index % showInterval !== 0\n      ) {\n        label.textContent = \"\";\n      } else {\n        label.textContent = `- ${this.colorSteps[reverseIndex]\n                                  .speed.toFixed(this.options.decimal)}`;\n      }\n    });\n  }\n\n  onAdd(map: Map): HTMLElement {\n    this.map = map;\n\t\tmap.getContainer().appendChild(this.outContainer);\n\n    this.initializeLegendItems();\n    this.update();\n\n\t\tthis.map.once('styledata', () => {\n\t\t\tthis.refresh();\n\t\t});\n\n    this.map.on('resize', () => {\n      this.update();\n    });\n\n\t\treturn this.outContainer;\n  }\n\n  onRemove(): void {\n    if (this.map) {\n      this.map.off('resize', this.update);\n      this.map.off('styledata', this.refresh);\n    }\n    this.container.parentNode?.removeChild(this.container);\n    this.outContainer.parentNode?.removeChild(this.outContainer);\n\t\tthis.map = undefined;\n  }\n\n\trefresh() {\n\t}\n\n  getDefaultPosition(): ControlPosition {\n    return this.options.position || 'top-left';\n  };\n\n\tupdateInnerContainerStyle(outContainer: HTMLElement, container: HTMLElement): void {\n    if (!this.map) {\n      return;\n    }\n    const parentContainer = this.map.getContainer();\n\t  const parentWidth = parentContainer.offsetWidth;\n\t  const parentHeight = parentContainer.offsetHeight;\n\n    outContainer.style.height = `${parentHeight}px`;\n\n\t  // Default styles\n\t  let marginTop = 10;\n\t  let marginBottom = 10;\n\t\tlet defMarginLeft = Math.max(\n\t\t  10,\n\t\t  parseFloat(\n\t\t    getComputedStyle(parentContainer)\n\t\t\t\t\t.getPropertyValue('env(safe-area-inset-left)') || '0'\n\t\t  )\n\t\t);\n    let defMarginRight = Math.max(\n\t\t  10,\n\t\t  parseFloat(\n\t\t    getComputedStyle(parentContainer)\n\t\t\t\t\t.getPropertyValue('env(safe-area-inset-right)') || '0'\n\t\t  )\n\t\t);\n\t\tlet marginLeft = defMarginLeft;\n\t\tlet marginRight = defMarginRight;\n\t\n\t  // Update styles based on parent dimensions\n\t  if (parentWidth >= 480) {\n\t    marginTop = 15;\n\t    marginBottom = 15;\n\t    marginLeft = Math.max(15, defMarginLeft);\n\t    marginRight = Math.max(15, defMarginRight);\n\t  }\n\n\t  if (parentWidth >= 992 && parentHeight >= 992) {\n\t    marginTop = 40;\n\t    marginBottom = 40;\n\t    marginLeft = Math.max(40, defMarginLeft);\n\t    marginRight = Math.max(40, defMarginRight);\n    }\n\n    if (this.options.position?.endsWith(\"left\")) {\n      container.style.marginLeft = `${marginLeft}px`;\n      container.style.marginRight = `${defMarginRight}px`;\n    } else {\n      container.style.marginLeft = `${defMarginLeft}px`;\n      container.style.marginRight = `${marginRight}px`;\n\t\t}\n\n    // Apply styles to innerContainer\n    container.style.marginTop = `${marginTop}px`;\n    container.style.marginBottom = `${marginBottom}px`;\n  \n    container.style.alignItems = 'flex-start';\n    container.style.display = 'flex'; // Ensures `align-items` works\n\t  container.style.height = `calc(min((100% - 29px), ${this.getHeight()}))`;\n  }\n\n  /**\n   * Parses the \"fill-color\" property and extracts speed-to-color mappings.\n   * @returns An array of speed thresholds and their corresponding colors.\n   */\n  getColorSteps(): ColorStep[] {\n    const colorSpec = this.propertySpec[\"fill-color\"];\n    if (!colorSpec) {\n      throw new Error(\"Missing 'fill-color' specification.\");\n    }\n  \n    const colorSteps = colorSpec.default || colorSpec;\n    const stepType = colorSteps[0];\n  \n    if (stepType !== \"step\") {\n      throw new Error(\"Only 'step' expressions are supported.\");\n    }\n  \n    const steps: ColorStep[] = [];\n    const [, , defaultColor, ...pairs] = colorSteps;\n  \n    const maxSpeed: number = this.options?.max || 30;\n  \n    // Add default color for speed < first threshold\n    steps.push({ speed: 0, color: defaultColor });\n  \n    // Extract speed thresholds and colors\n    for (let i = 0; i < pairs.length; i += 2) {\n      const speed = pairs[i] as number;\n      const absSpeed = speed * maxSpeed;\n      const color = pairs[i + 1] as string;\n      steps.push({ speed: absSpeed, color });\n    }\n  \n    // Sort steps by speed in ascending order\n    return steps.sort((a, b) => b.speed - a.speed);\n  }\n\n\n  /**\n   * Sets a property using a Mapbox style expression.\n   * @param prop The property name.\n   * @param value The Mapbox style expression.\n   */\n  setProperty(prop: string, value: Expression) {\n    const spec = this.propertySpec[prop];\n    if (!spec) {\n      throw new Error(`Property \"${prop}\" is not defined in the specification.`);\n    }\n\n    const expr = expression.createPropertyExpression(value, spec);\n    if (expr.result === \"success\") {\n      switch (expr.value.kind) {\n        case \"camera\":\n        case \"composite\":\n          // Example: handle zoom-dependent properties\n          console.log(`Camera/composite expression set for property \"${prop}\"`);\n          break;\n        default:\n          // Example: handle constant or other property types\n          console.log(`Property \"${prop}\" set with value`, expr.value);\n          break;\n      }\n    } else {\n      throw new Error(`Invalid expression for property \"${prop}\": ${expr.value}`);\n    }\n  }\n}\n\n"],"names":["pauseSvg","playSvg","reloadSvg","skipBackwardSvg","skipForwardSvg","ACTIVE_BUTTON_COLOR","makeImg","svg","img","timerId","makeContainer","length","interval","onSliderValueChange","container","titleDiv","slider","buttonsDiv","setLoopEnabled","enabled","loopButton","isLoopEnabled","decrement","increment","prevButton","pause","pauseButton","playButton","isPlaying","play","nextButton","TemporalControl","temporalFrames","options","__publicField","containerOptions","idx","map","_a","sliderValue","visibleLayerIds","layer","temporalFrame","isVisible","opacity","_b","_c","_d","extendBy","output","inputs","input","k","ExpressionParsingError","key","message","Scope","parent","bindings","name","expression","NullType","NumberType","StringType","BooleanType","ColorType","ProjectionDefinitionType","ObjectType","ValueType","ErrorType","CollatorType","FormattedType","PaddingType","ResolvedImageType","VariableAnchorOffsetCollectionType","array","itemType","N","typeToString","type","valueMemberTypes","checkSubtype","expected","t","memberType","isValidType","provided","allowedTypes","isValidNativeType","verifyType","sample","Xn","Yn","Zn","t0","t1","t2","t3","deg2rad","rad2deg","constrainAngle","angle","rgbToLab","r","g","b","alpha","rgb2xyz","x","z","y","xyz2lab","l","labToRgb","a","lab2xyz","xyz2rgb","rgbToHcl","rgbColor","c","hclToRgb","h","hslToRgb","s","f","n","parseCssColor","namedColorsMatch","namedColors","step","i","parseHex","rgbRegExp","rgbMatch","_","rp","f1","gp","f2","bp","f3","ap","argFormat","valFormat","maxValue","rgba","clamp","parseAlpha","validateNumbers","hslRegExp","hslMatch","hsla","hex","asPercentage","min","max","interpolateNumber","from","to","interpolateArray","d","isSupportedInterpolationColorSpace","colorSpace","Color","premultiplied","getterKey","lazyValue","spaceKey","hue0","chroma0","light0","alphaF","hue1","chroma1","light1","alphaT","hue","chroma","dh","Collator","caseSensitive","diacriticSensitive","locale","lhs","rhs","FormattedSection","text","image","scale","fontStack","textColor","Formatted","sections","unformatted","section","Padding","values","val","RuntimeError","anchors","VariableAnchorOffsetCollection","anchorValue","offsetValue","fromValues","toValues","fx","fy","tx","ty","ResolvedImage","ProjectionDefinition","transition","validateRGBA","isValue","mixed","item","typeOf","value","valueToString","Literal","args","context","types$1","Assertion","parsed","ctx","fn","arg","types","Coercion","error","pad","coll","num","classifyRings","rings","maxRings","polygons","polygon","ccw","ring","area","calculateSignedArea","sum","len","j","p1","p2","hasMultipleOuterRings","direction","geometryTypes","simpleGeometryType","EvaluationContext","geometryType","geom","cached","ParsingContext","registry","isConstantFunc","path","expectedType","scope","errors","part","expr","index","annotate","typeAnnotation","op","Expr","actual","ec","e","keys","Let","result","binding","Var","boundExpression","At","In","needle","haystack","IndexOf","fromIndex","rawIndex","Match","inputType","outputType","cases","outputs","otherwise","labels","labelContext","label","out","Case","branches","test","Slice","beginIndex","endIndex","findStopLessThanOrEqualTo","stops","lastIndex","lowerIndex","upperIndex","currentIndex","currentValue","nextValue","Step","labelKey","valueKey","stopCount","getDefaultExportFromCjs","unitbezier","hasRequiredUnitbezier","requireUnitbezier","UnitBezier","p1x","p1y","p2x","p2y","epsilon","x2","d2","unitbezierExports","Interpolate","operator","interpolation","lower","upper","exponentialInterpolation","rest","base","controlPoints","outputLower","outputUpper","lowerValue","upperValue","difference","progress","interpolateFactory","Coalesce","parsedArgs","argCount","requestedImageName","isComparableType","eq","neq","lt","gt","lteq","gteq","eqCollate","neqCollate","ltCollate","gtCollate","lteqCollate","gteqCollate","makeComparison","compareBasic","compareWithCollator","isOrderComparison","Comparison","collator","rt","Equals","NotEquals","LessThan","GreaterThan","LessThanOrEqual","GreaterThanOrEqual","CollatorExpression","NumberFormat","number","currency","minFractionDigits","maxFractionDigits","FormatExpression","firstArg","nextTokenMayBeObject","font","lastExpression","content","kind","evaluateSection","evaluatedContent","ImageExpression","evaluatedImageName","Length","EXTENT","getTileCoordinates","p","canonical","mercatorXfromLng","mercatorYfromLat","tilesAtZoom","getLngLatFromTileCoord","coord","lngFromMercatorXfromLng","latFromMercatorY","lng","mercatorX","lat","mercatorY","updateBBox","bbox","boxWithinBox","bbox1","bbox2","rayIntersect","pointOnBoundary","x1","y1","y2","segmentIntersectSegment","vectorP","vectorQ","perp","twoSided","lineIntersectPolygon","pointWithinPolygon","point","trueIfOnBoundary","inside","pointWithinPolygons","lineStringWithinPolygon","line","lineStringWithinPolygons","v1","v2","q1","q2","x3","y3","det1","det2","getTilePolygon","coordinates","getTilePolygons","updatePoint","polyBBox","worldSize","halfWorldSize","shift","resetBBox","getTilePoints","geometry","pointBBox","shifts","tilePoints","points","getTileLines","lineBBox","tileLines","tileLine","pointsWithinPolygons","polygonGeometry","tilePolygon","tilePolygons","linesWithinPolygons","Within","geojson","geometries","polygonsCoords","multipolygonWrapper","TinyQueue","data","compare","top","bottom","pos","current","halfLength","bestChild","right","RE","FE","E2","RAD","CheapRuler","m","coslat","w2","w","dx","dy","minDist","minX","minY","minI","minT","sqDist","deg","MinPointsSize","MinLinePointsSize","compareDistPair","getRangeSize","range","isRangeSafe","threshold","splitRange","isLine","size","size1","getBBox","coords","getPolygonBBox","isValidBBox","bboxToBBoxDistance","ruler","pointToLineDistance","nearestPoint","segmentToSegmentDistance","dist1","dist2","lineToLineDistance","line1","range1","line2","range2","dist","pointsToPointsDistance","points1","points2","pointToPolygonDistance","front","back","lineToPolygonDistance","polygonIntersect","poly1","poly2","polygonToPolygonDistance","polygon1","polygon2","currentMiniDist","ring1","len1","ring2","len2","updateQueue","distQueue","miniDist","rangeA","tempDist","updateQueueTwoSets","pointSet1","pointSet2","pointsToPolygonDistance","distPair","newRangesA","pointSetToPointSetDistance","isLine1","isLine2","rangeB","threshold1","threshold2","sublibe","newRangesB","pointToGeometryDistance","pointPosition","lineStringToGeometryDistance","linePositions","polygonToGeometryDistance","toSimpleGeometry","lineString","Distance","feature","expressions$1","CompoundExpression","evaluate","definition","availableOverloads","overloads","signature","signatureContext","params","isExpressionConstant","argParseFailed","signatures","stringifySignature","actualTypes","definitions","has","obj","get","v","binarySearch","varargs","isSupportedScript","isTypeAnnotation","childrenConstant","child","isFeatureConstant","isGlobalPropertyConstant","isStateConstant","properties","success","supportsPropertyExpression","spec","supportsZoomExpression","supportsInterpolation","getType","isFunction$1","identityFunction","createFunction","parameters","propertySpec","isColor","zoomAndFeatureDependent","featureDependent","zoomDependent","parseFn","stop","innerFun","hashedStops","categoricalKeyType","evaluateExponentialFunction","evaluateIntervalFunction","evaluateCategoricalFunction","evaluateIdentityFunction","featureFunctions","zoomStops","zoom","featureFunctionStops","interpolationType","coalesce$1","keyType","evaluated","interpolationFactor","interp","evaluatedLower","evaluatedUpper","StyleExpression","getDefaultValue","globals","featureState","availableImages","formattedSection","isExpression","createExpression","parser","getExpectedType","ZoomConstantExpression","ZoomDependentExpression","isZoomExpression","createPropertyExpression","expressionInput","isFeatureConstantResult","isZoomConstant","zoomCurve","findZoomCurve","StylePropertyFunction","specification","serialized","normalizePropertyExpression","err","constant","childResult","isExpressionFilter","filter","ColorBar","outContainer","innerContainer","heightExpression","parentHeight","percentage","group","title","unit","unitDiv","color","colorBox","_step","speed","legendItem","stepsHeight","stepHeight","showInterval","reverseIndex","parentContainer","parentWidth","marginTop","marginBottom","defMarginLeft","defMarginRight","marginLeft","marginRight","colorSpec","colorSteps","steps","defaultColor","pairs","maxSpeed","absSpeed","prop"],"mappings":"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","x_google_ignoreList":[2]}